<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>渲染模式通识 | 前端那些事儿</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/blog/logo.png">
    <link rel="manifest" href="/blog/manifest.json">
    <link rel="apple-touch-icon" href="/blog/images/icons/apple-icon-152x152.png">
    <meta name="description" content="我命由我不由天，学习吧少年">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
    <meta name="msapplication-TileColor" content="#000000">
    
    <link rel="preload" href="/blog/assets/css/0.styles.329e1c2e.css" as="style"><link rel="preload" href="/blog/assets/js/app.3fadfb99.js" as="script"><link rel="preload" href="/blog/assets/js/2.8bf77cff.js" as="script"><link rel="preload" href="/blog/assets/js/11.423e07d5.js" as="script"><link rel="preload" href="/blog/assets/js/4.ff6074e9.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.2e1f1296.js"><link rel="prefetch" href="/blog/assets/js/100.8ac8cdbc.js"><link rel="prefetch" href="/blog/assets/js/101.aee2b8c0.js"><link rel="prefetch" href="/blog/assets/js/102.c45d0ab0.js"><link rel="prefetch" href="/blog/assets/js/103.55d03437.js"><link rel="prefetch" href="/blog/assets/js/104.f80d61a8.js"><link rel="prefetch" href="/blog/assets/js/105.4830356c.js"><link rel="prefetch" href="/blog/assets/js/106.a2ed4cbe.js"><link rel="prefetch" href="/blog/assets/js/107.14a8c6ff.js"><link rel="prefetch" href="/blog/assets/js/108.29dcdcad.js"><link rel="prefetch" href="/blog/assets/js/109.ed3ad5de.js"><link rel="prefetch" href="/blog/assets/js/110.7dfde934.js"><link rel="prefetch" href="/blog/assets/js/111.11760cd5.js"><link rel="prefetch" href="/blog/assets/js/112.64fd31e7.js"><link rel="prefetch" href="/blog/assets/js/113.6e607dd1.js"><link rel="prefetch" href="/blog/assets/js/114.0d59c206.js"><link rel="prefetch" href="/blog/assets/js/115.a65d839e.js"><link rel="prefetch" href="/blog/assets/js/116.79ecc0ca.js"><link rel="prefetch" href="/blog/assets/js/117.80adbafb.js"><link rel="prefetch" href="/blog/assets/js/118.5860f134.js"><link rel="prefetch" href="/blog/assets/js/119.27520fb2.js"><link rel="prefetch" href="/blog/assets/js/12.a29783e3.js"><link rel="prefetch" href="/blog/assets/js/120.ca4462e8.js"><link rel="prefetch" href="/blog/assets/js/121.0fedffee.js"><link rel="prefetch" href="/blog/assets/js/122.c5f2e267.js"><link rel="prefetch" href="/blog/assets/js/123.60b1183f.js"><link rel="prefetch" href="/blog/assets/js/124.c85e571d.js"><link rel="prefetch" href="/blog/assets/js/125.2ce564a2.js"><link rel="prefetch" href="/blog/assets/js/126.57179830.js"><link rel="prefetch" href="/blog/assets/js/127.eba05af9.js"><link rel="prefetch" href="/blog/assets/js/128.d02d115e.js"><link rel="prefetch" href="/blog/assets/js/129.137859bf.js"><link rel="prefetch" href="/blog/assets/js/13.0a0a8660.js"><link rel="prefetch" href="/blog/assets/js/130.15698453.js"><link rel="prefetch" href="/blog/assets/js/131.c6af0ef1.js"><link rel="prefetch" href="/blog/assets/js/132.df0e87ae.js"><link rel="prefetch" href="/blog/assets/js/133.559a8ff5.js"><link rel="prefetch" href="/blog/assets/js/134.969af9a8.js"><link rel="prefetch" href="/blog/assets/js/135.a5e55ce8.js"><link rel="prefetch" href="/blog/assets/js/136.ff41831c.js"><link rel="prefetch" href="/blog/assets/js/137.c2c76065.js"><link rel="prefetch" href="/blog/assets/js/138.6a7b69e5.js"><link rel="prefetch" href="/blog/assets/js/139.d99f7f2c.js"><link rel="prefetch" href="/blog/assets/js/14.89bb6d33.js"><link rel="prefetch" href="/blog/assets/js/140.6bb0993e.js"><link rel="prefetch" href="/blog/assets/js/141.5f33ca9e.js"><link rel="prefetch" href="/blog/assets/js/142.fe7960b3.js"><link rel="prefetch" href="/blog/assets/js/143.bd329147.js"><link rel="prefetch" href="/blog/assets/js/144.da409c18.js"><link rel="prefetch" href="/blog/assets/js/145.d7804b81.js"><link rel="prefetch" href="/blog/assets/js/146.f42159d2.js"><link rel="prefetch" href="/blog/assets/js/147.ea18f004.js"><link rel="prefetch" href="/blog/assets/js/148.5c91fde6.js"><link rel="prefetch" href="/blog/assets/js/149.2656f9e9.js"><link rel="prefetch" href="/blog/assets/js/15.9c15f645.js"><link rel="prefetch" href="/blog/assets/js/150.20abb057.js"><link rel="prefetch" href="/blog/assets/js/151.eca0b8b7.js"><link rel="prefetch" href="/blog/assets/js/152.47b6a10b.js"><link rel="prefetch" href="/blog/assets/js/153.0e54d6fd.js"><link rel="prefetch" href="/blog/assets/js/154.24b843b3.js"><link rel="prefetch" href="/blog/assets/js/155.f4fc6d20.js"><link rel="prefetch" href="/blog/assets/js/156.017df8ca.js"><link rel="prefetch" href="/blog/assets/js/157.a3263d57.js"><link rel="prefetch" href="/blog/assets/js/158.3329d7f5.js"><link rel="prefetch" href="/blog/assets/js/159.a7caba92.js"><link rel="prefetch" href="/blog/assets/js/16.135dcaf5.js"><link rel="prefetch" href="/blog/assets/js/160.6a6e8ec8.js"><link rel="prefetch" href="/blog/assets/js/161.afa62aa5.js"><link rel="prefetch" href="/blog/assets/js/162.71d828b5.js"><link rel="prefetch" href="/blog/assets/js/163.c88692f1.js"><link rel="prefetch" href="/blog/assets/js/164.8251bf67.js"><link rel="prefetch" href="/blog/assets/js/165.e2875702.js"><link rel="prefetch" href="/blog/assets/js/166.e8e1e6e6.js"><link rel="prefetch" href="/blog/assets/js/167.ef2059fb.js"><link rel="prefetch" href="/blog/assets/js/168.cdc23b02.js"><link rel="prefetch" href="/blog/assets/js/169.2eefab1b.js"><link rel="prefetch" href="/blog/assets/js/17.6f58cfd1.js"><link rel="prefetch" href="/blog/assets/js/170.ce3fa57a.js"><link rel="prefetch" href="/blog/assets/js/171.2fff6416.js"><link rel="prefetch" href="/blog/assets/js/172.2b2d7eb7.js"><link rel="prefetch" href="/blog/assets/js/173.61637ed5.js"><link rel="prefetch" href="/blog/assets/js/174.c97e4800.js"><link rel="prefetch" href="/blog/assets/js/175.eff3398b.js"><link rel="prefetch" href="/blog/assets/js/176.dd941595.js"><link rel="prefetch" href="/blog/assets/js/177.90e9b27b.js"><link rel="prefetch" href="/blog/assets/js/178.51484ab5.js"><link rel="prefetch" href="/blog/assets/js/179.ea1cfce8.js"><link rel="prefetch" href="/blog/assets/js/18.11e73e23.js"><link rel="prefetch" href="/blog/assets/js/180.5fb5a7a5.js"><link rel="prefetch" href="/blog/assets/js/181.6020b17a.js"><link rel="prefetch" href="/blog/assets/js/182.7d8b01ed.js"><link rel="prefetch" href="/blog/assets/js/19.cde4fd51.js"><link rel="prefetch" href="/blog/assets/js/20.1f157ccc.js"><link rel="prefetch" href="/blog/assets/js/21.de811ecc.js"><link rel="prefetch" href="/blog/assets/js/22.b2a042a9.js"><link rel="prefetch" href="/blog/assets/js/23.5f8e06be.js"><link rel="prefetch" href="/blog/assets/js/24.36571354.js"><link rel="prefetch" href="/blog/assets/js/25.fbfe0052.js"><link rel="prefetch" href="/blog/assets/js/26.dc7df3f8.js"><link rel="prefetch" href="/blog/assets/js/27.3ac9e32a.js"><link rel="prefetch" href="/blog/assets/js/28.ee38feac.js"><link rel="prefetch" href="/blog/assets/js/29.a5515808.js"><link rel="prefetch" href="/blog/assets/js/3.6c93b5c9.js"><link rel="prefetch" href="/blog/assets/js/30.1dfd6b11.js"><link rel="prefetch" href="/blog/assets/js/31.42465964.js"><link rel="prefetch" href="/blog/assets/js/32.e4754258.js"><link rel="prefetch" href="/blog/assets/js/33.b3a02dc2.js"><link rel="prefetch" href="/blog/assets/js/34.6250006d.js"><link rel="prefetch" href="/blog/assets/js/35.62bbfabe.js"><link rel="prefetch" href="/blog/assets/js/36.f971cd67.js"><link rel="prefetch" href="/blog/assets/js/37.d7f9fc12.js"><link rel="prefetch" href="/blog/assets/js/38.7711db6a.js"><link rel="prefetch" href="/blog/assets/js/39.8326e514.js"><link rel="prefetch" href="/blog/assets/js/40.4aa5d949.js"><link rel="prefetch" href="/blog/assets/js/41.499a6f33.js"><link rel="prefetch" href="/blog/assets/js/42.e006b59b.js"><link rel="prefetch" href="/blog/assets/js/43.c2a93c21.js"><link rel="prefetch" href="/blog/assets/js/44.7b616777.js"><link rel="prefetch" href="/blog/assets/js/45.1e19e6c8.js"><link rel="prefetch" href="/blog/assets/js/46.848dd628.js"><link rel="prefetch" href="/blog/assets/js/47.e245a3a9.js"><link rel="prefetch" href="/blog/assets/js/48.12678395.js"><link rel="prefetch" href="/blog/assets/js/49.0cb83b5e.js"><link rel="prefetch" href="/blog/assets/js/5.727adf8a.js"><link rel="prefetch" href="/blog/assets/js/50.7ac657dc.js"><link rel="prefetch" href="/blog/assets/js/51.f4eb6fe0.js"><link rel="prefetch" href="/blog/assets/js/52.ce2a7f26.js"><link rel="prefetch" href="/blog/assets/js/53.4a17df90.js"><link rel="prefetch" href="/blog/assets/js/54.9038851f.js"><link rel="prefetch" href="/blog/assets/js/55.73935787.js"><link rel="prefetch" href="/blog/assets/js/56.17f69ab2.js"><link rel="prefetch" href="/blog/assets/js/57.d41e961f.js"><link rel="prefetch" href="/blog/assets/js/58.7c47fb80.js"><link rel="prefetch" href="/blog/assets/js/59.57c98278.js"><link rel="prefetch" href="/blog/assets/js/6.9723b38d.js"><link rel="prefetch" href="/blog/assets/js/60.2d8d205c.js"><link rel="prefetch" href="/blog/assets/js/61.086a1fac.js"><link rel="prefetch" href="/blog/assets/js/62.e50a6aba.js"><link rel="prefetch" href="/blog/assets/js/63.b2f3efaf.js"><link rel="prefetch" href="/blog/assets/js/64.93885dd3.js"><link rel="prefetch" href="/blog/assets/js/65.23d09604.js"><link rel="prefetch" href="/blog/assets/js/66.84f1ef02.js"><link rel="prefetch" href="/blog/assets/js/67.c0e564bc.js"><link rel="prefetch" href="/blog/assets/js/68.6ae7487c.js"><link rel="prefetch" href="/blog/assets/js/69.694b0591.js"><link rel="prefetch" href="/blog/assets/js/7.ae1b9be9.js"><link rel="prefetch" href="/blog/assets/js/70.5371842b.js"><link rel="prefetch" href="/blog/assets/js/71.63b31649.js"><link rel="prefetch" href="/blog/assets/js/72.92f11f86.js"><link rel="prefetch" href="/blog/assets/js/73.5991f4bf.js"><link rel="prefetch" href="/blog/assets/js/74.bd3d69e1.js"><link rel="prefetch" href="/blog/assets/js/75.6053e6d5.js"><link rel="prefetch" href="/blog/assets/js/76.84a05662.js"><link rel="prefetch" href="/blog/assets/js/77.f611378c.js"><link rel="prefetch" href="/blog/assets/js/78.3936f4e8.js"><link rel="prefetch" href="/blog/assets/js/79.1424f09d.js"><link rel="prefetch" href="/blog/assets/js/8.60aa9c8a.js"><link rel="prefetch" href="/blog/assets/js/80.6eca56ad.js"><link rel="prefetch" href="/blog/assets/js/81.4d525ce4.js"><link rel="prefetch" href="/blog/assets/js/82.7763533d.js"><link rel="prefetch" href="/blog/assets/js/83.c64e86e6.js"><link rel="prefetch" href="/blog/assets/js/84.3451d9d3.js"><link rel="prefetch" href="/blog/assets/js/85.1ce9f5ce.js"><link rel="prefetch" href="/blog/assets/js/86.c37fc614.js"><link rel="prefetch" href="/blog/assets/js/87.6ee9b5db.js"><link rel="prefetch" href="/blog/assets/js/88.60c727e1.js"><link rel="prefetch" href="/blog/assets/js/89.bbe12fed.js"><link rel="prefetch" href="/blog/assets/js/9.46c022d3.js"><link rel="prefetch" href="/blog/assets/js/90.f9d864bf.js"><link rel="prefetch" href="/blog/assets/js/91.6453cd96.js"><link rel="prefetch" href="/blog/assets/js/92.7e059b32.js"><link rel="prefetch" href="/blog/assets/js/93.a29de98a.js"><link rel="prefetch" href="/blog/assets/js/94.cbe8c47d.js"><link rel="prefetch" href="/blog/assets/js/95.81dc41f6.js"><link rel="prefetch" href="/blog/assets/js/96.4b5a16c1.js"><link rel="prefetch" href="/blog/assets/js/97.a68c6f32.js"><link rel="prefetch" href="/blog/assets/js/98.c14068d9.js"><link rel="prefetch" href="/blog/assets/js/99.6b7e7edd.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.329e1c2e.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/logo.png" alt="前端那些事儿" class="logo"> <span class="site-name can-hide">前端那些事儿</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/blog/base/" class="nav-link">
  前端基础
</a></div><div class="nav-item"><a href="/blog/vue/" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/blog/react/" class="nav-link">
  React
</a></div><div class="nav-item"><a href="/blog/node/" class="nav-link">
  Node
</a></div><div class="nav-item"><a href="/blog/devops/" class="nav-link">
  前端工程化
</a></div><div class="nav-item"><a href="/blog/mobile/" class="nav-link">
  泛客户端
</a></div><div class="nav-item"><a href="/blog/architecture/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  架构&amp;方案
</a></div><div class="nav-item"><a href="/blog/code/" class="nav-link">
  算法&amp;编程
</a></div><div class="nav-item"><a href="/blog/weekly/" class="nav-link">
  前端周刊
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="GitHub" class="dropdown-title"><span class="title">GitHub</span> <span class="arrow down"></span></button> <button type="button" aria-label="GitHub" class="mobile-dropdown-title"><span class="title">GitHub</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/jonny-wei" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/jonny-wei/sushi-js" target="_blank" rel="noopener noreferrer" class="nav-link external">
  JS 寿司
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/blog/base/" class="nav-link">
  前端基础
</a></div><div class="nav-item"><a href="/blog/vue/" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/blog/react/" class="nav-link">
  React
</a></div><div class="nav-item"><a href="/blog/node/" class="nav-link">
  Node
</a></div><div class="nav-item"><a href="/blog/devops/" class="nav-link">
  前端工程化
</a></div><div class="nav-item"><a href="/blog/mobile/" class="nav-link">
  泛客户端
</a></div><div class="nav-item"><a href="/blog/architecture/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  架构&amp;方案
</a></div><div class="nav-item"><a href="/blog/code/" class="nav-link">
  算法&amp;编程
</a></div><div class="nav-item"><a href="/blog/weekly/" class="nav-link">
  前端周刊
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="GitHub" class="dropdown-title"><span class="title">GitHub</span> <span class="arrow down"></span></button> <button type="button" aria-label="GitHub" class="mobile-dropdown-title"><span class="title">GitHub</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/jonny-wei" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/jonny-wei/sushi-js" target="_blank" rel="noopener noreferrer" class="nav-link external">
  JS 寿司
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>前端框架</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/architecture/" aria-current="page" class="active sidebar-link">渲染模式通识</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/architecture/#从-csr-到-ssr" class="sidebar-link">从 CSR 到 SSR</a></li><li class="sidebar-sub-header"><a href="/blog/architecture/#从-ssr-到-ssg" class="sidebar-link">从 SSR 到 SSG</a></li><li class="sidebar-sub-header"><a href="/blog/architecture/#从-ssg-到-isr-dpr" class="sidebar-link">从 SSG 到 ISR/DPR</a></li><li class="sidebar-sub-header"><a href="/blog/architecture/#混合渲染模式" class="sidebar-link">混合渲染模式</a></li><li class="sidebar-sub-header"><a href="/blog/architecture/#同构" class="sidebar-link">同构</a></li><li class="sidebar-sub-header"><a href="/blog/architecture/#小结" class="sidebar-link">小结</a></li></ul></li><li><a href="/blog/architecture/framework/Islands.html" class="sidebar-link">了解 Islands 架构</a></li><li><a href="/blog/architecture/micro-frontend.html" class="sidebar-link">微前端</a></li><li><a href="/blog/architecture/BFF.html" class="sidebar-link">BFF 中间层</a></li><li><a href="/blog/architecture/pwa.html" class="sidebar-link">PWA 与 service worker</a></li><li><a href="/blog/architecture/auth.html" class="sidebar-link">登录鉴权</a></li><li><a href="/blog/architecture/experience.html" class="sidebar-link">撸码点滴</a></li><li><a href="/blog/architecture/friendship-link.html" class="sidebar-link">友情链接</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>其他</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/architecture/others/web-worker.html" class="sidebar-link">Web Worker</a></li><li><a href="/blog/architecture/others/service-worker.html" class="sidebar-link">Service Worker</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="渲染模式通识"><a href="#渲染模式通识" class="header-anchor">#</a> 渲染模式通识</h1> <ul><li>CSR：Client Side Rendering，客户端（通常是浏览器）渲染；</li> <li>SSR：Server Side Rendering，服务端渲染；</li> <li>SSG：Static Site Generation，静态网站生成；</li> <li>ISR：Incremental Site Rendering，增量式的网站渲染；</li> <li>DPR：Distributed Persistent Rendering，分布式的持续渲染。</li></ul> <h2 id="从-csr-到-ssr"><a href="#从-csr-到-ssr" class="header-anchor">#</a> 从 CSR 到 SSR</h2> <p>CSR（Client Side Rendering），通俗的讲就是由客户端完成页面的渲染。其大致渲染流程是这样：在浏览器请求页面时，服务端先返回一个无具体内容的 HTML，浏览器还需要再加载并执行 JS，动态地将内容和数据渲染到页面中，才能完成页面具体内容的显示。</p> <p>CSR 的优点</p> <ul><li>由于客户端渲染架构包含静态文件，因此可以非常轻松地通过 CDN 提供服务；</li> <li>所有渲染都是在客户端完成的，因此 CSR 允许我们在不刷新整个页面的情况下进行导航，从而提供良好的用户体验。</li> <li>TTFB 时间很快，因此浏览器可以立即开始加载字体、CSS 和 JavaScript。</li></ul> <p>CSR 的缺点</p> <ul><li>由于所有内容都在客户端渲染，因此性能受到很大影响，因为用户首先需要下载并处理它才能看到页面上的内容。</li> <li>客户端渲染应用通常会在组件挂载时获取所需的数据，这会导致糟糕的用户体验，因为在初始页面加载时会遇到很多 loaders。此外，如果子组件需要获取数据，情况可能会变得更糟，这样它们的父组件获取完所有数据后才会渲染它们，这可能会导致大量 loaders 和糟糕的 Network Waterfall。</li> <li>SEO 是客户端渲染应用的一个问题，因为网络爬虫可以轻松读取服务端渲染的 HTML，但它们可能不会等待下载完所有 JavaScript 包，执行它们并等待客户端数据获取瀑布流完成 ，这可能会导致不正确的索引。</li></ul> <p>相比于客户端渲染，服务端渲染有什么优势？</p> <ul><li><p><strong>首屏时间更短</strong>。采用客户端渲染的页面，在 JS bundle 返回之前，页面一直是空白的。所以要拉取并执行 JS 代码，动态创建 DOM 结构，客户端逻辑越重，初始化需要执行的 JS 越多（bundle 体积过大）或者网络条件不好，首屏性能就越慢；客户端渲染前置的第三方类库/框架、polyfill 等都会在一定程度上拖慢首屏性能。Code splitting、lazy-load 等优化措施能够缓解一部分，但优化空间相对有限。相比而言，服务端渲染的页面直接拉取 HTML 就能显示内容，更短的首屏时间创造更多的可能性。</p></li> <li><p><strong>利于 SEO</strong>。在别人使用搜索引擎搜索相关的内容时，你的网页排行能靠得更前，这样你的流量就有越高，这就是SEO的意义所在。那为什么服务端渲染更利于爬虫爬你的页面呢？因为对于很多搜索引擎爬虫（非google）HTML返回是什么内容就爬什么内容，而不会动态执行 JS 代码内容。对客户端渲染的页面来说，简直无能为力，因为返回的 HTML 是一个空壳。而服务端渲染返回的HTML是有内容的。</p></li></ul> <p>SSR 的出现，就是为了解决这些 CSR 的弊端。</p> <h2 id="从-ssr-到-ssg"><a href="#从-ssr-到-ssg" class="header-anchor">#</a> 从 SSR 到 SSG</h2> <p>SSR (Server-side Rendering) ，顾名思义，就是在浏览器发起页面请求后由服务端完成页面的HTML结构拼接，返回给浏览器解析后能直接构建出有内容的页面。SSR 最早是为了解决单页应用（SPA）产生的 SEO、首屏渲染时间等问题而诞生的，在服务端直接实时同构渲染用户看到的页面，能最大程度上提高用户的体验，流程类似下面：</p> <p><img src="/blog/images/architecture/SSR1.png" alt="SSR1"></p> <p>React 从框架层面直接提供支持，只需要调用 <code>renderToString(Component)</code> 函数即可得到 HTML 内容。Next.js 提供 <code>getServerSideProps</code> 异步函数，以在 SSR 场景下获取额外的数据并返回给组件进行渲染。<code>getServerSideProps</code> 可以拿到每次请求的上下文（<code>Context</code>)，举个例子：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">FirstPost</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 在 props 中拿到数据</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span> title <span class="token punctuation">}</span> <span class="token operator">=</span> props<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>Layout<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span><span class="token punctuation">{</span>title<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>Layout<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">getServerSideProps</span><span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'context'</span><span class="token punctuation">,</span> context<span class="token punctuation">.</span>req<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 模拟获取数据</span>
  <span class="token keyword">const</span> title <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">getTitle</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span>req<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 把数据放在 props 对象中返回出去</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    props<span class="token operator">:</span> <span class="token punctuation">{</span>
      title
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>但 SSR 引入了另一个问题，既然要做服务端渲染，就必然<strong>需要一个实时在线的后台服务</strong>（通常是基于 Node.js 的服务）用来承载页面请求，那么：</p> <p>1、<strong>需要服务器的计算资源和公网流量</strong>来部署这套服务，并且消耗的资源与页面的访问量成正相关，当页面的访问量突增时，渲染服务也需要进行扩容；</p> <p>2、服务端只能部署在有限的几个地域，对于距离服务端较远的用户而言，<strong>加载速度跟静态资源的 CDN 相比，慢了一个数量级</strong>（通常是 1-5ms VS 50-100+ms）；</p> <p>3、日常也存在传统服务端同样的运维、监控告警等方面的负担，团队<strong>需要额外的人力来开发和维护</strong>。</p> <p>有没有办法解决这些问题呢？我们重新对 SSR 进行审视，服务端渲染出的页面，逻辑上讲可以分成下面两大块：</p> <p>1、<strong>变化不频繁，甚至不会变化的内容</strong>：例如文章、排行榜、商品信息、推荐列表等等，这些数据非常适合缓存；</p> <p>2、<strong>变化比较频繁，或者千人千面的内容</strong>：例如用户头像、Timeline、登录状态、实时评论等。</p> <p>例如，在一篇文章的页面中，文章的主题内容是偏向于静态的，很少有改动，那么每次用户的页面请求，都通过服务端来渲染就变得非常不值得，我们完全可以将文章的页面渲染为静态页面，至于页面内那些动态的内容（用户头像、评论框等），就通过 HTTP API 的形式进行浏览器端渲染（CSR）。那么这就是 静态站点生成（SSG，也叫构建时预渲染）所做的事情。</p> <p>SSG(Static Site Generation，也叫构建时预渲染) 是指在应用编译构建时预先渲染页面，并生成静态的 HTML。把生成的 HTML 静态资源部署到服务器后，浏览器不仅首次能请求到带页面内容的 HTML ，而且不需要服务器实时渲染和响应，大大节约了服务器运维成本和资源。</p> <p><img src="/blog/images/architecture/SSR2.png" alt="SSR2"></p> <p>这样做有很多好处：</p> <p>1、由于文章内容已经被静态化了，所以它是 SEO 友好的，能被搜索引擎轻松爬取；</p> <p>2、大大减轻了服务端渲染的资源负担，不需要额外做一套 Node.js 服务；</p> <p>3、用户始终通过 CDN 加载页面核心内容，CDN 的边缘节点有缓存，速度极快；</p> <p>4、通过 HTTP API + CSR，页面内次要的动态内容也可以被很好地渲染；</p> <p>5、数据有变化时，重新触发一次网站的异步渲染，然后推送新的内容到 CDN 即可。</p> <p>6、由于每次都是全站渲染，所以网站的版本可以很好的与 Git 的版本对应上，甚至可以做到原子化发布和回滚。</p> <p>这便是 Next.js、Gatsby.js 这样的网站生成器解决的问题，他们属于 React/Vue 更上一层的框架（Meta Framework），通过 SSR 把动态化的 Web 应用渲染为多个静态页面，并且对高度动态的内容也保留了 CSR 的能力。</p> <p>Next.js 默认为每个页面开启 SSG。对于页面内容需要依赖静态数据的场景，允许在每个页面中 <code>export</code> 一个 <code>getStaticProps</code> 异步函数，在这个函数中可以把该页面组件所需要的数据收集并返回。当 <code>getStaticProps</code> 函数执行完成后，页面组件就能在 <code>props</code> 中拿到这些数据并执行静态渲染。举个在静态路由中使用 SSG 的例子：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>
<span class="token comment">// pages/posts/first-post.js</span>
<span class="token keyword">function</span> <span class="token function">Post</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span> postData <span class="token punctuation">}</span> <span class="token operator">=</span> props<span class="token punctuation">;</span>
  
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span><span class="token punctuation">{</span>postData<span class="token punctuation">.</span>title<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">getStaticProps</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 模拟获取静态数据</span>
  <span class="token keyword">const</span> postData <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">getPostData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    props<span class="token operator">:</span> <span class="token punctuation">{</span> postData <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>对于动态路由的场景，Next.js 是如何做 SSG 的呢？Next.js 提供 <code>getStaticPaths</code> 异步函数，在这个方法中，会返回一个 <code>paths</code> 数组，这个数组包含了这个动态路由在构建时需要预渲染的页面数据。举个例子：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// pages/posts/[id].js</span>
<span class="token keyword">function</span> <span class="token function">Post</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span> postData <span class="token punctuation">}</span> <span class="token operator">=</span> props<span class="token punctuation">;</span>
  
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span><span class="token punctuation">{</span>postData<span class="token punctuation">.</span>title<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">getStaticPaths</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 返回该动态路由可能会渲染的页面数据，比如 params.id</span>
  <span class="token keyword">const</span> paths <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
      params<span class="token operator">:</span> <span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token string">'ssg-ssr'</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
      params<span class="token operator">:</span> <span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token string">'pre-rendering'</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    paths<span class="token punctuation">,</span>
    <span class="token comment">// 命中尚未生成静态页面的路由直接返回 404 页面</span>
    fallback<span class="token operator">:</span> <span class="token boolean">false</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">getStaticProps</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> params <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 使用 params.id 获取对应的静态数据</span>
  <span class="token keyword">const</span> postData <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">getPostData</span><span class="token punctuation">(</span>params<span class="token punctuation">.</span>id<span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    props<span class="token operator">:</span> <span class="token punctuation">{</span>
      postData
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br></div></div><p>当我们执行 <code>nextjs build</code> 后，可以看到打包结果包含 <code>pre-rendering.html</code> 和 <code>ssg-ssr.html</code> 两个 HTML 页面，也就是说在执行 SSG 时，会对 <code>getStaticPaths</code> 函数返回的 <code>paths</code> 数组进行循环，逐一预渲染页面组件并生成 HTML。</p> <h2 id="从-ssg-到-isr-dpr"><a href="#从-ssg-到-isr-dpr" class="header-anchor">#</a> 从 SSG 到 ISR/DPR</h2> <p>SSG 虽然很好解决了白屏时间过长和 SEO 不友好的问题，但是它仅仅适合于页面内容较为静态的场景，比如官网、博客等。面对页面数据更新频繁或页面数量很多的情况，它似乎显得有点束手无策，毕竟在静态构建时不能拿到最新的数据和无法枚举海量页面。</p> <p>例如，对于只有几十个页面的个人博客、小型文档站而言，数据有变化时，跑一次全页面渲染的消耗是可以接受的。但对于百万级、千万级、亿级页面的大型网站而言，一旦有数据改动，要进行一次全部页面的渲染，需要的时间可能是按小时甚至按天计的，这是不可接受的。</p> <p>为了解决这个问题，各种框架和静态网站托管平台都提供了不同的方案：</p> <h3 id="isr"><a href="#isr" class="header-anchor">#</a> ISR</h3> <p>既然全量预渲染整个网站是不现实的，那么我们可以做一个切分：</p> <p>1、<strong>关键性的页面</strong>（如网站首页、热点数据等）预渲染为静态页面，缓存至 CDN，保证最佳的访问性能；</p> <p>2、<strong>非关键性的页面</strong>（如流量很少的老旧内容）先响应 fallback 内容，然后浏览器渲染（CSR）为实际数据；同时对页面进行异步预渲染，之后缓存至 CDN，提升后续用户访问的性能。</p> <p><img src="/blog/images/architecture/SSR3.png" alt="SSR3"></p> <p>页面的更新始终返回 CDN 的缓存数据（无论是否过期）；如果数据已经过期，那么触发异步的预渲染，异步更新 CDN 的缓存。请求页面，页面数据未过期，返回预渲染页面。页面数据过期，拉取最新数据，重新预渲染。</p> <p>Next.js 推出的 ISR(Incremental Static Regeneration) 方案，允许<strong>在应用运行时再重新生成每个页面 HTML，而不需要重新构建整个应用</strong>。这样即使有海量页面，也能使用上 SSG 的特性。一般来说，使用 ISR 需要 <code>getStaticPaths</code> 和 <code>getStaticProps</code> 同时配合使用。举个例子：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// pages/posts/[id].js</span>
<span class="token keyword">function</span> <span class="token function">Post</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span> postData <span class="token punctuation">}</span> <span class="token operator">=</span> props<span class="token punctuation">;</span>
  
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span><span class="token punctuation">{</span>postData<span class="token punctuation">.</span>title<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">getStaticPaths</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> paths <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'https://.../posts'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    paths<span class="token punctuation">,</span>
    <span class="token comment">// 页面请求的降级策略，这里是指不降级，等待页面生成后再返回，类似于 SSR</span>
    fallback<span class="token operator">:</span> <span class="token string">'blocking'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">getStaticProps</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> params <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 使用 params.id 获取对应的静态数据</span>
  <span class="token keyword">const</span> postData <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">getPostData</span><span class="token punctuation">(</span>params<span class="token punctuation">.</span>id<span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    props<span class="token operator">:</span> <span class="token punctuation">{</span>
      postData
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// 开启 ISR，最多每10s重新生成一次页面</span>
    revalidate<span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p>在应用编译构建阶段，会生成已经确定的静态页面，和上面 SSG 执行流程一致。</p> <p>在 <code>getStaticProps</code> 函数返回的对象中增加 <code>revalidate</code> 属性，表示开启 ISR。在上面的例子中，指定 <code>revalidate = 10</code>，表示最多10秒内重新生成一次静态 HTML。当浏览器请求已在构建时渲染生成的页面时，首先返回的是缓存的 HTML，10s 后页面开始重新渲染，页面成功生成后，更新缓存，浏览器再次请求页面时就能拿到最新渲染的页面内容了。</p> <p>对于浏览器请求构建时未生成的页面时，会马上生成静态 HTML。在这个过程中，<code>getStaticPaths</code> 返回的 <code>fallback</code> 字段有以下的选项：</p> <ul><li><code>fallback: 'blocking'</code>：不降级，并且要求用户请求一直等到新页面静态生成结束，静态页面生成结束后会缓存</li> <li><code>fallback: true</code>：降级，先返回降级页面，当静态页面生成结束后，会返回一个 JSON 供降级页面 CSR 使用，经过二次渲染后，完整页面出来了</li></ul> <p>在上面的例子中，使用的是不降级方案(<code>fallback: 'blocking'</code>)，实际上和 SSR 方案有相似之处，都是阻塞渲染，只不过多了缓存而已。也不是所有场景都适合使用 ISR。对于实时性要求较高的场景，比如新闻资讯类的网站，可能 SSR 才是最好的选择。</p> <p>但 ISR 存在部分缺陷：</p> <p>1、对于没有预渲染的页面，用户首次访问将会看到一个 fallback 页面，此时服务端才开始渲染页面，直到渲染完毕。这就导致用户<strong>体验上的不一致</strong>。</p> <p>2、对于已经被预渲染的页面，用户直接从 CDN 加载，但这些页面可能是已经过期，甚至过期很久的，<strong>只有在用户刷新一次，第二次访问之后，才能看到新的数据</strong>。对于电商这样的场景而言，是不可接受的（比如商品已经卖完了，但用户看到的过期数据上显示还有）。</p> <h3 id="dpr"><a href="#dpr" class="header-anchor">#</a> DPR</h3> <p>为了解决 ISR 的一系列问题，Netlify 在前段时间发起了一个新的提案 - Distributed Persistent Rendering (DPR)。DPR 本质上讲，是对 ISR 的模型做了几处改动，并且搭配上 CDN 的能力：</p> <p>1、去除了 fallback 行为，而是直接用 On-demand Builder（按需构建器）来响应未经过预渲染的页面，然后将结果缓存至 CDN；</p> <p>2、数据页面过期时，不再响应过期的缓存页面，而是 CDN 回源到 Builder 上，渲染出最新的数据；</p> <p>3、每次发布新版本时，自动清除 CDN 的缓存数据。</p> <p>当然 DPR 还在很初期的阶段，就目前的讨论来看，依然有一些问题：</p> <ul><li>新页面的访问可能会触发 On-demand Builder 同步渲染，导致当次请求的响应时间比较长；</li> <li>比较难防御 DoS 攻击，因为攻击者可能会大量访问新页面，导致 Builder 被大量并行地运行，这里需要平台方实现 Builder 的归一化和串行运行。</li></ul> <h2 id="混合渲染模式"><a href="#混合渲染模式" class="header-anchor">#</a> 混合渲染模式</h2> <h3 id="ssr-csr"><a href="#ssr-csr" class="header-anchor">#</a> SSR + CSR</h3> <p>SSR 似乎已经解决了 CSR 带来的问题，那是不是 CSR 完全没有用武之地呢？其实并不是。使用 CSR 时，页面切换无需刷新，无需重新请求整个 HTML 的内容。既然如此，可以各取所长，各补其短，于是就有 SSR + CSR 的方案：</p> <ul><li>首次加载页面走 SSR：保证首屏加载速度的同时，并且满足 SEO 的诉求</li> <li>页面切换走 CSR：Next.js 会发起一次网络请求，执行 <code>getServerSideProps</code> 函数，拿到它返回的数据后，进行页面渲染。</li></ul> <p>二者的有机结合，大大减少后端服务器的压力和成本的同时，也能提高页面切换的速度，进一步提升用户的体验。</p> <h3 id="ssg-csr"><a href="#ssg-csr" class="header-anchor">#</a> SSG + CSR</h3> <p>SSR 需要较高的服务器运维成本。对于某些静态网站或者实时性要求较低的网站来说，是没有必要使用 SSR 的。假如用 SSG 代替 SSR，使用 SSG + CSR 方案，是不是会更好：</p> <ul><li>静态内容走 SSG：对于页面中较为静态的内容，比如导航栏、布局等，可以在编译构建时预先渲染静态 HTML</li> <li>动态内容走 CSR：一般会在 <code>useEffect</code> 中请求接口获取动态数据，然后进行页面重新渲染</li></ul> <p>虽然从体验来说，动态内容需要页面重新渲染后才能出现，体验上没有 SSR 好，但是避免 SSR 带来的高额服务器成本的同时，也能保证首屏渲染时间不会太长，相比纯 CSR 来说，还是提升了用户体验。</p> <h3 id="ssg-ssr"><a href="#ssg-ssr" class="header-anchor">#</a> SSG + SSR</h3> <p>在上面介绍的 ISR 方案时提及过，ISR 的实质是 SSG + SSR：</p> <ul><li>静态内容走 SSG：编译构建时把相对静态的页面预先渲染生成 HTML，浏览器请求时直接返回静态 HTML</li> <li>动态内容走 SSR：浏览器请求未预先渲染的页面，在运行时通过 SSR 渲染生成页面，然后返回到浏览器，并缓存静态 HTML，下次命中缓存时直接返回</li></ul> <p>ISR 相比于 SSG + CSR 来说，动态内容可以直接直出，进一步提升了首次访问页面时的体验；相比于 SSR + CSR 来说，减少没必要的静态页面渲染，节省了一部分后端服务器成本。</p> <h2 id="同构"><a href="#同构" class="header-anchor">#</a> 同构</h2> <p>上述知道了 SSR 的优缺点，并不是所有的 WEB 应用都必须使用 SSR，这需要开发者自己来权衡，因为服务端渲染会带来以下问题：</p> <ul><li>代码复杂度增加。为了实现服务端渲染，应用代码中需要兼容服务端和客户端两种运行情况，而一部分依赖的外部扩展库却只能在客户端运行，需要对其进行特殊处理，才能在服务器渲染应用程序中运行。</li> <li>需要更多的服务器负载均衡。由于服务器增加了渲染HTML的需求，使得原本只需要输出静态资源文件的 node 服务，新增了数据获取的 IO 和渲染 HTML 的 CPU 占用，如果流量突然暴增，有可能导致服务器down机，因此需要使用响应的缓存策略和准备相应的服务器负载。</li> <li>涉及构建设置和部署的更多要求。与可以部署在任何静态文件服务器上的完全静态单页面应用程序 (SPA) 不同，服务器渲染应用程序，需要处于 <code>Node.js server</code> 运行环境。</li></ul> <p>假如我们需要在项目中使用服务端渲染，我们需要做什么呢？那就是同构我们的项目。</p> <h3 id="同构定义"><a href="#同构定义" class="header-anchor">#</a> 同构定义</h3> <p>在服务端渲染中，有两种页面渲染的方式：</p> <ul><li>前端服务器通过请求后端服务器获取数据并组装HTML返回给浏览器，浏览器直接解析HTML后渲染页面</li> <li>浏览器在交互过程中，请求新的数据并动态更新渲染页面</li></ul> <p>这两种渲染方式有一个不同点就是，一个是在服务端中组装html的，一个是在客户端中组装html的，运行环境是不一样的。所谓同构，就是让一份代码，既可以在服务端中执行，也可以在客户端中执行，并且执行的效果都是一样的，都是完成这个html的组装，正确的显示页面。也就是说，一份代码，既可以客户端渲染，也可以服务端渲染。</p> <h3 id="同构条件"><a href="#同构条件" class="header-anchor">#</a> 同构条件</h3> <p>为了实现同构，我们需要满足什么条件呢？首先，我们思考一个应用中一个页面的组成，假如我们使用的是<code>Vue.js</code>，当我们打开一个页面时，首先是打开这个页面的URL，这个URL，可以通过应用的<code>路由</code>匹配，找到具体的页面，不同的页面有不同的视图，那么，视图是什么？从应用的角度来看，视图 = <code>模板</code> + <code>数据</code>，那么在 Vue.js 中， 模板可以理解成<code>组件</code>，数据可以理解为<code>数据模型</code>，即响应式数据。所以，对于同构应用来说，我们必须实现客户端与服务端的路由、模型组件、数据模型的共享。</p> <h2 id="小结"><a href="#小结" class="header-anchor">#</a> 小结</h2> <p>CSR、SSR、SSG 并不是渲染技术的最新趋势。虽然 SSR 和 SSG 在几年前开启了性能优化趋势，但增量静态再生 (ISR) 和流式 SSR 等更细分的渲染技术开始活跃起来。前者推进了 SSG，因为它允许在每个页面的基础上静态重新构建网站（例如，每 60 秒重新构建页面 X）而不是重新构建整个网站。按需 ISR，也称为按需重新验证，可用于通过应用公开的 API 触发重新构建（例如，当 CMS 数据更新时）。</p> <p>另一方面，Streaming SSR 优化了服务端渲染的单线程瓶颈。普通 SSR 必须在服务器上等待数据将渲染的内容立即发送到客户端，而流式 SSR 允许开发人员将应用分成块，这些块可以逐步从服务器并行发送到客户端。</p> <p>在过去几年中，SPA/MPA 中的 SSG 和 SSR 渲染模式非常简单。然而，如今更细分的版本正在流行，除了 ISR 和流式 SSR，部分水合（例如 React 服务端组件）允许仅在客户端上水合某些组件，渐进式水合可以对水合顺序进行更细粒度的控制，Island 用于 MPA 中的隔离应用或组件的架构（例如 Astro ）以及使用可恢复性而不是水合作用（例如 Qwik）。</p> <p><a href="https://mp.weixin.qq.com/s/x07fhB1LT7L2Pq0yt34iqA" target="_blank" rel="noopener noreferrer">新一代Web技术栈的演进：SSR/SSG/ISR/DPR都在做什么<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://mp.weixin.qq.com/s/tDPkTwrR031CjsWbiVTVGw" target="_blank" rel="noopener noreferrer">Next.js 是怎么做预渲染的<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://juejin.cn/post/6844903881390964744#heading-5" target="_blank" rel="noopener noreferrer">从头开始，彻底理解服务端渲染原理<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://juejin.cn/post/6856321751115431944#heading-33" target="_blank" rel="noopener noreferrer">从头到尾彻底理解服务端渲染SSR原理<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/blog/architecture/framework/Islands.html">
        了解 Islands 架构
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----><!----><!----></div></div>
    <script src="/blog/assets/js/app.3fadfb99.js" defer></script><script src="/blog/assets/js/2.8bf77cff.js" defer></script><script src="/blog/assets/js/11.423e07d5.js" defer></script><script src="/blog/assets/js/4.ff6074e9.js" defer></script>
  </body>
</html>
