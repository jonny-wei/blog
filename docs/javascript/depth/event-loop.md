# 事件循环

了解 **事件循环** 前，有必要先了解浏览器进程，浏览器渲染进程下的多线程， js 为什么采用单线程。 具体见 [浏览器渲染](../browser/browser-render)

![事件循环](/blog/images/javascript/事件循环.png)

JavaScript代码的执行过程中，除了依靠函数调用栈来搞定函数的执行顺序外，还依靠任务队列(task queue)来搞定另外一些代码的执行。整个执行过程，我们称为**事件循环过程**。

## 事件循环机制

Chrome 中的事件循环：

![chrome事件循环](/blog/images/javascript/chrome事件循环.png)

现在知道页面主线程是如何接收外部任务了：如果其他进程想要发送任务给页面主线程，那么先通过 IPC 把任务发送给渲染进程的 IO 线程，IO 线程再把任务发送给页面主线程

chromium 内核基本的事件循环系统：

- JavaScript V8引擎在渲染进程的主线程上工作
- 主线程有循环机制，能在线程运行过程中，能接收并执行新的任务
- 交给主线程执行的任务会先放入任务队列中，等待主线程空闲后依次调用
- 渲染进程会有一个 IO 线程：IO 线程负责和其它进程 IPC 通信，接收其他进程传进来的消息

::: tip 事件循环执行流程
1. 检查 Macrotask 队列是否为空，若不为空，则进行下一步，若为空，则跳到 3
3. 从 Macrotask 队列中取队首(在队列时间最长)的任务进去执行栈中执行(仅仅一个)，执行完后进入下一步
3. 检查 Microtask 队列是否为空，若不为空，则进入下一步，否则，跳到 1（开始新的事件循环）
4. 从 Microtask 队列中取队首(在队列时间最长)的任务进去事件队列执行，执行完后，跳到 3 其中，在执行代码过程中新增的 microtask 任务会在当前事件循环周期内执行，而新增的 macrotask 任务只能等到下一个事件循环才能执行了。
:::

页面线程所有执行的任务都来自于任务队列。任务队列是“先进先出”的，也就是说放入队列中的任务，需要等待前面的任务被执行完，才会被执行。这就导致两个问题了：

- 如何处理高优先级的任务？
- 如何处理执行时间长的任务？

## 处理高优先级的任务

微任务。

解决方案 V8 引擎已经给出了：在每个任务内部，开辟一个属于该任务的队列(任务队列)，把需要兼顾实时性和效率的任务，先放到这个任务内部的队列中等待执行，等到当前任务快执行完准备退出前，执行该任务内部的队列。咱们把放入到这个特殊队列中的任务称为 **微任务**。

这样既不会影响当前的任务又不会降低多少实时性。

![微任务](/blog/images/javascript/微任务.png)

- 任务队列中的任务都是宏观任务
- 每个宏观任务都有一个自己的微任务队列
- 微任务在当前宏任务中的 JavaScript 快执行完成时，也就在 V8 引擎准备退出全局执行上下文并清空调用栈的时候，V8 引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务。
- V8 引擎一直循环执行微任务队列中的任务，直到队列为空才算执行结束。也就是说在执行微任务过程中产生的新的微任务并不会推迟到下个宏任务中执行，而是在当前的宏任务中继续执行。

::: tip 注意
宿主（如浏览器）发起的任务称为宏观任务
JavaScript 引擎发起的任务称为微观任务
:::

一个线程中，事件循环是唯一的，但是任务队列可以拥有多个。任务队列又分为 **macro-task（宏任务）** 与 **micro-task（微任务）**，在最新标准中，它们被分别称为 task 与 jobs。

### 宏任务与微任务

**macro-task 宏任务** 大概包括：

- script(整体代码)
- setTimeout
- setInterval
- setImmediate
- I/O
- UI render


**micro-task 微任务** 大概包括:

- process.nextTick
- Promise
- Async/Await(实际就是promise)
- MutationObserver(html5新特性)
- Object.observe(已废弃)

## 处理执行时间长的任务

回调。

要知道**排版引擎 Blink** 和 **JavaScript引擎 V8** 都工作在渲染进程的主线程上并且是互斥的。在单线程中，每次只能执行一个任务，而其他任务就都处于等待状态。如果其中一个任务执行时间过久，那么下一个任务就要等待很长时间。这当然是非常糟糕的用户体验。想要避免这种问题，就需要用到回调来解决。

setTimeout/Promise 等我们称之为任务源。而进入任务队列的是他们指定的具体执行任务。来自不同任务源的任务会进入到不同的任务队列。其中 setTimeout 与 setInterval 是同源的。

## 事件循环顺序

事件循环的顺序，决定了 JavaScript 代码的执行顺序。它从 script (整体代码) 开始第一次循环。之后全局上下文进入函数调用栈。直到调用栈清空(只剩全局)，然后执行所有的 micro-task。当所有可执行的 micro-task 执行完毕之后。循环再次从 macro-task 开始，找到其中一个任务队列执行完毕，然后再执行所有的 micro-task，这样一直循环下去。其中每一个任务的执行，无论是 macro-task 还是 micro-task，都是借助函数调用栈来完成。

总的结论就是，执行宏任务，然后执行该宏任务产生的微任务，若微任务在执行过程中产生了新的微任务，则继续执行微任务，微任务执行完毕后，再回到宏任务中进行下一轮循环。

