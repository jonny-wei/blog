<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>初始化与模块安装 | 花帽子的博客</title>
    <meta name="generator" content="VuePress 1.7.1">
    <link rel="icon" href="/blog/logo.png">
    <link rel="manifest" href="/blog/manifest.json">
    <link rel="apple-touch-icon" href="/blog/images/icons/apple-icon-152x152.png">
    <meta name="description" content="我命由我不由天，学习吧少年">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
    <meta name="msapplication-TileColor" content="#000000">
    
    <link rel="preload" href="/blog/assets/css/0.styles.4a49bc7c.css" as="style"><link rel="preload" href="/blog/assets/js/app.8c0e21f4.js" as="script"><link rel="preload" href="/blog/assets/js/2.2a4e8c54.js" as="script"><link rel="preload" href="/blog/assets/js/39.13426ff2.js" as="script"><link rel="preload" href="/blog/assets/js/3.07d27621.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.a1529350.js"><link rel="prefetch" href="/blog/assets/js/11.c1a0135c.js"><link rel="prefetch" href="/blog/assets/js/12.99ded477.js"><link rel="prefetch" href="/blog/assets/js/13.2521a16e.js"><link rel="prefetch" href="/blog/assets/js/14.133aa108.js"><link rel="prefetch" href="/blog/assets/js/15.6d4bda15.js"><link rel="prefetch" href="/blog/assets/js/16.ba074823.js"><link rel="prefetch" href="/blog/assets/js/17.301089ac.js"><link rel="prefetch" href="/blog/assets/js/18.322991d6.js"><link rel="prefetch" href="/blog/assets/js/19.ec1e3725.js"><link rel="prefetch" href="/blog/assets/js/20.1783200a.js"><link rel="prefetch" href="/blog/assets/js/21.0c26b5a2.js"><link rel="prefetch" href="/blog/assets/js/22.52e001de.js"><link rel="prefetch" href="/blog/assets/js/23.23588340.js"><link rel="prefetch" href="/blog/assets/js/24.db64810d.js"><link rel="prefetch" href="/blog/assets/js/25.66cef743.js"><link rel="prefetch" href="/blog/assets/js/26.5e4dba4d.js"><link rel="prefetch" href="/blog/assets/js/27.784c53fa.js"><link rel="prefetch" href="/blog/assets/js/28.7fa06bfa.js"><link rel="prefetch" href="/blog/assets/js/29.8555f961.js"><link rel="prefetch" href="/blog/assets/js/30.8f0c5b22.js"><link rel="prefetch" href="/blog/assets/js/31.491bf9df.js"><link rel="prefetch" href="/blog/assets/js/32.ed67849a.js"><link rel="prefetch" href="/blog/assets/js/33.85317e03.js"><link rel="prefetch" href="/blog/assets/js/34.03e230e0.js"><link rel="prefetch" href="/blog/assets/js/35.7918ce2c.js"><link rel="prefetch" href="/blog/assets/js/36.a6ec54e2.js"><link rel="prefetch" href="/blog/assets/js/37.1efa4804.js"><link rel="prefetch" href="/blog/assets/js/38.fedd23b0.js"><link rel="prefetch" href="/blog/assets/js/4.2bef4353.js"><link rel="prefetch" href="/blog/assets/js/40.5681cfae.js"><link rel="prefetch" href="/blog/assets/js/41.77314b0c.js"><link rel="prefetch" href="/blog/assets/js/42.04df6381.js"><link rel="prefetch" href="/blog/assets/js/43.6c0cc2ec.js"><link rel="prefetch" href="/blog/assets/js/44.e2d4ba71.js"><link rel="prefetch" href="/blog/assets/js/45.d4830d14.js"><link rel="prefetch" href="/blog/assets/js/5.5d40c251.js"><link rel="prefetch" href="/blog/assets/js/6.08d6e999.js"><link rel="prefetch" href="/blog/assets/js/7.96560134.js"><link rel="prefetch" href="/blog/assets/js/8.f4a7eed1.js"><link rel="prefetch" href="/blog/assets/js/9.72652230.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.4a49bc7c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/logo.png" alt="花帽子的博客" class="logo"> <span class="site-name can-hide">花帽子的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/blog/vue/vue/vue-render.html" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/blog/css/basis/abstract.html" class="nav-link">
  CSS
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JS系列菜单" class="dropdown-title"><span class="title">JS</span> <span class="arrow down"></span></button> <button type="button" aria-label="JS系列菜单" class="mobile-dropdown-title"><span class="title">JS</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/javascript/book/chapter1.html" class="nav-link">
  JavaScript红宝书
</a></li></ul></div></div><div class="nav-item"><a href="/blog/typescript/" class="nav-link">
  TS
</a></div><div class="nav-item"><a href="/blog/optimization/" class="nav-link">
  优化
</a></div><div class="nav-item"><a href="/blog/mobile/" class="nav-link">
  移动端
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="GitHub" class="dropdown-title"><span class="title">GitHub</span> <span class="arrow down"></span></button> <button type="button" aria-label="GitHub" class="mobile-dropdown-title"><span class="title">GitHub</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/jonny-wei" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub地址
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/blog/vue/vue/vue-render.html" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/blog/css/basis/abstract.html" class="nav-link">
  CSS
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JS系列菜单" class="dropdown-title"><span class="title">JS</span> <span class="arrow down"></span></button> <button type="button" aria-label="JS系列菜单" class="mobile-dropdown-title"><span class="title">JS</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/javascript/book/chapter1.html" class="nav-link">
  JavaScript红宝书
</a></li></ul></div></div><div class="nav-item"><a href="/blog/typescript/" class="nav-link">
  TS
</a></div><div class="nav-item"><a href="/blog/optimization/" class="nav-link">
  优化
</a></div><div class="nav-item"><a href="/blog/mobile/" class="nav-link">
  移动端
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="GitHub" class="dropdown-title"><span class="title">GitHub</span> <span class="arrow down"></span></button> <button type="button" aria-label="GitHub" class="mobile-dropdown-title"><span class="title">GitHub</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/jonny-wei" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub地址
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Vue秘籍</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/vue/vue/guide.html" class="sidebar-link">js 高级技巧</a></li><li><a href="/blog/vue/vue/vue-render.html" class="sidebar-link">vue渲染原理</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Vue源码解析</span> <!----></p> <!----></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>VueRouter源码解析</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/vue/vue-router/abstract.html" class="sidebar-link">摘要</a></li><li><a href="/blog/vue/vue-router/warmUp.html" class="sidebar-link">准备工作</a></li><li><a href="/blog/vue/vue-router/plugin.html" class="sidebar-link">插件机制</a></li><li><a href="/blog/vue/vue-router/initialization.html" class="sidebar-link">初始化与降级处理</a></li><li><a href="/blog/vue/vue-router/transitions.html" class="sidebar-link">路由过渡与视图渲染</a></li><li><a href="/blog/vue/vue-router/match.html" class="sidebar-link">路由匹配</a></li><li><a href="/blog/vue/vue-router/scroll.html" class="sidebar-link">滚动行为处理</a></li><li><a href="/blog/vue/vue-router/summary.html" class="sidebar-link">总结</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Vuex源码解析</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/vue/vuex/abstract.html" class="sidebar-link">摘要</a></li><li><a href="/blog/vue/vuex/warmUp.html" class="sidebar-link">准备工作</a></li><li><a href="/blog/vue/vuex/initialization.html" aria-current="page" class="active sidebar-link">初始化与模块安装</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/vue/vuex/initialization.html#入口文件" class="sidebar-link">入口文件</a></li><li class="sidebar-sub-header"><a href="/blog/vue/vuex/initialization.html#安装" class="sidebar-link">安装</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/vue/vuex/initialization.html#applymixin-的实现" class="sidebar-link">applyMixin 的实现</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/vue/vuex/initialization.html#实例化-store" class="sidebar-link">实例化 Store</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/vue/vuex/initialization.html#store-类" class="sidebar-link">Store 类</a></li><li class="sidebar-sub-header"><a href="/blog/vue/vuex/initialization.html#store-类构造方法" class="sidebar-link">Store 类构造方法</a></li><li class="sidebar-sub-header"><a href="/blog/vue/vuex/initialization.html#模块收集器" class="sidebar-link">模块收集器</a></li><li class="sidebar-sub-header"><a href="/blog/vue/vuex/initialization.html#module-类" class="sidebar-link">Module 类</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/vue/vuex/initialization.html#模块安装" class="sidebar-link">模块安装</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/vue/vuex/initialization.html#installmodule-的实现" class="sidebar-link">installModule 的实现</a></li><li class="sidebar-sub-header"><a href="/blog/vue/vuex/initialization.html#命名空间" class="sidebar-link">命名空间</a></li><li class="sidebar-sub-header"><a href="/blog/vue/vuex/initialization.html#makelocalcontext-的实现" class="sidebar-link">makeLocalContext 的实现</a></li><li class="sidebar-sub-header"><a href="/blog/vue/vuex/initialization.html#makelocalgetters-的实现" class="sidebar-link">makeLocalGetters 的实现</a></li><li class="sidebar-sub-header"><a href="/blog/vue/vuex/initialization.html#getnestedstate-的实现" class="sidebar-link">getNestedState 的实现</a></li><li class="sidebar-sub-header"><a href="/blog/vue/vuex/initialization.html#registermutation-的实现" class="sidebar-link">registerMutation 的实现</a></li><li class="sidebar-sub-header"><a href="/blog/vue/vuex/initialization.html#registeraction-的实现" class="sidebar-link">registerAction 的实现</a></li><li class="sidebar-sub-header"><a href="/blog/vue/vuex/initialization.html#registergetter-的实现" class="sidebar-link">registerGetter 的实现</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/vue/vuex/initialization.html#resetstorevm" class="sidebar-link">resetStoreVM</a></li></ul></li><li><a href="/blog/vue/vuex/state.html" class="sidebar-link">State 相关</a></li><li><a href="/blog/vue/vuex/getters.html" class="sidebar-link">Getters 相关</a></li><li><a href="/blog/vue/vuex/mutations.html" class="sidebar-link">Mutations 相关</a></li><li><a href="/blog/vue/vuex/actions.html" class="sidebar-link">Actions 相关</a></li><li><a href="/blog/vue/vuex/modules.html" class="sidebar-link">Modules 相关</a></li><li><a href="/blog/vue/vuex/others.html" class="sidebar-link">其他</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Vue3新特性</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/vue/vue3.x/abstract.html" class="sidebar-link">摘要</a></li><li><a href="/blog/vue/vue3.x/reactivity.html" class="sidebar-link">响应式系统</a></li><li><a href="/blog/vue/vue3.x/features.html" class="sidebar-link">功能方面</a></li><li><a href="/blog/vue/vue3.x/performance.html" class="sidebar-link">性能方面</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="初始化与模块安装"><a href="#初始化与模块安装" class="header-anchor">#</a> 初始化与模块安装</h1> <p>上一章节我们有讲到 vuex 的使用，现在来回顾一下：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// store.js</span>
<span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span>
<span class="token keyword">import</span> Vuex <span class="token keyword">from</span> <span class="token string">'vuex'</span>

Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Vuex<span class="token punctuation">)</span>

<span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>如你所见 Vuex 也是使用 vue 的 <a href="/blog/vue/vue-router/plugin.html">插件机制</a>。<code>import Vuex from 'vuex'</code> 这句主要将 <code>vuex</code> 的 <code>src/index.js</code> 中 <code>export</code>
的方法导入进来。<code>Vue.use(Vuex)</code> 执行这句将自动调用 <code>vuex</code> 暴露的 <code>install</code> 方法进行 <code>vuex</code> 的安装或者叫注册。再接着 <code>new Vuex.Store({ ... })</code>
执行 <code>vuex</code> 暴露的 <code>Store</code> 方法，实例化一个 <code>store</code>，完成初始化。</p> <h2 id="入口文件"><a href="#入口文件" class="header-anchor">#</a> 入口文件</h2> <p>vuex 暴露的方法在入口文件 <code>src/index.js</code> 文件中，下面具体看一下</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/* src/index.js */</span>

<span class="token keyword">import</span> <span class="token punctuation">{</span> Store<span class="token punctuation">,</span> install <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./store'</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> mapState<span class="token punctuation">,</span> mapMutations<span class="token punctuation">,</span> mapGetters<span class="token punctuation">,</span> mapActions<span class="token punctuation">,</span> 
createNamespacedHelpers <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./helpers'</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  Store<span class="token punctuation">,</span> <span class="token comment">// Store vuex的核心 去初始化一个 store</span>
  install<span class="token punctuation">,</span> <span class="token comment">// vuex 插件安装 Vue.use(Vuex) 时自动调用</span>
  version<span class="token operator">:</span> <span class="token string">'__VERSION__'</span><span class="token punctuation">,</span>
  <span class="token comment">/* 4 个辅助函数 */</span>
  mapState<span class="token punctuation">,</span> 
  mapMutations<span class="token punctuation">,</span>
  mapGetters<span class="token punctuation">,</span>
  mapActions<span class="token punctuation">,</span>
  <span class="token comment">/* 命名空间 */</span>
  createNamespacedHelpers
<span class="token punctuation">}</span>
</code></pre></div><p>此外，<code>vuex</code> 还有一个入口文件 <code>src/index.esm.js</code>：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/* src/index.esm.js */</span>

<span class="token keyword">import</span> <span class="token punctuation">{</span> Store<span class="token punctuation">,</span> install <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./store'</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> mapState<span class="token punctuation">,</span> mapMutations<span class="token punctuation">,</span> mapGetters<span class="token punctuation">,</span> mapActions<span class="token punctuation">,</span>
 createNamespacedHelpers <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./helpers'</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  Store<span class="token punctuation">,</span>
  install<span class="token punctuation">,</span>
  version<span class="token operator">:</span> <span class="token string">'__VERSION__'</span><span class="token punctuation">,</span>
  mapState<span class="token punctuation">,</span>
  mapMutations<span class="token punctuation">,</span>
  mapGetters<span class="token punctuation">,</span>
  mapActions<span class="token punctuation">,</span>
  createNamespacedHelpers
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token punctuation">{</span>
  Store<span class="token punctuation">,</span>
  install<span class="token punctuation">,</span>
  mapState<span class="token punctuation">,</span>
  mapMutations<span class="token punctuation">,</span>
  mapGetters<span class="token punctuation">,</span>
  mapActions<span class="token punctuation">,</span>
  createNamespacedHelpers
<span class="token punctuation">}</span>

</code></pre></div><p>基本和 <code>src/index.js</code> 一样，这个文件主要用于 <code>es module</code> 的打包，而 <code>src/index.js</code> 用于 <code>commonjs</code> 的打包</p> <p>到这儿，我们也就清楚的知道了 <code>vuex</code> 的安装与初始化的 在 <code>src/store.js</code> 中,下面先具体分析一下 <strong>vuex的安装</strong>。</p> <h2 id="安装"><a href="#安装" class="header-anchor">#</a> 安装</h2> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/* src/store.js */</span>
<span class="token keyword">import</span> applyMixin <span class="token keyword">from</span> <span class="token string">'./mixin'</span>

<span class="token comment">/* 暴露install方法，供Vue.use调用安装插件 */</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">install</span> <span class="token punctuation">(</span><span class="token parameter">_Vue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/**
  * 判断是否已安装过 避免重复安装
  * 存在Vue实例_Vue 代表已安装 直接return 否则继续执行下面的代码
  */</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>Vue <span class="token operator">&amp;&amp;</span> _Vue <span class="token operator">===</span> Vue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>
        <span class="token string">'[vuex] already installed. Vue.use(Vuex) should be called only once.'</span>
      <span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>
  <span class="token comment">/**
  * 保存 Vue 实例，给当前作用域提供Vue
  * 这里把 install 方法的参数 _Vue 对象赋值给 Vue 变量
  * 这样我们就可以在 index.js 文件的其它地方使用 Vue 这个变量了
  * 好处是不在import Vue (在Vue-Router也是这样处理的 作用在源码分析中也说过)
  */</span>
  Vue <span class="token operator">=</span> _Vue
   <span class="token comment">/* 将 vuexInit 混入进Vue的beforeCreate */</span>
  <span class="token function">applyMixin</span><span class="token punctuation">(</span>Vue<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以看到 <code>install</code> 中调用了<code>applyMixin(Vue)</code> 参数是<code>Vue 实例</code></p> <h3 id="applymixin-的实现"><a href="#applymixin-的实现" class="header-anchor">#</a> applyMixin 的实现</h3> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/* src/mixin.js */</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">Vue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">/* 获取Vue版本，判断 Vue1.0 还是 Vue2.0 */</span>
  <span class="token keyword">const</span> version <span class="token operator">=</span> <span class="token function">Number</span><span class="token punctuation">(</span>Vue<span class="token punctuation">.</span>version<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token comment">/* 如果是 vue 2.0+*/</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>version <span class="token operator">&gt;=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* 通过mixin将 vuexInit 混入到 Vue实例 的 beforeCreate 钩子中 */</span>
    Vue<span class="token punctuation">.</span><span class="token function">mixin</span><span class="token punctuation">(</span><span class="token punctuation">{</span> beforeCreate<span class="token operator">:</span> vuexInit <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// override init and inject vuex init procedure</span>
    <span class="token comment">// 覆盖init并注入vuex init方法中 (vue1.0提供的init)</span>
    <span class="token comment">// for 1.x backwards compatibility.</span>
    <span class="token comment">/* 将vuexInit放入_init中调用 */</span>
    <span class="token keyword">const</span> _init <span class="token operator">=</span> <span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>_init
    <span class="token comment">// _init 方法</span>
    <span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">_init</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">options <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      options<span class="token punctuation">.</span>init <span class="token operator">=</span> options<span class="token punctuation">.</span>init
        <span class="token operator">?</span> <span class="token punctuation">[</span>vuexInit<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span>init<span class="token punctuation">)</span>
        <span class="token operator">:</span> vuexInit
      <span class="token function">_init</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> options<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">/**
   * Vuex init hook, injected into each instances init hooks list.
   * Vuex初始化钩子，注入到每个实例的初始化挂钩子列表中。
   */</span>
  <span class="token keyword">function</span> <span class="token function">vuexInit</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> options <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$options
    <span class="token comment">// store injection 向 Vue 实例注入 store  让所有组件都拥有 $store 属性，</span>
    <span class="token comment">// 指向根实例的 store 对象</span>
    <span class="token comment">// 根组件从这里拿到store</span>
    <span class="token comment">/* 判断是否存在store 当我们在执行 new Vue 的时候，需要提供store字段 存在代表是 root 节点*/</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>store<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">/**
      * 存在store 
      * 如果是个function 则执行 store() 方法
      * 如果不是function 则直接使用store
      */</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>$store <span class="token operator">=</span> <span class="token keyword">typeof</span> options<span class="token punctuation">.</span>store <span class="token operator">===</span> <span class="token string">'function'</span>
        <span class="token operator">?</span> options<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token operator">:</span> options<span class="token punctuation">.</span>store
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>parent <span class="token operator">&amp;&amp;</span> options<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>$store<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">/**
      * 否则拿 parent 上的 $store 从而实现所有组件共用一个 store实例
      * 子组件从父组件拿到，这样一层一层传递下去，实现所有组件都有$store属性，
      * 这样我们就可以在任何组件中通过this.$store访问到store
      */</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>$store <span class="token operator">=</span> options<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>$store
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这段代码的作用就是在 Vue 的<strong>生命周期</strong>中的<strong>初始化</strong>（1.0 版本是 init，2.0 版本是 <code>beforeCreated</code>）钩子前插入一段 Vuex 初始化代码。
这里做的事情很简单——给 Vue 的实例注入一个<code>$store</code> 的属性，这就是为什么我们在 Vue 的组件中可以通过 <code>this.$store</code> 访问到 Vuex 的各种数据和状态。</p> <h2 id="实例化-store"><a href="#实例化-store" class="header-anchor">#</a> 实例化 Store</h2> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// store.js</span>
<span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span>
<span class="token keyword">import</span> Vuex <span class="token keyword">from</span> <span class="token string">'vuex'</span>

Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Vuex<span class="token punctuation">)</span>

<span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  store  <span class="token comment">// store: store</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span>
</code></pre></div><p>我们在导入 Vuex 之后，通过 <code>Vue.use(Vuex)</code> 安装后，接着会<code>实例化 Store 对象</code>，返回 <code>store 实例</code>，
最后传入<code>new Vue</code> 的 <code>options</code> 中，也就是我们刚才提到的 <code>options.store</code>。下面具体分析一下 vuex 的核心 <strong>实例化 Store</strong>：</p> <h3 id="store-类"><a href="#store-类" class="header-anchor">#</a> Store 类</h3> <p>首先还是先看看代码骨架，从整体认识：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/* src/store.js */</span>

<span class="token comment">/* Store构造类 */</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">Store</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token parameter">options <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
  
  <span class="token comment">/* 将 store.state 即 rootState 代理到之前声明的 vm 实例中的 $state 中 */</span>
  <span class="token keyword">get</span> <span class="token function">state</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
  
  <span class="token keyword">set</span> <span class="token function">state</span> <span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
  <span class="token comment">/**
  * 提交 mutation。支持载荷方式和对象方式进行提交
  * 参数
  *   _type：一个字符串的 事件类型
  *   _payload：载荷 store.commit 时传入额外的参数 在大多数情况下，载荷应该是一个对象
  *   _options：options 里可以有 root: true，它允许在命名空间模块里提交根的 mutation
  */</span>
  <span class="token function">commit</span> <span class="token punctuation">(</span><span class="token parameter">_type<span class="token punctuation">,</span> _payload<span class="token punctuation">,</span> _options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
  <span class="token comment">/**
  * 分发 action。支持同样的载荷方式和对象方式进行分发
  * 参数
  *   _type：一个字符串的 事件类型
  *   _payload：载荷 store.dispatch 时传入额外的参数 在大多数情况下，载荷应该是一个对象
  *   返回一个解析所有被触发的 action 处理器的 Promise。
  */</span> 
  <span class="token function">dispatch</span> <span class="token punctuation">(</span><span class="token parameter">_type<span class="token punctuation">,</span> _payload</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
  <span class="token comment">/**
  * 注册一个 mutation 订阅函数，返回取消订阅的函数
  * 通常用于插件
  */</span>
  <span class="token function">subscribe</span> <span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
  <span class="token comment">/**
  * 注册一个 action 订阅函数 2.5.0 新增
  * 从 3.1.0 起，subscribeAction 也可以指定订阅处理函数的被调用时机
  * 应该在一个 action 分发之前还是之后 (默认行为是之前)
  * 常用于插件
  */</span>
  <span class="token function">subscribeAction</span> <span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
  <span class="token comment">/**
  * 观察一个getter方法
  * @param getter getter方法
  * @param cb 回调函数 当getter值改变时调用
  * @param options 可选的对象参数表示 Vue 的 vm.$watch 方法的参数
  * 要停止侦听，调用此方法返回的函数即可停止侦听。
  */</span>
  <span class="token function">watch</span> <span class="token punctuation">(</span><span class="token parameter">getter<span class="token punctuation">,</span> cb<span class="token punctuation">,</span> options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
  <span class="token comment">/* 重置state 替换 store 的根状态，仅用状态合并或时光旅行调试 */</span>
  <span class="token function">replaceState</span> <span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
  <span class="token comment">/**
  * 注册一个动态模块
  * 当业务进行异步加载的时候，可以通过该接口进行注册动态module
  * @param path
  * @param rawModule
  * @param options 可以包含 preserveState: true 以允许保留之前的 state。用于服务端渲染
  */</span>
  <span class="token function">registerModule</span> <span class="token punctuation">(</span><span class="token parameter">path<span class="token punctuation">,</span> rawModule<span class="token punctuation">,</span> options <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
  <span class="token comment">/* 卸载一个动态模块 */</span>
  <span class="token function">unregisterModule</span> <span class="token punctuation">(</span><span class="token parameter">path</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
  <span class="token comment">/* 热替换新的 action 和 mutation */</span>
  <span class="token function">hotUpdate</span> <span class="token punctuation">(</span><span class="token parameter">newOptions</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
  <span class="token comment">/* 保证通过mutation修改store的数据 */</span>
  <span class="token function">_withCommit</span> <span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="store-类构造方法"><a href="#store-类构造方法" class="header-anchor">#</a> Store 类构造方法</h3> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/* src/store.js */</span>

<span class="token comment">/**
* 构造函数
* 参数：一个对象参数
* { state,getters, mutations,actions,modules,...}
*/</span>
<span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token parameter">options <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Auto install if it is not done yet and `window` has `Vue`.</span>
    <span class="token comment">// To allow users to avoid auto-installation in some cases,</span>
    <span class="token comment">// this code should be placed here. See #731</span>
    <span class="token comment">/**
    * 如果尚未安装且`window`具有`Vue`，则自动安装。为了在某些情况下允许用户避免自动安装，
    * 挂载在window上的自动安装，也就是通过script标签引入时不需要手动调用Vue.use(Vuex)
    */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Vue <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> window <span class="token operator">!==</span> <span class="token string">'undefined'</span> <span class="token operator">&amp;&amp;</span> window<span class="token punctuation">.</span>Vue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">install</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>Vue<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 断言必须使用Vue.use(Vuex),在install方法中会给Vue赋值</span>
      <span class="token function">assert</span><span class="token punctuation">(</span>Vue<span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">must call Vue.use(Vuex) before creating a store instance.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
      <span class="token comment">// 断言必须存在Promise</span>
      <span class="token function">assert</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> Promise <span class="token operator">!==</span> <span class="token string">'undefined'</span><span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">vuex requires a Promise 
      polyfill in this browser.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
      <span class="token comment">// 断言必须使用new操作符</span>
      <span class="token function">assert</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">Store</span><span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">store must be called with the new operator.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/* ES6的解构赋值拿到的 options(用户配置的) 中的 plugins 和 strict  */</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span>
      <span class="token comment">/**
      * 一个数组，包含应用在 store 上的插件方法。这些插件直接接收 store 作为唯一参数，
      * 可以监听 mutation（用于外部地数据持久化、记录或调试）
      * 或者提交 mutation （用于内部数据，例如 websocket 或 某些观察者） 
      * 插件默认是空数组
      */</span>
      plugins <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
       <span class="token comment">/* 使 Vuex store 进入严格模式，在严格模式下，
       任何 mutation 处理函数以外修改 Vuex state 都会抛出错误。*/</span>
      strict <span class="token operator">=</span> <span class="token boolean">false</span>
    <span class="token punctuation">}</span> <span class="token operator">=</span> options

    <span class="token comment">// store internal state 以下 初始化store内部状态 </span>
    <span class="token comment">/* 用来判断严格模式下是否是用mutation修改state的 */</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_committing <span class="token operator">=</span> <span class="token boolean">false</span>
    <span class="token comment">/* 存放action Object.create(null) 创建空对象*/</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_actions <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
    <span class="token comment">/* 保存订阅action的回调 */</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_actionSubscribers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token comment">/* 存放mutation */</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_mutations <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
    <span class="token comment">/* 保存包装后的getter */</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_wrappedGetters <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
    <span class="token comment">/* module收集器 保存一棵module树 vuex支持模块，
    即将state通过key-value的形式拆分为多个模块*/</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_modules <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ModuleCollection</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span>
    <span class="token comment">/* 根据namespace存放module 保存namespaced的模块 */</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_modulesNamespaceMap <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
    <span class="token comment">/* 保存订阅mutation的回调 用于监听mutation 监听队列，当执行commit时会执行队列中的函数 */</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_subscribers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
     <span class="token comment">/* 使用 $watch 观测 getters 用于响应式地监测一个 getter 方法的返回值 监控state的改变*/</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_watcherVM <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">/* 用来存放生成的本地 getters 的缓存 */</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_makeLocalGettersCache <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>

    <span class="token comment">// bind commit and dispatch to self</span>
    <span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token comment">/**
    * 将dispatch与commit调用的this绑定为store对象本身，
    * 否则在组件内部this.dispatch时的this会指向组件的vm
    */</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> dispatch<span class="token punctuation">,</span> commit <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span>
     <span class="token comment">/* 定义dispatch方法 为dispatch与commit绑定this（Store实例本身）*/</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">dispatch</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">boundDispatch</span> <span class="token punctuation">(</span><span class="token parameter">type<span class="token punctuation">,</span> payload</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">dispatch</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>store<span class="token punctuation">,</span> type<span class="token punctuation">,</span> payload<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">commit</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">boundCommit</span> <span class="token punctuation">(</span><span class="token parameter">type<span class="token punctuation">,</span> payload<span class="token punctuation">,</span> options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">/* 定义commit方法 */</span>
      <span class="token keyword">return</span> <span class="token function">commit</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>store<span class="token punctuation">,</span> type<span class="token punctuation">,</span> payload<span class="token punctuation">,</span> options<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// strict mode</span>
    <span class="token comment">/**
    * 严格模式(使 Vuex store 进入严格模式
    * 严格模式下，任何 mutation 处理函数以外修改 Vuex state 都会抛出错误
    */</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>strict <span class="token operator">=</span> strict

    <span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_modules<span class="token punctuation">.</span>root<span class="token punctuation">.</span>state

    <span class="token comment">// init root module.</span>
    <span class="token comment">// this also recursively registers all sub-modules</span>
    <span class="token comment">// and collects all module getters inside this._wrappedGetters</span>
    <span class="token comment">/**
    * 初始化根module，这也同时递归注册了所有子module，
    * 收集所有module的getter到_wrappedGetters中去，
    * this._modules.root代表根module才独有保存的Module对象
    * 根据命名空间注册 state,actions,mutations,getters，并且提供访问当前模块的便捷方法（local）
    * installModule 方法是把我们通过 options 传入的各种属性模块注册和安装
    */</span>
    <span class="token function">installModule</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> state<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_modules<span class="token punctuation">.</span>root<span class="token punctuation">)</span>

    <span class="token comment">// initialize the store vm, which is responsible for the reactivity</span>
    <span class="token comment">// (also registers _wrappedGetters as computed properties)</span>
    <span class="token comment">/*
    * 新建一个vm实例保存state，在computed属性中保存getters，
    * 通过watch观察state，保证都使用commit修改state
    * 通过vm重设store，新建Vue对象使用Vue内部的响应式实现注册state以及computed
    * 初始化 store._vm，观测 state 和 getters 的变化
    * */</span>
    <span class="token function">resetStoreVM</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> state<span class="token punctuation">)</span>

    <span class="token comment">// apply plugins 调用插件</span>
    <span class="token comment">/* 执行插件，plugins前面已定义 是一个数组，遍历然后执行每个插件的函数 */</span>
    plugins<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">plugin</span> <span class="token operator">=&gt;</span> <span class="token function">plugin</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token comment">/* devtool插件 */</span>
    <span class="token comment">// 如果开启了开发工具，也会把实例对象传给开发工具。</span>
    <span class="token keyword">const</span> useDevtools <span class="token operator">=</span> options<span class="token punctuation">.</span>devtools <span class="token operator">!==</span> <span class="token keyword">undefined</span> <span class="token operator">?</span> options<span class="token punctuation">.</span>devtools <span class="token operator">:</span> 
    Vue<span class="token punctuation">.</span>config<span class="token punctuation">.</span>devtools
    <span class="token keyword">if</span> <span class="token punctuation">(</span>useDevtools<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">devtoolPlugin</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre></div><h4 id="断言判断"><a href="#断言判断" class="header-anchor">#</a> 断言判断</h4> <p>断言函数 <code>assert()</code>：断言就是当不满足某些条件时，会抛出错误，用于对一些条件进行校验。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/* /src/util.js */</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">assert</span> <span class="token punctuation">(</span><span class="token parameter">condition<span class="token punctuation">,</span> msg</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>condition<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">[vuex] </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>msg<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>Store</code> 构造函数中做了以下断言：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 断言必须使用Vue.use(Vuex),在install方法中会给Vue赋值</span>
      <span class="token function">assert</span><span class="token punctuation">(</span>Vue<span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">must call Vue.use(Vuex) before creating a store instance.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
      <span class="token comment">// 断言必须存在Promise</span>
      <span class="token function">assert</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> Promise <span class="token operator">!==</span> <span class="token string">'undefined'</span><span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">vuex requires a Promise 
      polyfill in this browser.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
      <span class="token comment">// 断言必须使用new操作符</span>
      <span class="token function">assert</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">Store</span><span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">store must be called with the new operator.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
</code></pre></div><ul><li><p><strong>第一个</strong>  是确保创建实例前已经在 <code>Vue</code> 中注册了 <code>Vuex</code>，也就是 <code>Vue.use(Vuex)</code>,前面也说过，当我们在调用 <code>Vue.use()</code> 函数时，
会调用 Vuex 的 <code>install()</code> 函数，来给 Vue 的实例<strong>注入初始化函数</strong>，初始化函数会在 <strong>vue 实例化过程中执行</strong>，
然后给 <code>Vue实例</code> 注入一个 <code>$store</code> 的属性，保证我们可以通过通过 <code>this.$store</code> 访问到 Vuex 的各种数据和状态。
所以如果在 <code>new Vue()</code> 之后再去 <code>Vue.use(Vuex)</code> 的话，<strong>初始化函数</strong>并没有挂在到 Vue 上， <code>$store</code> 属性就无法添加到 Vue 的实例化对象上。</p></li> <li><p><strong>第二个</strong>  是为了确保 <code>Promsie</code> 可以使用的，因为 Vuex 的源码是依赖 <code>Promise</code> 的。<code>Promise</code> 是 <code>ES6</code> 提供新的 API，
由于现在的浏览器并不是都支持 ES6 语法的，所以通常我们会用 <code>Babel</code> 编译我们的代码，如果想使用 <code>Promise</code> 这个 特性，
我们需要在 <code>package.json</code> 中添加对 <code>babel-polyfill</code> 的依赖并在代码的入口加上 <code>import 'babel-polyfill'</code> 这段代码。</p></li> <li><p><strong>第三个</strong>  是验证<strong>调用方</strong>是否是通过 <code>new</code> 出来的，也就是说<strong>是否是 Store 的原型</strong>，防止通过直接调用 <code>Stroe()</code> 这样，把 <code>Store</code> 当成普通函数来调用。</p></li></ul> <p>构造函数中除了创建了一些内部属性初始化 <code>store</code> 内部状态外，最重要的做了三件事：</p> <ul><li><strong><code>ModuleCollection</code></strong>：  模块收集器，保存一棵 <code>module</code> 树，初始化模块</li> <li><strong><code>installModule</code></strong>： 安装模块，初始化<code>根 module</code>，这也同时递归注册了所有<code>子 module</code>。</li> <li><strong><code>resetStoreVM</code></strong>：新建一个 <code>vm实例</code> 保存 <code>state</code>，用于初始化 <code>store._vm</code></li></ul> <p>下面就先从这三件事开始深入分析</p> <h3 id="模块收集器"><a href="#模块收集器" class="header-anchor">#</a> 模块收集器</h3> <p>在上一章节中我们提到过 <code>vuex的模块</code>，模块 <code>modules</code>：类似于命名空间，用于项目中将各个模块的状态分开定义和操作，便于维护。
由于 <code>vuex</code> 使用单一状态树，应用的所有状态会集中到一个比较大的对象 <code>Store</code> 中，当应用变得非常复杂时，<code>store</code> 对象就有可能变得相当臃肿。
为了解决以上问题，vuex支持模块，即将 <code>store</code> 通过 <code>key-value</code> 的形式拆分为多个模块（module）。
每个模块拥有自己的 <code>state、getter、mutation、action</code> 甚至<code>module 子模块</code>，这样的话模块的设计就是一个树型结构，
<code>store</code> 本身可以理解为一个 <code>root module 根模块</code>，它下面的 <code>modules</code> 就是子模块，Vuex 需要完成这颗树的构建，构建过程的入口就是：
<strong><code>this._modules = new ModuleCollection(options)</code></strong>。</p> <p>下面具体分析 <code>ModuleCollection</code> 的实现：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/* src/module/module-collection.js */</span>

<span class="token comment">/* module收集类 */</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">ModuleCollection</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token parameter">rawRootModule</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// register root module (Vuex.Store options)</span>
    <span class="token comment">/**
    *  将 new Vuex.Store 传入的用户配置项作为参数 通过 rawRootModule 传入
    *  即 { strict,state,getters mutations,actions,modules,plugins}
    */</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> rawRootModule<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token comment">/**
  * 根据 path 获取 module， register中会调用
  * 根据传入的 path （数组），递归的遍历，不断的从模块的子模块中找
  * 直到 path 遍历完毕，找到这个 path 数组最后一个元素对应的模块
  */</span>
  <span class="token function">get</span> <span class="token punctuation">(</span>path<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> path<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">module<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> module<span class="token punctuation">.</span><span class="token function">getChild</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  
  <span class="token comment">/**
  * 获取namespace 命名空间，当namespaced为true的时候会 
  * 将当前模块的属性名拼接到整个 namespace 组成的字符串中
  * 返回'moduleName/name'
  * 并且这个模块下面所有的 actions/mutations/getters 都会加上 namespace 前缀
  * 这样使得多个模块能够对同一 mutation 或 action 作出响应。
  * 如果希望你的模块更加自包含或提高可重用性，
  * 你可以通过添加 namespaced: true 的方式使其成为命名空间模块。
  * 当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。
  */</span>
  <span class="token function">getNamespace</span> <span class="token punctuation">(</span><span class="token parameter">path</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> module <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root
    <span class="token keyword">return</span> path<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">namespace<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      module <span class="token operator">=</span> module<span class="token punctuation">.</span><span class="token function">getChild</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
      <span class="token keyword">return</span> namespace <span class="token operator">+</span> <span class="token punctuation">(</span>module<span class="token punctuation">.</span>namespaced <span class="token operator">?</span> key <span class="token operator">+</span> <span class="token string">'/'</span> <span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token function">update</span> <span class="token punctuation">(</span><span class="token parameter">rawRootModule</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">,</span> rawRootModule<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">/**
  * 根据配置项生成 ModuleCollection 实例，即所有模块集合
  * 一般一个 Vuex 实例只有一个模块集合，一个模块集合又有多个模块实例组成
  * runtime 为 true 时，代表动态注入的模块，初始化时传入 false
  */</span>
  <span class="token function">register</span> <span class="token punctuation">(</span><span class="token parameter">path<span class="token punctuation">,</span> rawModule<span class="token punctuation">,</span> runtime <span class="token operator">=</span> <span class="token boolean">true</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">assertRawModule</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> rawModule<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/* 实例化一个module 传入当前 Module 的配置项 */</span>
    <span class="token keyword">const</span> newModule <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Module</span><span class="token punctuation">(</span>rawModule<span class="token punctuation">,</span> runtime<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>path<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">/* path为空数组的代表跟节点 将根module 绑定到root属性上 
      定义唯一的一个实例属性 root，指向根 module 实例*/</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>root <span class="token operator">=</span> newModule
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">/**
      *  获取父级module 找到当前模块的父模块
      *  path.slice(0, -1) 为除去最后一个元素的 path 数组，即当前模块父模块的 path 数组
      */</span>
      <span class="token keyword">const</span> parent <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token comment">/**
      * 在父module中插入一个子module
      * 给当前模块的父模块的 _children 属性添加当前模块
      * 即注册子模块 
      */</span>
      parent<span class="token punctuation">.</span><span class="token function">addChild</span><span class="token punctuation">(</span>path<span class="token punctuation">[</span>path<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> newModule<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// register nested modules </span>
    <span class="token comment">// 递归注册当前 module 的子 modules 遍历子模块，逐个注册，最终形成一个树</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>rawModule<span class="token punctuation">.</span>modules<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">forEachValue</span><span class="token punctuation">(</span>rawModule<span class="token punctuation">.</span>modules<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">rawChildModule<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">/**
        * 将 path 数组合并上当前模块子模块的属性名，
        * 传入递归 register 函数中，作为模块的前缀（命名空间）
        */</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> rawChildModule<span class="token punctuation">,</span> runtime<span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">/* 注销 */</span>
  <span class="token function">unregister</span> <span class="token punctuation">(</span><span class="token parameter">path</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> parent <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">const</span> key <span class="token operator">=</span> path<span class="token punctuation">[</span>path<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>parent<span class="token punctuation">.</span><span class="token function">getChild</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">.</span>runtime<span class="token punctuation">)</span> <span class="token keyword">return</span>

    parent<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>ModuleCollection</code> 实例化的过程就是执行了 <code>register</code> 方法， <code>register</code> 接收 3 个参数：</p> <ul><li><strong><code>path</code></strong>  表示路径，因为我们整体目标是要构建一颗模块树，path 是在构建树的过程中维护的路径</li> <li><strong><code>rawModule</code></strong>  表示定义模块的原始配置</li> <li><strong><code>runtime</code></strong>  表示是否是一个运行时创建的模块</li></ul> <p><code>register</code> 方法中传入当前 Module 的配置项并实例化一个 Module，下面具体分析 实例化 Module 的过程</p> <h3 id="module-类"><a href="#module-类" class="header-anchor">#</a> Module 类</h3> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/* src/module/module.js */</span>


<span class="token comment">// Base data struct for store's module, package with some attribute and method</span>
<span class="token comment">/**
*  Module 实例
*  _children（当前模块子模块实例组成的数组）
*  _rawModule当前模块的最初的定义（用户定义）
*/</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">Module</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token parameter">rawModule<span class="token punctuation">,</span> runtime</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>runtime <span class="token operator">=</span> runtime
    <span class="token comment">// Store some children item </span>
    <span class="token comment">/* 存放 当前模块的子模块实例 用于保存子模块*/</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_children <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
    <span class="token comment">// Store the origin module object which passed by programmer</span>
    <span class="token comment">/* 保存module 保存用户传递的原始模块对象*/</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_rawModule <span class="token operator">=</span> rawModule
    <span class="token comment">/* 保存modele的state */</span>
    <span class="token keyword">const</span> rawState <span class="token operator">=</span> rawModule<span class="token punctuation">.</span>state

    <span class="token comment">// Store the origin module's state 前模块的最初定义的state</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> rawState <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">?</span> <span class="token function">rawState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> rawState<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">/* 获取namespace */</span>
  <span class="token keyword">get</span> <span class="token function">namespaced</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">!</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>_rawModule<span class="token punctuation">.</span>namespaced
  <span class="token punctuation">}</span>
  <span class="token comment">/* 插入一个子module，存入_children中 */</span>
  <span class="token function">addChild</span> <span class="token punctuation">(</span><span class="token parameter">key<span class="token punctuation">,</span> module</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 将子模块添加到_children中</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_children<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> module
  <span class="token punctuation">}</span>
 <span class="token comment">/* 移除一个子module */</span>
  <span class="token function">removeChild</span> <span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">delete</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_children<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
  <span class="token comment">/* 根据key获取子module */</span>
  <span class="token function">getChild</span> <span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_children<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
  <span class="token comment">/* 更新module */</span>
  <span class="token function">update</span> <span class="token punctuation">(</span><span class="token parameter">rawModule</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_rawModule<span class="token punctuation">.</span>namespaced <span class="token operator">=</span> rawModule<span class="token punctuation">.</span>namespaced
    <span class="token keyword">if</span> <span class="token punctuation">(</span>rawModule<span class="token punctuation">.</span>actions<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>_rawModule<span class="token punctuation">.</span>actions <span class="token operator">=</span> rawModule<span class="token punctuation">.</span>actions
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>rawModule<span class="token punctuation">.</span>mutations<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>_rawModule<span class="token punctuation">.</span>mutations <span class="token operator">=</span> rawModule<span class="token punctuation">.</span>mutations
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>rawModule<span class="token punctuation">.</span>getters<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>_rawModule<span class="token punctuation">.</span>getters <span class="token operator">=</span> rawModule<span class="token punctuation">.</span>getters
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
   <span class="token comment">/* 遍历child */</span>
  <span class="token function">forEachChild</span> <span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">forEachValue</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_children<span class="token punctuation">,</span> fn<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">/* 遍历getter */</span>
  <span class="token function">forEachGetter</span> <span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_rawModule<span class="token punctuation">.</span>getters<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">forEachValue</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_rawModule<span class="token punctuation">.</span>getters<span class="token punctuation">,</span> fn<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">/* 遍历action */</span>
  <span class="token function">forEachAction</span> <span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_rawModule<span class="token punctuation">.</span>actions<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">forEachValue</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_rawModule<span class="token punctuation">.</span>actions<span class="token punctuation">,</span> fn<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">/* 遍历matation */</span>
  <span class="token function">forEachMutation</span> <span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_rawModule<span class="token punctuation">.</span>mutations<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">forEachValue</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_rawModule<span class="token punctuation">.</span>mutations<span class="token punctuation">,</span> fn<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>来看一下 Module 的构造函数，对于每个模块而言：</p> <ul><li><strong><code>this.runtime</code></strong>  表示是否是一个运行时创建的模块</li> <li><strong><code>this._rawModule</code></strong>  表示模块的配置</li> <li><strong><code>this._children</code></strong>  表示它的所有子模块</li> <li><strong><code>this.state</code></strong>  表示这个模块定义的 state</li></ul> <p>回到 register 方法，在实例化一个 Module 后，接着判断当前的 path 的长度，如果为 0 则说明它是一个根模块，
就把 <code>newModule</code> 赋值给了 <code>this.root</code> （定义唯一的一个实例属性 root，指向根 module 实例），否则就需要建立父子关系了：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/* src/module/module-collection.js */</span>

  <span class="token comment">/**
  *  根据path获取父级module 找到当前模块的父模块
  *  path.slice(0, -1) 为除去最后一个元素的 path 数组，即当前模块父模块的 path 数组
  */</span>
   <span class="token keyword">const</span> parent <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
   <span class="token comment">/**
   * 在父module中插入一个子module
   * 给当前模块的父模块的 _children 属性添加当前模块
   * 即注册子模块 
   */</span>
   parent<span class="token punctuation">.</span><span class="token function">addChild</span><span class="token punctuation">(</span>path<span class="token punctuation">[</span>path<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> newModule<span class="token punctuation">)</span>
</code></pre></div><p>首先根据路径获取到父模块，然后再调用父模块的 <code>addChild</code> 方法建立父子关系。</p> <p>最后，是递归调用 register 方法 遍历当前模块定义中的所有 modules，<strong>根据 key 作为 path，递归调用 register 方法</strong>。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/* src/module/module-collection.js */</span>

  <span class="token comment">// register nested modules </span>
  <span class="token comment">// 递归注册当前 module 的子 modules 遍历子模块，逐个注册，最终形成一个树</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>rawModule<span class="token punctuation">.</span>modules<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">forEachValue</span><span class="token punctuation">(</span>rawModule<span class="token punctuation">.</span>modules<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">rawChildModule<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token comment">/**
      * 将 path 数组合并上当前模块子模块的属性名，
      * 传入递归 register 函数中，作为模块的前缀（命名空间）
      */</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> rawChildModule<span class="token punctuation">,</span> runtime<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>这样我们再回过头看一下建立父子关系的逻辑，首先执行了 <code>this.get(path.slice(0, -1)</code> 方法：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/* src/module/module-collection.js */</span>

 <span class="token comment">/**
  * 根据 path 获取 module 
  * 根据传入的 path （数组），递归的遍历，不断的从模块的子模块中找
  * 直到 path 遍历完毕，找到这个 path 数组最后一个元素对应的模块
  */</span>
  <span class="token function">get</span> <span class="token punctuation">(</span>path<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> path<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">module<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> module<span class="token punctuation">.</span><span class="token function">getChild</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>传入的 <code>path</code> 是它的<strong>父模块</strong>的 <code>path</code>，然后从<strong>根模块</strong>开始，通过 <code>reduce</code> 方法一层层去找到对应的模块，
查找的过程中，执行的是<code>module.getChild(key)</code> 方法：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/* src/module/module.js */</span>

<span class="token comment">/* 根据key获取子module */</span>
<span class="token function">getChild</span> <span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_children<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>其实就是返回当前模块的 _<code>children</code> 中对应 <code>key</code> 的模块，那么每个模块的 _<em>children 是如何添加的呢</em>，
是通过执行 <code>parent.addChild(path[path.length - 1], newModule)</code> 方法：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/* src/module/module.js */</span>

<span class="token comment">/* 插入一个子module，存入_children中 */</span>
  <span class="token function">addChild</span> <span class="token punctuation">(</span><span class="token parameter">key<span class="token punctuation">,</span> module</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_children<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> module
  <span class="token punctuation">}</span>
</code></pre></div><p>所以说对于 root module 的下一层 modules 来说，它们的 parent 就是 root module，
那么他们就会被添加的 root module 的 _children 中。
每个子模块通过路径找到它的父模块，然后通过父模块的 <code>addChild</code> 方法建立父子关系，
递归执行这样的过程，最终就建立一颗完整的模块树。</p> <p>到此，我们分析了 <code>Module 类</code> 和 <code>ModuleCollection 类</code>的 register 方法，这也意味着 ModuleCollection 类及其构造方法分析完了。
整个过程就是 <code>this._modules = new ModuleCollection(options)</code> vuex 模块树的构建过程，即初始化模块。</p> <h2 id="模块安装"><a href="#模块安装" class="header-anchor">#</a> 模块安装</h2> <p>初始化模块后，执行安装模块的相关逻辑，初始化根module，这也同时递归注册了所有子module。
它的作用就是对模块中的 state、getters、mutations、actions以及 子module 做初始化工作。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/* src/store.js */</span>

  <span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_modules<span class="token punctuation">.</span>root<span class="token punctuation">.</span>state

  <span class="token comment">// init root module.</span>
  <span class="token comment">// this also recursively registers all sub-modules</span>
  <span class="token comment">// and collects all module getters inside this._wrappedGetters</span>
  <span class="token comment">/**
  * 初始化根module，这也同时递归注册了所有子module，
  * 收集所有module的getter到_wrappedGetters中去，
  * this._modules.root代表根module才独有保存的Module对象
  * 根据命名空间注册 state,actions,mutations,getters，并且提供访问当前模块的便捷方法（local）
  */</span>
  <span class="token function">installModule</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> state<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_modules<span class="token punctuation">.</span>root<span class="token punctuation">)</span>
</code></pre></div><p>执行 <code>installModule</code> 方法，<code>installModule</code> 方法是把我们通过 <code>options</code> 传入的各种属性模块注册和安装</p> <h3 id="installmodule-的实现"><a href="#installmodule-的实现" class="header-anchor">#</a> installModule 的实现</h3> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/* src/store.js */</span>

<span class="token comment">/**
* 这里是module处理的核心，包括处理根module、命名空间、action、mutation、getters和递归注册子module
* @param store 传入的 this 即root store
* @param rootState 传入的 state 即root state
* @param path 传入的 [] 模块的访问路径 即path数组 初始为空 之后若有命名空间会转为命名空间组成的数组
* @param module 传入的 this._modules.root 当前的模块
* @param hot 是否热更新
*/</span>
<span class="token keyword">function</span> <span class="token function">installModule</span> <span class="token punctuation">(</span><span class="token parameter">store<span class="token punctuation">,</span> rootState<span class="token punctuation">,</span> path<span class="token punctuation">,</span> module<span class="token punctuation">,</span> hot</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 是否是根module path为空数组的代表跟节点 */</span>
  <span class="token keyword">const</span> isRoot <span class="token operator">=</span> <span class="token operator">!</span>path<span class="token punctuation">.</span>length
 
  <span class="token comment">/* 获取module的namespace */</span>
  <span class="token comment">/* 根据 path 数组获取命名前缀，根模块为空字符串
   * {
   *   // ...
   *   modules: {
   *     moduleA: {
   *       namespaced: true
   *     },
   *     moduleB: {}
   *   }
   * }
   * moduleA的namespace -&gt; 'moduleA/'
   * moduleB的namespace -&gt; ''
   * 设置了 namespaced 的模块会根据嵌套的层级拼接（a/b/c/）
   */</span>
  <span class="token keyword">const</span> namespace <span class="token operator">=</span> store<span class="token punctuation">.</span>_modules<span class="token punctuation">.</span><span class="token function">getNamespace</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span>

  <span class="token comment">// register in namespace map</span>
  <span class="token comment">/**
  * 如果有namespace则在_modulesNamespaceMap中注册
  * 生成 _modulesNamespaceMap 对象，存放 namespaced 为 true 的模块
  * 属性名是所有的父级 module 名 +  '/'，值为当前注册的 module 实例
  * 通过加上父级模块的路径，保证了每个模块都有自己的命名空间，
  * 防止名字相同的 getter/actions/mutations 命名冲突
  */</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>module<span class="token punctuation">.</span>namespaced<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>store<span class="token punctuation">.</span>_modulesNamespaceMap<span class="token punctuation">[</span>namespace<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">[vuex] duplicate namespace </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>namespace<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> 
      for the namespaced module </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 保存namespaced模块</span>
    store<span class="token punctuation">.</span>_modulesNamespaceMap<span class="token punctuation">[</span>namespace<span class="token punctuation">]</span> <span class="token operator">=</span> module
  <span class="token punctuation">}</span>

  <span class="token comment">// set state</span>
  <span class="token comment">/* 添加当前模块，作为父模块的 state 对象中的属性，在 state 中建立父子关系 */</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isRoot <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>hot<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">/* 获取父级的state */</span>
    <span class="token keyword">const</span> parentState <span class="token operator">=</span> <span class="token function">getNestedState</span><span class="token punctuation">(</span>rootState<span class="token punctuation">,</span> path<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
     <span class="token comment">/* 模块名称 */</span>
    <span class="token keyword">const</span> moduleName <span class="token operator">=</span> path<span class="token punctuation">[</span>path<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>
    store<span class="token punctuation">.</span><span class="token function">_withCommit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>moduleName <span class="token keyword">in</span> parentState<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          console<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span>
            <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">[vuex] state field &quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>moduleName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot; was overridden 
            by a module with the same name at &quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot;</span><span class="token template-punctuation string">`</span></span>
          <span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      <span class="token comment">/**
      * 在父模块的 state 属性中添加当前模块，属性名是当前模块名，值是 state 对象
      * Vuex 之所以这么做可能是因为需要让所有的模块状态都保存在 state 中
      * 使得在重置模块时能够通过保留 state 从而保留所有的模块依赖关系
      * 将子module设置称响应式的
      */</span>
      Vue<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>parentState<span class="token punctuation">,</span> moduleName<span class="token punctuation">,</span> module<span class="token punctuation">.</span>state<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">/**
  * 给当前模块添加 context 属性，即 action 的第一个参数 ctx
  * ctx 中的 dispatch 会添加当前模块的命名空间
  * 再执行全局的 dispatch 去 _actions 中找到对应的 action
  * local 返回的是一个含有 dispatch,commit,getters,state 的对象，即 ctx
  */</span>
  <span class="token keyword">const</span> local <span class="token operator">=</span> module<span class="token punctuation">.</span>context <span class="token operator">=</span> <span class="token function">makeLocalContext</span><span class="token punctuation">(</span>store<span class="token punctuation">,</span> namespace<span class="token punctuation">,</span> path<span class="token punctuation">)</span>
  <span class="token comment">/* 遍历注册mutation */</span>
  module<span class="token punctuation">.</span><span class="token function">forEachMutation</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">mutation<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">/* mutation 是 mutations 中定义的函数，key 为这个 mutation 函数的 key */</span>
    <span class="token keyword">const</span> namespacedType <span class="token operator">=</span> namespace <span class="token operator">+</span> key
    <span class="token comment">/* 给 store 的 _mutations 对象添加当前模块包含的所有 mutations */</span>
    <span class="token function">registerMutation</span><span class="token punctuation">(</span>store<span class="token punctuation">,</span> namespacedType<span class="token punctuation">,</span> mutation<span class="token punctuation">,</span> local<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token comment">/* 遍历注册action */</span>
  module<span class="token punctuation">.</span><span class="token function">forEachAction</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">action<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> type <span class="token operator">=</span> action<span class="token punctuation">.</span>root <span class="token operator">?</span> key <span class="token operator">:</span> namespace <span class="token operator">+</span> key
    <span class="token keyword">const</span> handler <span class="token operator">=</span> action<span class="token punctuation">.</span>handler <span class="token operator">||</span> action
    <span class="token function">registerAction</span><span class="token punctuation">(</span>store<span class="token punctuation">,</span> type<span class="token punctuation">,</span> handler<span class="token punctuation">,</span> local<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token comment">/* 遍历注册getter */</span>
  module<span class="token punctuation">.</span><span class="token function">forEachGetter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">getter<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> namespacedType <span class="token operator">=</span> namespace <span class="token operator">+</span> key
    <span class="token function">registerGetter</span><span class="token punctuation">(</span>store<span class="token punctuation">,</span> namespacedType<span class="token punctuation">,</span> getter<span class="token punctuation">,</span> local<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token comment">/**
  * 递归注册子模块，建立 module 树，并且给 path 数组推入当前命名空间（字符串）
  * 此时所有的子模块中的 state，actions，mutations，getters 都被注册完毕
  */</span>
  module<span class="token punctuation">.</span><span class="token function">forEachChild</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">child<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">installModule</span><span class="token punctuation">(</span>store<span class="token punctuation">,</span> rootState<span class="token punctuation">,</span> path<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> child<span class="token punctuation">,</span> hot<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>installModule</code> 方法支持 5 个参数，store、rootState、path、module、hot。</p> <ul><li><code>store</code> 表示当前 Store 实例</li> <li><code>rootState</code> 表示根 state</li> <li><code>path</code> 表示当前嵌套模块的路径数组</li> <li><code>module</code> 表示当前安装的模块</li> <li><code>hot</code> 当动态改变 modules 或者热更新的时候为 true</li></ul> <h3 id="命名空间"><a href="#命名空间" class="header-anchor">#</a> 命名空间</h3> <p>接下来看函数逻辑，这里涉及到了<strong>命名空间</strong>的概念，默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的
——这样使得多个模块能够对同一 mutation 或 action 作出响应。如果希望你的模块具有更高的封装度和复用性，
你可以通过添加 <code>namespaced: true</code> 的方式使其成为<strong>带命名空间的模块</strong>。
当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。例如：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  modules<span class="token operator">:</span> <span class="token punctuation">{</span>
    account<span class="token operator">:</span> <span class="token punctuation">{</span>
      namespaced<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>

      <span class="token comment">// 模块内容（module assets）</span>
      state<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响</span>
      getters<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token function">isAdmin</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span> <span class="token comment">// -&gt; getters['account/isAdmin']</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      actions<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token function">login</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span> <span class="token comment">// -&gt; dispatch('account/login')</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      mutations<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token function">login</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span> <span class="token comment">// -&gt; commit('account/login')</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>

      <span class="token comment">// 嵌套模块</span>
      modules<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token comment">// 继承父模块的命名空间</span>
        myPage<span class="token operator">:</span> <span class="token punctuation">{</span>
          state<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
          getters<span class="token operator">:</span> <span class="token punctuation">{</span>
            <span class="token function">profile</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span> <span class="token comment">// -&gt; getters['account/profile']</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>

        <span class="token comment">// 进一步嵌套命名空间</span>
        posts<span class="token operator">:</span> <span class="token punctuation">{</span>
          namespaced<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>

          state<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
          getters<span class="token operator">:</span> <span class="token punctuation">{</span>
            <span class="token function">popular</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span> <span class="token comment">// -&gt; getters['account/posts/popular']</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>启用了命名空间的 getter 和 action 是<strong>局部化</strong>的 getter，dispatch 和 commit。换言之，
你在使用模块内容（module assets）时不需要在同一模块内额外添加空间名前缀。更改 namespaced 属性后不需要修改模块内的代码。</p> <h4 id="在带命名空间的模块内访问全局内容-global-assets"><a href="#在带命名空间的模块内访问全局内容-global-assets" class="header-anchor">#</a> 在带命名空间的模块内<code>访问全局内容</code>（Global Assets）</h4> <p>如果你希望<strong>使用全局 state 和 getter</strong>，<code>rootState</code> 和 <code>rootGetters</code> 会作为第三和第四参数传入 <code>getter</code>，也会通过 <code>context</code> 对象的属性传入 <code>action</code>。</p> <p>若需要在全局命名空间内<strong>分发 action</strong> 或<strong>提交 mutation</strong>，将 <code>{ root: true }</code> 作为第三参数传给 <code>dispatch</code> 或 <code>commit</code> 即可。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>modules<span class="token operator">:</span> <span class="token punctuation">{</span>
  foo<span class="token operator">:</span> <span class="token punctuation">{</span>
    namespaced<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>

    getters<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token comment">// 在这个模块的 getter 中，`getters` 被局部化了</span>
      <span class="token comment">// 你可以使用 getter 的第四个参数来调用 `rootGetters`</span>
      <span class="token function">someGetter</span> <span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> getters<span class="token punctuation">,</span> rootState<span class="token punctuation">,</span> rootGetters</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        getters<span class="token punctuation">.</span>someOtherGetter <span class="token comment">// -&gt; 'foo/someOtherGetter'</span>
        rootGetters<span class="token punctuation">.</span>someOtherGetter <span class="token comment">// -&gt; 'someOtherGetter'</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token function-variable function">someOtherGetter</span><span class="token operator">:</span> <span class="token parameter">state</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>

    actions<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token comment">// 在这个模块中， dispatch 和 commit 也被局部化了</span>
      <span class="token comment">// 他们可以接受 `root` 属性以访问根 dispatch 或 commit</span>
      <span class="token function">someAction</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> dispatch<span class="token punctuation">,</span> commit<span class="token punctuation">,</span> getters<span class="token punctuation">,</span> rootGetters <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        getters<span class="token punctuation">.</span>someGetter <span class="token comment">// -&gt; 'foo/someGetter'</span>
        rootGetters<span class="token punctuation">.</span>someGetter <span class="token comment">// -&gt; 'someGetter'</span>

        <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">'someOtherAction'</span><span class="token punctuation">)</span> <span class="token comment">// -&gt; 'foo/someOtherAction'</span>
        <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">'someOtherAction'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> root<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// -&gt; 'someOtherAction'</span>

        <span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'someMutation'</span><span class="token punctuation">)</span> <span class="token comment">// -&gt; 'foo/someMutation'</span>
        <span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'someMutation'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> root<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// -&gt; 'someMutation'</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token function">someOtherAction</span> <span class="token punctuation">(</span><span class="token parameter">ctx<span class="token punctuation">,</span> payload</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="在带命名空间的模块注册全局-action"><a href="#在带命名空间的模块注册全局-action" class="header-anchor">#</a> 在带命名空间的模块<code>注册全局 action</code></h4> <p>若需要在<strong>带命名空间的</strong>模块<strong>注册全局 action</strong>，你可添加 <code>root: true</code>，并将这个 <code>action</code> 的定义放在函数 <code>handler</code> 中。例如：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token punctuation">{</span>
  actions<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">someOtherAction</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>dispatch<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">'someAction'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  modules<span class="token operator">:</span> <span class="token punctuation">{</span>
    foo<span class="token operator">:</span> <span class="token punctuation">{</span>
      namespaced<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>

      actions<span class="token operator">:</span> <span class="token punctuation">{</span>
        someAction<span class="token operator">:</span> <span class="token punctuation">{</span>
          root<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
          <span class="token function">handler</span> <span class="token punctuation">(</span><span class="token parameter">namespacedContext<span class="token punctuation">,</span> payload</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span> <span class="token comment">// -&gt; 'someAction' 注册为全局的 action</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="带命名空间的绑定函数"><a href="#带命名空间的绑定函数" class="header-anchor">#</a> 带命名空间的<code>绑定函数</code></h4> <p>当使用 <code>mapState</code>, <code>mapGetters</code>, <code>mapActions</code> 和 <code>mapMutations</code> 这些函数来<strong>绑定带命名空间的模块</strong>时，写起来可能比较繁琐：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>computed<span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token operator">...</span><span class="token function">mapState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token function-variable function">a</span><span class="token operator">:</span> <span class="token parameter">state</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>some<span class="token punctuation">.</span>nested<span class="token punctuation">.</span>module<span class="token punctuation">.</span>a<span class="token punctuation">,</span>
    <span class="token function-variable function">b</span><span class="token operator">:</span> <span class="token parameter">state</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>some<span class="token punctuation">.</span>nested<span class="token punctuation">.</span>module<span class="token punctuation">.</span>b
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
methods<span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token operator">...</span><span class="token function">mapActions</span><span class="token punctuation">(</span><span class="token punctuation">[</span>
    <span class="token string">'some/nested/module/foo'</span><span class="token punctuation">,</span> <span class="token comment">// -&gt; this['some/nested/module/foo']()</span>
    <span class="token string">'some/nested/module/bar'</span> <span class="token comment">// -&gt; this['some/nested/module/bar']()</span>
  <span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>对于这种情况，你可以将模块的<strong>空间名称</strong>字符串<strong>作为第一个参数</strong>传递给上述函数，这样所有绑定都会<strong>自动将该模块作为<code>上下文</code></strong>。于是上面的例子可以简化为：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>computed<span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token operator">...</span><span class="token function">mapState</span><span class="token punctuation">(</span><span class="token string">'some/nested/module'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">a</span><span class="token operator">:</span> <span class="token parameter">state</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>a<span class="token punctuation">,</span>
    <span class="token function-variable function">b</span><span class="token operator">:</span> <span class="token parameter">state</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>b
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
methods<span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token operator">...</span><span class="token function">mapActions</span><span class="token punctuation">(</span><span class="token string">'some/nested/module'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
    <span class="token string">'foo'</span><span class="token punctuation">,</span> <span class="token comment">// -&gt; this.foo()</span>
    <span class="token string">'bar'</span> <span class="token comment">// -&gt; this.bar()</span>
  <span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>而且，你可以通过使用 <code>createNamespacedHelpers</code> 创建<strong>基于某个命名空间辅助函数</strong>。它返回一个对象，对象里有新的绑定在<strong>给定命名空间值</strong>上的组件<strong>绑定辅助函数</strong>：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> createNamespacedHelpers <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vuex'</span>

<span class="token keyword">const</span> <span class="token punctuation">{</span> mapState<span class="token punctuation">,</span> mapActions <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">createNamespacedHelpers</span><span class="token punctuation">(</span><span class="token string">'some/nested/module'</span><span class="token punctuation">)</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  computed<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// 在 `some/nested/module` 中查找</span>
    <span class="token operator">...</span><span class="token function">mapState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token function-variable function">a</span><span class="token operator">:</span> <span class="token parameter">state</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>a<span class="token punctuation">,</span>
      <span class="token function-variable function">b</span><span class="token operator">:</span> <span class="token parameter">state</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>b
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  methods<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// 在 `some/nested/module` 中查找</span>
    <span class="token operator">...</span><span class="token function">mapActions</span><span class="token punctuation">(</span><span class="token punctuation">[</span>
      <span class="token string">'foo'</span><span class="token punctuation">,</span>
      <span class="token string">'bar'</span>
    <span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>回到 <code>installModule</code> 方法，我们首先根据 <code>path</code> 获取 <code>namespace</code>：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/* 获取module的namespace */</span>
<span class="token keyword">const</span> namespace <span class="token operator">=</span> store<span class="token punctuation">.</span>_modules<span class="token punctuation">.</span><span class="token function">getNamespace</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span>
</code></pre></div><p>调用了 <code>getNamespace</code> 方法</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/* src/module/module-collection.js */</span>

<span class="token comment">/**
  * 获取namespace 命名空间，当namespaced为true的时候会 
  * 将当前模块的属性名拼接到整个 namespace 组成的字符串中
  * 返回'moduleName/name'
  * 并且这个模块下面所有的 actions/mutations/getters 都会加上 namespace 前缀
  * 这样使得多个模块能够对同一 mutation 或 action 作出响应。
  * 如果希望你的模块更加自包含或提高可重用性，
  * 你可以通过添加 namespaced: true 的方式使其成为命名空间模块。
  * 当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。
  */</span>
  <span class="token function">getNamespace</span> <span class="token punctuation">(</span><span class="token parameter">path</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> module <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root
    <span class="token keyword">return</span> path<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">namespace<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      module <span class="token operator">=</span> module<span class="token punctuation">.</span><span class="token function">getChild</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
      <span class="token keyword">return</span> namespace <span class="token operator">+</span> <span class="token punctuation">(</span>module<span class="token punctuation">.</span>namespaced <span class="token operator">?</span> key <span class="token operator">+</span> <span class="token string">'/'</span> <span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>从 <code>root module</code> 开始，通过 <code>reduce</code> 方法一层层找子模块，如果发现该模块配置了 namespaced 为 true，则把该模块的 key 拼到 namesapce 中，最终返回完整的 namespace 字符串。</p> <p>回到 <code>installModule</code> 方法，接下来把 namespace 对应的模块保存下来，为了方便以后能根据 namespace 查找模块：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/**
  * 如果有namespace则在_modulesNamespaceMap中注册
  * 生成 _modulesNamespaceMap 对象，存放 namespaced 为 true 的模块
  * 属性名是所有的父级 module 名 +  '/'，值为当前注册的 module 实例
  * 通过加上父级模块的路径，保证了每个模块都有自己的命名空间，
  * 防止名字相同的 getter/actions/mutations 命名冲突
  */</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>module<span class="token punctuation">.</span>namespaced<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>store<span class="token punctuation">.</span>_modulesNamespaceMap<span class="token punctuation">[</span>namespace<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">[vuex] duplicate namespace </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>namespace<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> 
      for the namespaced module </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 保存namespaced模块</span>
    store<span class="token punctuation">.</span>_modulesNamespaceMap<span class="token punctuation">[</span>namespace<span class="token punctuation">]</span> <span class="token operator">=</span> module
  <span class="token punctuation">}</span>
</code></pre></div><p>接下来判断<code>非 root module</code> 且<code>非 hot</code> 的情况执行一些逻辑：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/* 添加当前模块，作为父模块的 state 对象中的属性，在 state 中建立父子关系 */</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isRoot <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>hot<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">/* 获取父级的state */</span>
    <span class="token keyword">const</span> parentState <span class="token operator">=</span> <span class="token function">getNestedState</span><span class="token punctuation">(</span>rootState<span class="token punctuation">,</span> path<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
     <span class="token comment">/* 模块名称 */</span>
    <span class="token keyword">const</span> moduleName <span class="token operator">=</span> path<span class="token punctuation">[</span>path<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>
    store<span class="token punctuation">.</span><span class="token function">_withCommit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>moduleName <span class="token keyword">in</span> parentState<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          console<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span>
            <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">[vuex] state field &quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>moduleName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot; was overridden 
            by a module with the same name at &quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot;</span><span class="token template-punctuation string">`</span></span>
          <span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      <span class="token comment">/**
      * 在父模块的 state 属性中添加当前模块，属性名是当前模块名，值是 state 对象
      * Vuex 之所以这么做可能是因为需要让所有的模块状态都保存在 state 中
      * 使得在重置模块时能够通过保留 state 从而保留所有的模块依赖关系
      * 将子module设置称响应式的
      */</span>
      Vue<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>parentState<span class="token punctuation">,</span> moduleName<span class="token punctuation">,</span> module<span class="token punctuation">.</span>state<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>首先保存 namespaced 模块到 <code>store._modulesNamespaceMap</code>，再判断<strong>是否为根组件</strong>且<strong>不是 hot</strong>，得到<strong>父级 module 的 state</strong> 和<strong>当前 module 的 name</strong>，
调用 <code>Vue.set(parentState, moduleName, module.state)</code> 将<strong>当前 module 的 state</strong> 挂载到<strong>父 state</strong> 上。
接下去会<strong>设置 module 的上下文</strong>，因为可能存在 namespaced，需要额外处理。</p> <p><code>makeLocalContext</code>，构造了一个<strong>本地上下文环境</strong>：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> local <span class="token operator">=</span> module<span class="token punctuation">.</span>context <span class="token operator">=</span> <span class="token function">makeLocalContext</span><span class="token punctuation">(</span>store<span class="token punctuation">,</span> namespace<span class="token punctuation">,</span> path<span class="token punctuation">)</span>
</code></pre></div><h3 id="makelocalcontext-的实现"><a href="#makelocalcontext-的实现" class="header-anchor">#</a> makeLocalContext 的实现</h3> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/* src/store.js */</span>

<span class="token comment">/**
* 根据是否开启命名空间来获取上下文
* 设置module的上下文，绑定对应的dispatch、commit、getters、state
* 声明了 namespace 的模块中的 actions dispatch 时不需要加上命名空间，
* 自动作用与当前模块 namespace (a/b/c/)
* 如果没有声明 namespaced，namespace 为一个空字符串
*/</span>
<span class="token keyword">function</span> <span class="token function">makeLocalContext</span> <span class="token punctuation">(</span><span class="token parameter">store<span class="token punctuation">,</span> namespace<span class="token punctuation">,</span> path</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> noNamespace <span class="token operator">=</span> namespace <span class="token operator">===</span> <span class="token string">''</span>
  <span class="token comment">// local 为 action 中第一个 ctx 参数</span>
  <span class="token keyword">const</span> local <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment">/**
    * 如果没有命名空间，则使用普通的 dispatch
    */</span>
    dispatch<span class="token operator">:</span> noNamespace <span class="token operator">?</span> store<span class="token punctuation">.</span><span class="token function-variable function">dispatch</span> <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">_type<span class="token punctuation">,</span> _payload<span class="token punctuation">,</span> _options</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token comment">// 统一格式 因为支持payload风格和对象风格</span>
      <span class="token keyword">const</span> args <span class="token operator">=</span> <span class="token function">unifyObjectStyle</span><span class="token punctuation">(</span>_type<span class="token punctuation">,</span> _payload<span class="token punctuation">,</span> _options<span class="token punctuation">)</span>
      <span class="token keyword">const</span> <span class="token punctuation">{</span> payload<span class="token punctuation">,</span> options <span class="token punctuation">}</span> <span class="token operator">=</span> args
      <span class="token keyword">let</span> <span class="token punctuation">{</span> type <span class="token punctuation">}</span> <span class="token operator">=</span> args
      <span class="token comment">// 如果root: true 不会加上namespace 即在命名空间模块里提交根的 action</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>options <span class="token operator">||</span> <span class="token operator">!</span>options<span class="token punctuation">.</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        type <span class="token operator">=</span> namespace <span class="token operator">+</span> type
        <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>store<span class="token punctuation">.</span>_actions<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">[vuex] unknown local action type: 
          </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>args<span class="token punctuation">.</span>type<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">, global type: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>type<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
          <span class="token keyword">return</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 触发action</span>
      <span class="token keyword">return</span> store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> payload<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>

    commit<span class="token operator">:</span> noNamespace <span class="token operator">?</span> store<span class="token punctuation">.</span><span class="token function-variable function">commit</span> <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">_type<span class="token punctuation">,</span> _payload<span class="token punctuation">,</span> _options</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token comment">// 统一格式 因为支持payload风格和对象风格</span>
      <span class="token keyword">const</span> args <span class="token operator">=</span> <span class="token function">unifyObjectStyle</span><span class="token punctuation">(</span>_type<span class="token punctuation">,</span> _payload<span class="token punctuation">,</span> _options<span class="token punctuation">)</span>
      <span class="token keyword">const</span> <span class="token punctuation">{</span> payload<span class="token punctuation">,</span> options <span class="token punctuation">}</span> <span class="token operator">=</span> args
      <span class="token keyword">let</span> <span class="token punctuation">{</span> type <span class="token punctuation">}</span> <span class="token operator">=</span> args

      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>options <span class="token operator">||</span> <span class="token operator">!</span>options<span class="token punctuation">.</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/* 如果定义了 namespace:true 则会自动在 type 前加上模块的命名空间（a/b/c/ + type）*/</span>
        <span class="token comment">// 如果root: true 不会加上namespace 即在命名空间模块里提交根的 mutation</span>
        type <span class="token operator">=</span> namespace <span class="token operator">+</span> type
        <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>store<span class="token punctuation">.</span>_mutations<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">[vuex] unknown local mutation type: 
          </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>args<span class="token punctuation">.</span>type<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">, global type: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>type<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
          <span class="token keyword">return</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 触发mutation</span>
      store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> payload<span class="token punctuation">,</span> options<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// getters and state object must be gotten lazily</span>
  <span class="token comment">// because they will be changed by vm update</span>
  <span class="token comment">// 定义 local.getters 和 local.state</span>
  <span class="token comment">/* 这里的getters和state需要延迟处理，需要等数据更新后才进行计算，
  所以使用getter函数，当访问的时候再进行一次计算 */</span>
  Object<span class="token punctuation">.</span><span class="token function">defineProperties</span><span class="token punctuation">(</span>local<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    getters<span class="token operator">:</span> <span class="token punctuation">{</span>
      get<span class="token operator">:</span> noNamespace
        <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> store<span class="token punctuation">.</span>getters
        <span class="token comment">/**
        * 生成上下文的 getters 对象 获取namespace下的getters
        * 允许在 module 中通过 ctx.getters ，使得访问当前 module 的 getter 不需要添加命名空间
        */</span>
        <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">makeLocalGetters</span><span class="token punctuation">(</span>store<span class="token punctuation">,</span> namespace<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    state<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">getNestedState</span><span class="token punctuation">(</span>store<span class="token punctuation">.</span>state<span class="token punctuation">,</span> path<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

  <span class="token keyword">return</span> local
<span class="token punctuation">}</span>
</code></pre></div><p><code>makeLocalContext</code> 传入 3 个参数：</p> <ul><li><code>store</code> 表示 root store</li> <li><code>namespace</code> 表示模块的命名空间</li> <li><code>path</code> 表示模块的 path</li></ul> <p>该方法定义了 <strong>local 对象</strong>，这里会判断 <strong>module 是否设置了 namespace</strong> ，如果没有 namespace，它们就<strong>直接指向了 root store</strong> 的 dispatch 和 commit 方法。
如果存在，创建方法，给 type <strong>自动拼接上 namespace</strong>。如果声明了**<code>{ root: true }</code>也不做处理**。</p> <p><strong>对于 getters 和 states 而言</strong>，需要<strong>延迟处理</strong>，需要等<strong>数据更新后</strong>才进行计算，所以使用 <code>Object.defineProperties</code> 的 getter 函数，当访问的时候再进行计算。
<strong>对于 getters 而言</strong>，如果没有 namespace，则直接返回 root store 的 getters，否则返回 <code>makeLocalGetters(store, namespace)</code>的返回值; <strong>对于 states 而言</strong>，
则是通过 <code>getNestedState(store.state, path)</code> 方法获取。</p> <h3 id="makelocalgetters-的实现"><a href="#makelocalgetters-的实现" class="header-anchor">#</a> makeLocalGetters 的实现</h3> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/* src/store.js */</span>

<span class="token keyword">function</span> <span class="token function">makeLocalGetters</span> <span class="token punctuation">(</span><span class="token parameter">store<span class="token punctuation">,</span> namespace</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> gettersProxy <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token keyword">const</span> splitPos <span class="token operator">=</span> namespace<span class="token punctuation">.</span>length
  <span class="token comment">// store.getters 保存了所有 getters，并且同名的 getters 会添加命名空间</span>
  Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>store<span class="token punctuation">.</span>getters<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">type</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果getter不在该命名空间下 直接return</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>type<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> splitPos<span class="token punctuation">)</span> <span class="token operator">!==</span> namespace<span class="token punctuation">)</span> <span class="token keyword">return</span>

    <span class="token comment">// 去掉type上的命名空间</span>
    <span class="token comment">// 根据 type 获取 localType 名</span>
    <span class="token comment">// type(a/b/c/getter1) = splitPos(a/b/c/) + localType(getter1)</span>
    <span class="token keyword">const</span> localType <span class="token operator">=</span> type<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>splitPos<span class="token punctuation">)</span>

    <span class="token comment">// Add a port to the getters proxy.</span>
    <span class="token comment">// Define as getter property because</span>
    <span class="token comment">// we do not want to evaluate the getters in this time.</span>
    <span class="token comment">// 给getters加一层代理 这样在module中获取到的getters不会带命名空间，</span>
    <span class="token comment">// 实际返回的是store.getters[type] type是有命名空间的</span>
    Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>gettersProxy<span class="token punctuation">,</span> localType<span class="token punctuation">,</span> <span class="token punctuation">{</span>
      <span class="token comment">// 访问localType实际上映射到 store.getters 中的type</span>
      <span class="token comment">/* 即访问 local.getter 最终会拼上命名空间从 store.getters 找 */</span>
      <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> store<span class="token punctuation">.</span>getters<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">,</span>
      enumerable<span class="token operator">:</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

  <span class="token keyword">return</span> gettersProxy
<span class="token punctuation">}</span>
</code></pre></div><p><code>makeLocalGetters</code> 首先获取了 <code>namespace</code> 的长度，然后<strong>遍历</strong> <code>root store</code> 下的所有 <code>getters</code>，先判断它的类型<strong>是否匹配</strong> <code>namespace</code>，
只有匹配的时候我们从 <code>namespace</code> 的位置<strong>截取</strong>后面的字符串得到 <code>localType</code>，
接着用 <code>Object.defineProperty</code> 定义了 <code>gettersProxy</code>，获取 <code>localType</code> 实际上是访问了 <code>store.getters[type]</code>。</p> <h3 id="getnestedstate-的实现"><a href="#getnestedstate-的实现" class="header-anchor">#</a> getNestedState 的实现</h3> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/* src/store.js */</span>

<span class="token keyword">function</span> <span class="token function">getNestedState</span> <span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> path</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> path<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> state<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

</code></pre></div><p><code>getNestedState</code> 方法很简单，就是根据 path 查找 state 上的<strong>嵌套 state</strong>，最终找到<strong>目标模块的 state</strong>。在这里就是传入 <code>rootState</code> 和 <code>path</code>，计算出当前模块的<strong>父模块的 state</strong>，
由于模块的 path 是根据模块的名称 <code>concat</code> 连接的，<strong>所以 path 的最后一个元素就是当前模块的模块名</strong></p> <p>那么构造完 <strong>local 上下文</strong>后，我们再回到 <code>installModule</code> 方法，接下来它就会遍历模块中定义的 mutations、actions、getters 以及 子module，分别执行它们的注册工作，
它们的实现都差不多。</p> <h3 id="registermutation-的实现"><a href="#registermutation-的实现" class="header-anchor">#</a> registerMutation 的实现</h3> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/* src/store.js */</span>

<span class="token comment">/* 遍历注册mutation */</span>
  module<span class="token punctuation">.</span><span class="token function">forEachMutation</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">mutation<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">/* mutation 是 mutations 中定义的函数，key 为这个 mutation 函数的 key */</span>
    <span class="token keyword">const</span> namespacedType <span class="token operator">=</span> namespace <span class="token operator">+</span> key
    <span class="token comment">/* 给 store 的 _mutations 对象添加当前模块包含的所有 mutations */</span>
    <span class="token function">registerMutation</span><span class="token punctuation">(</span>store<span class="token punctuation">,</span> namespacedType<span class="token punctuation">,</span> mutation<span class="token punctuation">,</span> local<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>首先遍历模块中的 mutations 的定义，拿到<strong>每一个 mutation 和 key</strong>，并把 key <strong>拼接上 namespace</strong>，然后执行 <code>registerMutation</code> 方法。
该方法实际上就是给 root store 上的 <code>_mutations[types]</code> 添加 <code>wrappedMutationHandler</code> 方法，
该方法的具体实现我们之后会提到。<strong><code>注意，同一 type 的 _mutations 可以对应多个方法</code></strong>。</p> <p><code>registerMutation</code> 方法的实现 :</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/* src/store.js */</span>

<span class="token comment">// 参数是store、mutation的key（namespace处理后的）、handler函数、当前module上下文</span>
<span class="token keyword">function</span> <span class="token function">registerMutation</span> <span class="token punctuation">(</span><span class="token parameter">store<span class="token punctuation">,</span> type<span class="token punctuation">,</span> handler<span class="token punctuation">,</span> local</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/**
  * 所有的mutation会被push进一个数组中，
  * 这样相同的mutation就可以调用不同module中的同名的mutation了
  * 首先判断store._mutations是否存在，否则给空数组
  */</span>
  <span class="token keyword">const</span> entry <span class="token operator">=</span> store<span class="token punctuation">.</span>_mutations<span class="token punctuation">[</span>type<span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token punctuation">(</span>store<span class="token punctuation">.</span>_mutations<span class="token punctuation">[</span>type<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token comment">/**
   * 将mutation包一层函数，push到数组中
   * mutations对象中的mutation实际上是一个数组，当有重复名字的mutation存在时，依次执行
   */</span>
  entry<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">wrappedMutationHandler</span> <span class="token punctuation">(</span><span class="token parameter">payload</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/**
     * handler 为 mutation 函数，并且让这个 mutation 能够不用命名前缀访问当前模块的state 
     * 包一层，commit执行时只需要传入payload
     * 执行时让this指向store，参数为当前module上下文的state和用户额外添加的payload
     */</span>
    <span class="token function">handler</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>store<span class="token punctuation">,</span> local<span class="token punctuation">.</span>state<span class="token punctuation">,</span> payload<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>registerMutation</code> 是对 store 的 mutation 的初始化，它接受 4 个参数:</p> <ul><li><code>store</code>  当前 Store 实例</li> <li><code>type</code>  模块 的 名称</li> <li><code>handler</code>  mutation 执行的<strong>回调函数</strong></li> <li><code>local</code> <strong>makeLocalContext(store, namespace, path)<strong>生成的</strong>当前模块的路径</strong></li></ul> <p>mutation 的作用就是同步修改当前模块的 state ，函数首先通过 <code>type</code> 拿到对应的 <strong>mutation 对象数组</strong>，
然后把一个 mutation 的<strong>包装函数</strong> push 到这个数组中，这个函数接收一个参数 payload，这个就是我们在定义 mutation 的时候接收的额外参数。
这个函数执行的时候<strong>会调用 mutation 的回调函数</strong>，并将<strong>实例对象 store</strong>，<strong>当前模块的 state</strong>，和 <strong>playload</strong> 一起作为回调函数的参数。</p> <h3 id="registeraction-的实现"><a href="#registeraction-的实现" class="header-anchor">#</a> registerAction 的实现</h3> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/* src/store.js */</span>

<span class="token comment">/* 遍历注册action */</span>
  module<span class="token punctuation">.</span><span class="token function">forEachAction</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">action<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> type <span class="token operator">=</span> action<span class="token punctuation">.</span>root <span class="token operator">?</span> key <span class="token operator">:</span> namespace <span class="token operator">+</span> key
    <span class="token keyword">const</span> handler <span class="token operator">=</span> action<span class="token punctuation">.</span>handler <span class="token operator">||</span> action
    <span class="token function">registerAction</span><span class="token punctuation">(</span>store<span class="token punctuation">,</span> type<span class="token punctuation">,</span> handler<span class="token punctuation">,</span> local<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>首先遍历模块中的 <strong>actions</strong> 的定义，拿到<strong>每一个 action 和 key</strong>，并判断 <code>action.root</code>，如果<strong>否的情况</strong>把 <strong>key 拼接上 namespace</strong>，然后执行 <code>registerAction</code> 方法。
该方法实际上就是给 root store 上的 <code>_actions[types]</code> 添加 <code>wrappedActionHandler</code> 方法，该方法的具体实现我们之后会提到。<strong><code>注意，同一 type 的 _actions 可以对应多个方法</code></strong>。</p> <p><code>registerAction</code> 方法的实现:</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/* src/store.js */</span>

<span class="token comment">// 参数是store、type（namespace处理后的）、handler函数、module上下文</span>
<span class="token keyword">function</span> <span class="token function">registerAction</span> <span class="token punctuation">(</span><span class="token parameter">store<span class="token punctuation">,</span> type<span class="token punctuation">,</span> handler<span class="token punctuation">,</span> local</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 获取_actions数组，不存在即赋值为空数组</span>
  <span class="token keyword">const</span> entry <span class="token operator">=</span> store<span class="token punctuation">.</span>_actions<span class="token punctuation">[</span>type<span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token punctuation">(</span>store<span class="token punctuation">.</span>_actions<span class="token punctuation">[</span>type<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token comment">/**
  * action 会被 wrappedActionHandler 包裹一层，每当 dispatch 执行一个 action 时
  * 都会通过 wrappedActionHandler 将 action 包裹为一个 promise，
  * 并且传入 ctx 中的 dispatch 等方法
  * 执行时需要传入payload和cb
  */</span>
  entry<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">wrappedActionHandler</span> <span class="token punctuation">(</span><span class="token parameter">payload</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token function">handler</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>store<span class="token punctuation">,</span> <span class="token punctuation">{</span>
      dispatch<span class="token operator">:</span> local<span class="token punctuation">.</span>dispatch<span class="token punctuation">,</span>
      commit<span class="token operator">:</span> local<span class="token punctuation">.</span>commit<span class="token punctuation">,</span>
      getters<span class="token operator">:</span> local<span class="token punctuation">.</span>getters<span class="token punctuation">,</span>
      state<span class="token operator">:</span> local<span class="token punctuation">.</span>state<span class="token punctuation">,</span>
      <span class="token comment">// rootGetters 为 store 中的根getters</span>
      rootGetters<span class="token operator">:</span> store<span class="token punctuation">.</span>getters<span class="token punctuation">,</span>
      rootState<span class="token operator">:</span> store<span class="token punctuation">.</span>state
    <span class="token punctuation">}</span><span class="token punctuation">,</span> payload<span class="token punctuation">)</span>
    <span class="token comment">/* 判断是否是Promise */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isPromise</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">/* 不是Promise对象的时候转化称Promise对象 */</span>
      <span class="token comment">// 如果action的执行结果不是promise，将他包裹为promise，这样就支持promise的链式调用</span>
      res <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>store<span class="token punctuation">.</span>_devtoolHook<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">/* 存在devtool捕获的时候触发vuex的error给devtool */</span>
      <span class="token keyword">return</span> res<span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">err</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        store<span class="token punctuation">.</span>_devtoolHook<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'vuex:error'</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
        <span class="token keyword">throw</span> err
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> res
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>registerAction</code> 是对 store 的 <strong>action 的初始化</strong>，它和 <code>registerMutation</code> 的<strong>参数一致</strong>，和 mutation 不同一点，mutation 是同步修改当前模块的 state，
而 action 是<strong>异步去修改 state</strong>，在 action 的<strong>回调中并不会直接修改 state</strong>。</p> <ul><li><code>payload</code> 表示额外参数</li> <li><code>cb</code> 表示回调函数（实际上我们并没有使用它）</li></ul> <p>action 是通过提交一个 mutation 去修改 state（mutation 是修改 state 的唯一途径）。</p> <p>函数首先也是通过 <code>type</code> 拿到对应 action 的对象数组，然后把一个 action 的<strong>包装函数</strong> push 到 <code>store._actions</code> 数组中，
函数执行的时候会调用 action 的回调函数，传入一个 <strong>context 对象</strong>，context 对象包括了 store 的 <code>commit</code> 和 <code>dispatch</code> 方法、<code>getter</code>、<code>当前模块的 state 和 rootState</code> 等等。
接着对这个函数的<strong>返回值做判断</strong>，如果不是一个 Promise 对象，则调用 <code>Promise.resolve（res）</code> 给 res 包装成了一个 Promise 对象。
这里也就解释了<strong>为何 Vuex 的源码依赖 Promise</strong>，这里对 Promise 的判断也和简单，参考代码 <code>src/util.js</code>，对 <code>isPromise</code> 的判断如下：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/* src/util.js */</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">isPromise</span> <span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> val <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> val<span class="token punctuation">.</span>then <span class="token operator">===</span> <span class="token string">'function'</span>
<span class="token punctuation">}</span>
</code></pre></div><p>其实就是简单的<strong>检查对象的 then 方法</strong>，如果包含说明就是一个 Promise 对象。</p> <p>接着判断 <code>store._devtoolHook</code>，这个只有当用到 <code>Vuex devtools</code>开启的时候，我们<strong>才能捕获 promise 过程</strong>。
<code>action</code> 的<strong>包装函数</strong>最后返回 res ，它就是一个地地道道的 Promise 对象。</p> <h3 id="registergetter-的实现"><a href="#registergetter-的实现" class="header-anchor">#</a> registerGetter 的实现</h3> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/* src/store.js */</span>

 <span class="token comment">/* 遍历注册getter */</span>
  module<span class="token punctuation">.</span><span class="token function">forEachGetter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">getter<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> namespacedType <span class="token operator">=</span> namespace <span class="token operator">+</span> key
    <span class="token function">registerGetter</span><span class="token punctuation">(</span>store<span class="token punctuation">,</span> namespacedType<span class="token punctuation">,</span> getter<span class="token punctuation">,</span> local<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>首先遍历模块中的 <code>getters</code> 的定义，拿到<strong>每一个 getter 和 key</strong>，并把 <strong>key 拼接上 namespace</strong>，然后执行 <code>registerGetter</code> 方法。
该方法实际上就是给 root store 上的 <code>_wrappedGetters[key]</code> 指定 <code>wrappedGetter</code> 方法，
该方法的具体实现我们之后会提到。<strong><code>注意，同一 type 的 _wrappedGetters 只能定义一个</code></strong>。</p> <p><code>registerGetter</code> 方法的实现：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/* src/store.js */</span>

<span class="token comment">// 参数是store、type（namesapce处理后的）、getter函数、module上下文</span>
<span class="token keyword">function</span> <span class="token function">registerGetter</span> <span class="token punctuation">(</span><span class="token parameter">store<span class="token punctuation">,</span> type<span class="token punctuation">,</span> rawGetter<span class="token punctuation">,</span> local</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// getter不能有相同命名 不允许重复定义getters</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>store<span class="token punctuation">.</span>_wrappedGetters<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">[vuex] duplicate getter key: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>type<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>
  <span class="token comment">/**
  * 包一层，保存到_wrappedGetters中
  * _wrappedGetters 和 store.getters 的区别在于，前者的值是一个函数，后者的值是函数计算后的结果
  * 当执行里面的 getter 函数时，会传入 local 对象来计算出最终值
  */</span>
  store<span class="token punctuation">.</span>_wrappedGetters<span class="token punctuation">[</span>type<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">wrappedGetter</span> <span class="token punctuation">(</span><span class="token parameter">store</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 执行时传入store，执行对应的getter函数</span>
    <span class="token keyword">return</span> <span class="token function">rawGetter</span><span class="token punctuation">(</span>
      local<span class="token punctuation">.</span>state<span class="token punctuation">,</span> <span class="token comment">// local state</span>
      local<span class="token punctuation">.</span>getters<span class="token punctuation">,</span> <span class="token comment">// local getters</span>
      store<span class="token punctuation">.</span>state<span class="token punctuation">,</span> <span class="token comment">// root state</span>
      store<span class="token punctuation">.</span>getters <span class="token comment">// root getters</span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>registerGetter</code> 是对 store 的 <strong>getters 初始化</strong>，它接受 4个 参数，</p> <ul><li><code>store</code> 表示当前 Store 实例</li> <li><code>type</code> 表示当前的命名空间的key</li> <li><code>rawGetter</code> 表示当前模块下的单个getter</li> <li><code>local</code> 对应当前的模块上下文</li></ul> <p>这个函数做的事情就是<strong>把每一个 getter 包装成一个方法</strong>，添加到 <code>store._wrappedGetters</code> 对象中， <strong>getter 的 key 是不允许重复的</strong>，
使用 <code>store._wrappedGetters[type]</code> 来判断 key <strong>是否重复</strong>。
在这个包装的方法里，会执行 getter 的<strong>回调函数</strong>，并把<code>当前模块的 state</code>，store 的 <code>getters</code> 和 <code>store 的 rootState</code>，
<code>store 的 getters</code> 作为它参数。</p> <p>再回到 <code>installModule</code> 方法，最后一步就是遍历模块中的所有子 modules，递归执行 <code>installModule</code> 方法：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>  <span class="token comment">/**
  * 递归注册子模块，建立 module 树，并且给 path 数组推入当前命名空间（字符串）
  * 此时所有的子模块中的 state，actions，mutations，getters 都被注册完毕
  */</span>
  module<span class="token punctuation">.</span><span class="token function">forEachChild</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">child<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">installModule</span><span class="token punctuation">(</span>store<span class="token punctuation">,</span> rootState<span class="token punctuation">,</span> path<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> child<span class="token punctuation">,</span> hot<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>所以 <code>installModule</code> 实际上就是完成了模块下的 state、getters、actions、mutations 的初始化工作，并且通过递归遍历的方式，就完成了所有子模块的安装工作。</p> <h2 id="resetstorevm"><a href="#resetstorevm" class="header-anchor">#</a> resetStoreVM</h2> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/* src/store.js */</span>

 <span class="token comment">/*
 * 新建一个vm实例保存state，在computed属性中保存getters，
 * 通过watch观察state，保证都使用commit修改state
 * 通过vm重设store，新建Vue对象使用Vue内部的响应式实现注册state以及computed
 * 初始化 store._vm，观测 state 和 getters 的变化
 * */</span>
<span class="token keyword">function</span> <span class="token function">resetStoreVM</span> <span class="token punctuation">(</span><span class="token parameter">store<span class="token punctuation">,</span> state<span class="token punctuation">,</span> hot</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 存放之前的vm对象 */</span>
  <span class="token keyword">const</span> oldVm <span class="token operator">=</span> store<span class="token punctuation">.</span>_vm

  <span class="token comment">// bind store public getters</span>
  store<span class="token punctuation">.</span>getters <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token comment">// reset local getters cache</span>
  store<span class="token punctuation">.</span>_makeLocalGettersCache <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> wrappedGetters <span class="token operator">=</span> store<span class="token punctuation">.</span>_wrappedGetters
  <span class="token keyword">const</span> computed <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token comment">/**
  * 遍历 store._wrappedGetters 对象
  * 依次拿到每个 getter 的包装函数，并把这个包装函数执行的结果用 computed 临时变量保存。
  * 通过 Object.defineProperty 为每一个 getter 方法设置 get 方法
  * 调用 this.$store.getters.xxxgetters 这个方法的时候，
  * 会访问 store._vm[xxxgetters]，也就是 Vue对象 的 computed 属性
  */</span>
  <span class="token function">forEachValue</span><span class="token punctuation">(</span>wrappedGetters<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// use computed to leverage its lazy-caching mechanism</span>
    <span class="token comment">// direct inline function use will lead to closure preserving oldVm.</span>
    <span class="token comment">// using partial to return function with only arguments preserved in closure environment.</span>
    <span class="token comment">/**
    * fn 是 wrappedGetters 对象的属性值，即 wrappedGetter 函数
    * 将 wrappedGetters 对象上所有的 getter 函数，作为内部 vm 实例的 computed 属性
    * 这里传入了全局的 store 对象，
    * 因为 getter 的 3，4 参数需要依赖 store 对象（store.state，store.getters）
    */</span>
    computed<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">partial</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> store<span class="token punctuation">)</span>
    <span class="token comment">/**
    * 定义 store.getters 属性，使得能直接通过 store.getters.&lt; getter 名&gt; 访问对应的 getter
    * key 为含有命名空间的完整路径
    */</span>
    Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>store<span class="token punctuation">.</span>getters<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
      <span class="token comment">// 访问 store.getters 最终会指向 vm 实例对应的 computed 属性，同时触发计算返回结果值</span>
      <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> store<span class="token punctuation">.</span>_vm<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span>
      enumerable<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token comment">// for local getters</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

  <span class="token comment">// use a Vue instance to store the state tree</span>
  <span class="token comment">// suppress warnings just in case the user has added</span>
  <span class="token comment">// some funky global mixins</span>
  <span class="token comment">/**
  * 使用一个vue实例来保存state和getter
  * 获取到全局 Vue.config.silent 的配置，然后临时把这个配置设成 true
  * 设置 silent 为 true 的目的是为了取消这个 _vm 的所有日志和警告
  */</span>  
  <span class="token keyword">const</span> silent <span class="token operator">=</span> Vue<span class="token punctuation">.</span>config<span class="token punctuation">.</span>silent
  Vue<span class="token punctuation">.</span>config<span class="token punctuation">.</span>silent <span class="token operator">=</span> <span class="token boolean">true</span>
  <span class="token comment">/**
  * 实例化一个 Vue 的实例，把 store 的状态树 state 作为 data 传入，
  * 把我们刚才的临时变量 computed 作为计算属性传入
  * 再把之前的 silent 配置重置
  * 把 computed 对象作为 _vm的 computed 属性，这样就完成了 getters 的注册
  * 因为当我们在组件中访问 this.$store.getters.xxxgetters 的时候，
  * 就相当于访问 store._vm[xxxgetters]，
  * 也就是在访问 computed[xxxgetters]，这样就访问到了 xxxgetters 对应的回调函数了
  */</span>
  store<span class="token punctuation">.</span>_vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    data<span class="token operator">:</span> <span class="token punctuation">{</span>
      $$state<span class="token operator">:</span> state
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    computed
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  Vue<span class="token punctuation">.</span>config<span class="token punctuation">.</span>silent <span class="token operator">=</span> silent

  <span class="token comment">// enable strict mode for new vm</span>
  <span class="token comment">// 是否开启 vuex 的 strict 严格模式，目的是禁止 commit 以外的方法修改 state</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>store<span class="token punctuation">.</span>strict<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">enableStrictMode</span><span class="token punctuation">(</span>store<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">/**
  * 将旧的 _vm 对象的状态设置为 null，并调用 $destroy 方法销毁这个旧的 _vm 对象
  */</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>oldVm<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>hot<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// dispatch changes in all subscribed watchers</span>
      <span class="token comment">// to force getter re-evaluation for hot reloading.</span>
      store<span class="token punctuation">.</span><span class="token function">_withCommit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        oldVm<span class="token punctuation">.</span>_data<span class="token punctuation">.</span>$$state <span class="token operator">=</span> <span class="token keyword">null</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    Vue<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> oldVm<span class="token punctuation">.</span><span class="token function">$destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个方法主要是重置一个<strong>私有的 _vm 对象</strong>，它是一个 Vue 的实例。这个 <strong>_vm 对象</strong>会保留我们的 <strong>state 树</strong>，以及用<strong>计算属性的方式</strong>存储了 store 的 <strong>getters</strong>。</p> <p><code>resetStoreVM</code> 的作用实际上是想<strong>建立 getters 和 state 的联系</strong>，因为从设计上 getters 的获取就依赖了 state ，并且希望它的依赖能被缓存起来，
且只有当它的依赖值发生了改变才会被重新计算。<strong>因此这里利用了 Vue 中用 computed 计算属性来实现</strong>。</p> <p><code>resetStoreVM</code> 首先遍历了 <code>_wrappedGetters</code> 获得每个 getter 的函数 fn 和 key，然后定义了 <code>computed[key] = () =&gt; fn(store)</code>。
我们之前提到过 <code>_wrappedGetters</code> 的初始化过程，它定义在 <code>registerGetter</code> 方法中。这里 <code>fn(store)</code> 相当于执行了 <code>wrappedGetter</code> 方法，
返回的就是 <code>rawGetter</code> 的执行函数。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/* src/store.js */</span>

<span class="token comment">// 参数是store、type（namesapce处理后的）、getter函数、module上下文</span>
<span class="token keyword">function</span> <span class="token function">registerGetter</span> <span class="token punctuation">(</span><span class="token parameter">store<span class="token punctuation">,</span> type<span class="token punctuation">,</span> rawGetter<span class="token punctuation">,</span> local</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// getter不能有相同命名 不允许重复定义getters</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>store<span class="token punctuation">.</span>_wrappedGetters<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">[vuex] duplicate getter key: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>type<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>
  <span class="token comment">/**
  * 包一层，保存到_wrappedGetters中
  * _wrappedGetters 和 store.getters 的区别在于，前者的值是一个函数，后者的值是函数计算后的结果
  * 当执行里面的 getter 函数时，会传入 local 对象来计算出最终值
  */</span>
  store<span class="token punctuation">.</span>_wrappedGetters<span class="token punctuation">[</span>type<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">wrappedGetter</span> <span class="token punctuation">(</span><span class="token parameter">store</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 执行时传入store，执行对应的getter函数</span>
    <span class="token keyword">return</span> <span class="token function">rawGetter</span><span class="token punctuation">(</span>
      local<span class="token punctuation">.</span>state<span class="token punctuation">,</span> <span class="token comment">// local state</span>
      local<span class="token punctuation">.</span>getters<span class="token punctuation">,</span> <span class="token comment">// local getters</span>
      store<span class="token punctuation">.</span>state<span class="token punctuation">,</span> <span class="token comment">// root state</span>
      store<span class="token punctuation">.</span>getters <span class="token comment">// root getters</span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>rawGetter</code> 表示当前模块下的单个 getter，就是用户定义的 getter 函数。它的前 2 个参数是 <code>local state</code> 和 <code>local getters</code>，后 2 个参数是 <code>root state</code> 和 <code>root getters</code>。</p> <p>接着实例化一个 Vue 实例 <code>store._vm</code>，并把 <code>computed</code> 传入：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/**
  * 实例化一个 Vue 的实例，把 store 的状态树 state 作为 data 传入，
  * 把我们刚才的临时变量 computed 作为计算属性传入
  * 再把之前的 silent 配置重置
  * 把 computed 对象作为 _vm的 computed 属性，这样就完成了 getters 的注册
  * 因为当我们在组件中访问 this.$store.getters.xxxgetters 的时候，
  * 就相当于访问 store._vm[xxxgetters]，
  * 也就是在访问 computed[xxxgetters]，这样就访问到了 xxxgetters 对应的回调函数了
  */</span>
  store<span class="token punctuation">.</span>_vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    data<span class="token operator">:</span> <span class="token punctuation">{</span>
      $$state<span class="token operator">:</span> state
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    computed
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  Vue<span class="token punctuation">.</span>config<span class="token punctuation">.</span>silent <span class="token operator">=</span> silent
</code></pre></div><p>data 选项里定义了 <code>$$state</code> 属性，而我们访问 <code>store.state</code> 的时候，实际上会访问 Store 类上定义的 state 的 <strong>get 方法</strong>：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/* src/store.js */</span>

<span class="token keyword">get</span> <span class="token function">state</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_vm<span class="token punctuation">.</span>_data<span class="token punctuation">.</span>$$state
<span class="token punctuation">}</span>
</code></pre></div><p>它实际上就访问了 <code>store._vm._data.$$state</code>。那么 getters 和 state 是如何建立依赖逻辑的呢，我们再看这段代码逻辑：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code> <span class="token comment">/**
  * 遍历 store._wrappedGetters 对象
  * 依次拿到每个 getter 的包装函数，并把这个包装函数执行的结果用 computed 临时变量保存。
  * 通过 Object.defineProperty 为每一个 getter 方法设置 get 方法
  * 调用 this.$store.getters.xxxgetters 这个方法的时候，
  * 会访问 store._vm[xxxgetters]，也就是 Vue对象 的 computed 属性
  */</span>
  <span class="token function">forEachValue</span><span class="token punctuation">(</span>wrappedGetters<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// use computed to leverage its lazy-caching mechanism</span>
    <span class="token comment">// direct inline function use will lead to closure preserving oldVm.</span>
    <span class="token comment">// using partial to return function with only arguments preserved in closure environment.</span>
    <span class="token comment">/**
    * fn 是 wrappedGetters 对象的属性值，即 wrappedGetter 函数
    * 将 wrappedGetters 对象上所有的 getter 函数，作为内部 vm 实例的 computed 属性
    * 这里传入了全局的 store 对象，
    * 因为 getter 的 3，4 参数需要依赖 store 对象（store.state，store.getters）
    */</span>
    computed<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">partial</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> store<span class="token punctuation">)</span>
    <span class="token comment">/**
    * 定义 store.getters 属性，使得能直接通过 store.getters.&lt; getter 名&gt; 访问对应的 getter
    * key 为含有命名空间的完整路径
    */</span>
    Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>store<span class="token punctuation">.</span>getters<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
      <span class="token comment">// 访问 store.getters 最终会指向 vm 实例对应的 computed 属性，同时触发计算返回结果值</span>
      <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> store<span class="token punctuation">.</span>_vm<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span>
      enumerable<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token comment">// for local getters</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>当根据 <code>key</code> 访问 <code>store.getters</code> 的某一个 getter 的时候，实际上就是访问了 <code>store._vm[key]</code>，也就是 <code>computed[key]</code>，在执行 <code>computed[key]</code> 对应的函数的时候，
会执行 <code>rawGetter(local.state,...)</code> 方法，那么就会访问到 <code>store.state</code>，进而访问到 <code>store._vm._data.$$state</code>，这样就建立了一个依赖关系。
当 <code>store.state</code> 发生变化的时候，下一次再访问 <code>store.getters</code> 的时候会重新计算。</p> <p>再来看一下<strong>严格模式</strong>都干了什么：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// enable strict mode for new vm</span>
  <span class="token comment">// 是否开启 vuex 的 strict 严格模式，目的是禁止 commit 以外的方法修改 state</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>store<span class="token punctuation">.</span>strict<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">enableStrictMode</span><span class="token punctuation">(</span>store<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  
<span class="token keyword">function</span> <span class="token function">enableStrictMode</span> <span class="token punctuation">(</span><span class="token parameter">store</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  store<span class="token punctuation">.</span>_vm<span class="token punctuation">.</span><span class="token function">$watch</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_data<span class="token punctuation">.</span>$$state <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">assert</span><span class="token punctuation">(</span>store<span class="token punctuation">.</span>_committing<span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">do not mutate vuex store state outside mutation handlers.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> deep<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> sync<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>严格模式做的事情很简单，监测 <code>store._vm.state</code> 的变化，看看 state 的变化<strong>是否通过执行 mutation 的回调函数而改变</strong>，
如果是外部直接修改 state，那么 <code>store._committing</code> 的值为 false，这样就抛出一条错误。再次强调一下，Vuex 中对 state 的修改只能在 mutation 的回调函数里。
<code>store._committing</code> 默认值是 false，那么它什么时候会 true 呢，Store 定义了 <code>_withCommit</code> 实例方法：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/* 保证通过mutation修改store的数据 */</span>
<span class="token function">_withCommit</span> <span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> committing <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_committing
    <span class="token keyword">this</span><span class="token punctuation">.</span>_committing <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_committing <span class="token operator">=</span> committing
  <span class="token punctuation">}</span>
</code></pre></div><p>对 <code>fn</code> 包装了一个环境，确保在 <code>fn</code> 中执行任何逻辑的时候 <code>this._committing = true</code>。由于我们是在修改 state，Vuex 中所有对 state 的修改都会用 <code>_withCommit</code> 函数包装，
保证在同步修改 state 的过程中 <code>this._committing</code> 的值始终为 true。这样当我们观测 state 的变化时，如果 <code>this._committing</code> 的值不为 true，则能检查到这个状态修改是有问题的。</p> <div class="custom-block danger"><p class="custom-block-title">注意</p> <p><strong>不要在发布环境下启用严格模式！</strong> 严格模式会<strong>深度监测状态树</strong>来检测不合规的状态变更——请确保<strong>在发布环境下关闭严格模式</strong>，以避免性能损失。</p></div> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  strict<span class="token operator">:</span> process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">最近更新:</span> <span class="time">11/11/2020, 9:37:26 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/vue/vuex/warmUp.html" class="prev">
        准备工作
      </a></span> <span class="next"><a href="/blog/vue/vuex/state.html">
        State 相关
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----><!----><!----></div></div>
    <script src="/blog/assets/js/app.8c0e21f4.js" defer></script><script src="/blog/assets/js/2.2a4e8c54.js" defer></script><script src="/blog/assets/js/39.13426ff2.js" defer></script><script src="/blog/assets/js/3.07d27621.js" defer></script>
  </body>
</html>
