<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>响应式原理 | 花帽子的博客</title>
    <meta name="generator" content="VuePress 1.7.1">
    <link rel="icon" href="/blog/logo.png">
    <link rel="manifest" href="/blog/manifest.json">
    <link rel="apple-touch-icon" href="/blog/images/icons/apple-icon-152x152.png">
    <meta name="description" content="我命由我不由天，学习吧少年">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
    <meta name="msapplication-TileColor" content="#000000">
    
    <link rel="preload" href="/blog/assets/css/0.styles.8f6a9f80.css" as="style"><link rel="preload" href="/blog/assets/js/app.7d7aee42.js" as="script"><link rel="preload" href="/blog/assets/js/2.55125c9d.js" as="script"><link rel="preload" href="/blog/assets/js/106.7b57d9e3.js" as="script"><link rel="preload" href="/blog/assets/js/4.f8e09ced.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.fc1225fd.js"><link rel="prefetch" href="/blog/assets/js/100.fdcffc0c.js"><link rel="prefetch" href="/blog/assets/js/101.57d65be2.js"><link rel="prefetch" href="/blog/assets/js/102.7d33b8ae.js"><link rel="prefetch" href="/blog/assets/js/103.3ef21006.js"><link rel="prefetch" href="/blog/assets/js/104.97c15ba2.js"><link rel="prefetch" href="/blog/assets/js/105.ed82fe39.js"><link rel="prefetch" href="/blog/assets/js/107.b349001b.js"><link rel="prefetch" href="/blog/assets/js/108.4183f46d.js"><link rel="prefetch" href="/blog/assets/js/109.827d517e.js"><link rel="prefetch" href="/blog/assets/js/11.5a9ad38d.js"><link rel="prefetch" href="/blog/assets/js/110.55340042.js"><link rel="prefetch" href="/blog/assets/js/111.4cbce35c.js"><link rel="prefetch" href="/blog/assets/js/112.bd8213f3.js"><link rel="prefetch" href="/blog/assets/js/113.4515ae67.js"><link rel="prefetch" href="/blog/assets/js/114.6534b9b0.js"><link rel="prefetch" href="/blog/assets/js/115.7689da95.js"><link rel="prefetch" href="/blog/assets/js/116.48f96cfb.js"><link rel="prefetch" href="/blog/assets/js/117.7e73b5f8.js"><link rel="prefetch" href="/blog/assets/js/118.f74e3c66.js"><link rel="prefetch" href="/blog/assets/js/119.69af11f6.js"><link rel="prefetch" href="/blog/assets/js/12.cb725f93.js"><link rel="prefetch" href="/blog/assets/js/13.46dfc8b8.js"><link rel="prefetch" href="/blog/assets/js/14.f7104277.js"><link rel="prefetch" href="/blog/assets/js/15.6c0eb7fe.js"><link rel="prefetch" href="/blog/assets/js/16.f7ed45f1.js"><link rel="prefetch" href="/blog/assets/js/17.4106a270.js"><link rel="prefetch" href="/blog/assets/js/18.d7588661.js"><link rel="prefetch" href="/blog/assets/js/19.09e5a998.js"><link rel="prefetch" href="/blog/assets/js/20.00504915.js"><link rel="prefetch" href="/blog/assets/js/21.22d5e68d.js"><link rel="prefetch" href="/blog/assets/js/22.6246472d.js"><link rel="prefetch" href="/blog/assets/js/23.5e5d1302.js"><link rel="prefetch" href="/blog/assets/js/24.eeecbd4f.js"><link rel="prefetch" href="/blog/assets/js/25.16782390.js"><link rel="prefetch" href="/blog/assets/js/26.add8bef2.js"><link rel="prefetch" href="/blog/assets/js/27.de5a7d2d.js"><link rel="prefetch" href="/blog/assets/js/28.f4a2e5f9.js"><link rel="prefetch" href="/blog/assets/js/29.88e45715.js"><link rel="prefetch" href="/blog/assets/js/3.6b7316b6.js"><link rel="prefetch" href="/blog/assets/js/30.29a52e77.js"><link rel="prefetch" href="/blog/assets/js/31.dd4ba9f2.js"><link rel="prefetch" href="/blog/assets/js/32.216d7b56.js"><link rel="prefetch" href="/blog/assets/js/33.46bd5fd5.js"><link rel="prefetch" href="/blog/assets/js/34.c23d48b5.js"><link rel="prefetch" href="/blog/assets/js/35.989a168e.js"><link rel="prefetch" href="/blog/assets/js/36.fabde2d6.js"><link rel="prefetch" href="/blog/assets/js/37.e3d84b18.js"><link rel="prefetch" href="/blog/assets/js/38.5d4cc67e.js"><link rel="prefetch" href="/blog/assets/js/39.26825c5c.js"><link rel="prefetch" href="/blog/assets/js/40.4d45607d.js"><link rel="prefetch" href="/blog/assets/js/41.d7ba5736.js"><link rel="prefetch" href="/blog/assets/js/42.0301c251.js"><link rel="prefetch" href="/blog/assets/js/43.79171039.js"><link rel="prefetch" href="/blog/assets/js/44.894e2581.js"><link rel="prefetch" href="/blog/assets/js/45.6fda0cdf.js"><link rel="prefetch" href="/blog/assets/js/46.273654fd.js"><link rel="prefetch" href="/blog/assets/js/47.fb251ced.js"><link rel="prefetch" href="/blog/assets/js/48.400fac13.js"><link rel="prefetch" href="/blog/assets/js/49.0c6840f5.js"><link rel="prefetch" href="/blog/assets/js/5.1850a7a0.js"><link rel="prefetch" href="/blog/assets/js/50.7bc24007.js"><link rel="prefetch" href="/blog/assets/js/51.197c3a7f.js"><link rel="prefetch" href="/blog/assets/js/52.7ef8e381.js"><link rel="prefetch" href="/blog/assets/js/53.95eb8dc5.js"><link rel="prefetch" href="/blog/assets/js/54.8e2e87ee.js"><link rel="prefetch" href="/blog/assets/js/55.2803055e.js"><link rel="prefetch" href="/blog/assets/js/56.f114a02e.js"><link rel="prefetch" href="/blog/assets/js/57.009d2844.js"><link rel="prefetch" href="/blog/assets/js/58.4ea9e214.js"><link rel="prefetch" href="/blog/assets/js/59.fe98dbf8.js"><link rel="prefetch" href="/blog/assets/js/6.6628c9dd.js"><link rel="prefetch" href="/blog/assets/js/60.27009423.js"><link rel="prefetch" href="/blog/assets/js/61.b1a03c6c.js"><link rel="prefetch" href="/blog/assets/js/62.13763602.js"><link rel="prefetch" href="/blog/assets/js/63.4d127323.js"><link rel="prefetch" href="/blog/assets/js/64.81871be4.js"><link rel="prefetch" href="/blog/assets/js/65.ce6724df.js"><link rel="prefetch" href="/blog/assets/js/66.d44d7aa1.js"><link rel="prefetch" href="/blog/assets/js/67.c8ea671d.js"><link rel="prefetch" href="/blog/assets/js/68.e83dccac.js"><link rel="prefetch" href="/blog/assets/js/69.4cec9439.js"><link rel="prefetch" href="/blog/assets/js/7.82cfa7a9.js"><link rel="prefetch" href="/blog/assets/js/70.00141353.js"><link rel="prefetch" href="/blog/assets/js/71.bc7837e8.js"><link rel="prefetch" href="/blog/assets/js/72.4217104a.js"><link rel="prefetch" href="/blog/assets/js/73.d121837a.js"><link rel="prefetch" href="/blog/assets/js/74.7f8f4479.js"><link rel="prefetch" href="/blog/assets/js/75.9730baa2.js"><link rel="prefetch" href="/blog/assets/js/76.5decf315.js"><link rel="prefetch" href="/blog/assets/js/77.62becd74.js"><link rel="prefetch" href="/blog/assets/js/78.07604af2.js"><link rel="prefetch" href="/blog/assets/js/79.a64f7774.js"><link rel="prefetch" href="/blog/assets/js/8.441834aa.js"><link rel="prefetch" href="/blog/assets/js/80.43c048c6.js"><link rel="prefetch" href="/blog/assets/js/81.1d28503e.js"><link rel="prefetch" href="/blog/assets/js/82.8f22f620.js"><link rel="prefetch" href="/blog/assets/js/83.6d4d2943.js"><link rel="prefetch" href="/blog/assets/js/84.d00ff1d4.js"><link rel="prefetch" href="/blog/assets/js/85.a67613a9.js"><link rel="prefetch" href="/blog/assets/js/86.7578624f.js"><link rel="prefetch" href="/blog/assets/js/87.d6cef9c2.js"><link rel="prefetch" href="/blog/assets/js/88.088aaf17.js"><link rel="prefetch" href="/blog/assets/js/89.9bf650b0.js"><link rel="prefetch" href="/blog/assets/js/9.a921bf18.js"><link rel="prefetch" href="/blog/assets/js/90.d0aba2ec.js"><link rel="prefetch" href="/blog/assets/js/91.5d0aa9ce.js"><link rel="prefetch" href="/blog/assets/js/92.35a9f5ef.js"><link rel="prefetch" href="/blog/assets/js/93.d0dda25f.js"><link rel="prefetch" href="/blog/assets/js/94.4843c0c5.js"><link rel="prefetch" href="/blog/assets/js/95.559aeaf5.js"><link rel="prefetch" href="/blog/assets/js/96.98796f83.js"><link rel="prefetch" href="/blog/assets/js/97.57508df4.js"><link rel="prefetch" href="/blog/assets/js/98.6f3d5c54.js"><link rel="prefetch" href="/blog/assets/js/99.1de7c612.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.8f6a9f80.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/logo.png" alt="花帽子的博客" class="logo"> <span class="site-name can-hide">花帽子的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/blog/vue/" class="nav-link router-link-active">
  Vue
</a></div><div class="nav-item"><a href="/blog/css/" class="nav-link">
  CSS
</a></div><div class="nav-item"><a href="/blog/javascript/" class="nav-link">
  JS
</a></div><div class="nav-item"><a href="/blog/typescript/" class="nav-link">
  TS
</a></div><div class="nav-item"><a href="/blog/node/" class="nav-link">
  Node
</a></div><div class="nav-item"><a href="/blog/optimization/" class="nav-link">
  优化
</a></div><div class="nav-item"><a href="/blog/mobile/" class="nav-link">
  移动端
</a></div><div class="nav-item"><a href="/blog/talk/" class="nav-link">
  其他
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="GitHub" class="dropdown-title"><span class="title">GitHub</span> <span class="arrow down"></span></button> <button type="button" aria-label="GitHub" class="mobile-dropdown-title"><span class="title">GitHub</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/jonny-wei" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub地址
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/blog/vue/" class="nav-link router-link-active">
  Vue
</a></div><div class="nav-item"><a href="/blog/css/" class="nav-link">
  CSS
</a></div><div class="nav-item"><a href="/blog/javascript/" class="nav-link">
  JS
</a></div><div class="nav-item"><a href="/blog/typescript/" class="nav-link">
  TS
</a></div><div class="nav-item"><a href="/blog/node/" class="nav-link">
  Node
</a></div><div class="nav-item"><a href="/blog/optimization/" class="nav-link">
  优化
</a></div><div class="nav-item"><a href="/blog/mobile/" class="nav-link">
  移动端
</a></div><div class="nav-item"><a href="/blog/talk/" class="nav-link">
  其他
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="GitHub" class="dropdown-title"><span class="title">GitHub</span> <span class="arrow down"></span></button> <button type="button" aria-label="GitHub" class="mobile-dropdown-title"><span class="title">GitHub</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/jonny-wei" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub地址
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Vue秘籍</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/vue/" aria-current="page" class="sidebar-link">Vue 的秘籍</a></li><li><a href="/blog/vue/interview/vue-communication.html" class="sidebar-link">Vue 组件通信</a></li><li><a href="/blog/vue/interview/vue-symbols.html" class="sidebar-link">Vue 修饰符</a></li><li><a href="/blog/vue/interview/vue-test.html" class="sidebar-link">Vue 单元测试</a></li><li><a href="/blog/vue/interview/vue-router.html" class="sidebar-link">Vue 路由原理</a></li><li><a href="/blog/vue/interview/vue-vuex.html" class="sidebar-link">Vuex 实现原理</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Vue源码解析</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/vue/vue/github.html" class="sidebar-link">源码学习</a></li><li><a href="/blog/vue/vue/vue-render.html" class="sidebar-link">渲染器</a></li><li><a href="/blog/vue/vue/vue-init.html" class="sidebar-link">构建与初始化</a></li><li><a href="/blog/vue/vue/vue-observer.html" aria-current="page" class="active sidebar-link">响应式原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/vue/vue/vue-observer.html#如何侦测数据的变化" class="sidebar-link">如何侦测数据的变化</a></li><li class="sidebar-sub-header"><a href="/blog/vue/vue/vue-observer.html#依赖收集与更新" class="sidebar-link">依赖收集与更新</a></li><li class="sidebar-sub-header"><a href="/blog/vue/vue/vue-observer.html#总结" class="sidebar-link">总结</a></li><li class="sidebar-sub-header"><a href="/blog/vue/vue/vue-observer.html#问题" class="sidebar-link">问题</a></li></ul></li><li><a href="/blog/vue/vue/vue-template.html" class="sidebar-link">模板编译与渲染</a></li><li><a href="/blog/vue/vue/vue-diff.html" class="sidebar-link">虚拟 DOM 与 Diff 算法</a></li><li><a href="/blog/vue/vue/vue-nextTick.html" class="sidebar-link">异步更新队列</a></li><li><a href="/blog/vue/vue/vue-lifecycle.html" class="sidebar-link">生命周期</a></li><li><a href="/blog/vue/vue/vue-computed.html" class="sidebar-link">计算属性与侦听器</a></li><li><a href="/blog/vue/vue/vue-slot.html" class="sidebar-link">插槽</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>VueRouter源码解析</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/vue/vue-router/abstract.html" class="sidebar-link">摘要</a></li><li><a href="/blog/vue/vue-router/warmUp.html" class="sidebar-link">准备工作</a></li><li><a href="/blog/vue/vue-router/plugin.html" class="sidebar-link">插件机制</a></li><li><a href="/blog/vue/vue-router/initialization.html" class="sidebar-link">初始化与降级处理</a></li><li><a href="/blog/vue/vue-router/transitions.html" class="sidebar-link">路由过渡与视图渲染</a></li><li><a href="/blog/vue/vue-router/match.html" class="sidebar-link">路由匹配</a></li><li><a href="/blog/vue/vue-router/scroll.html" class="sidebar-link">滚动行为处理</a></li><li><a href="/blog/vue/vue-router/summary.html" class="sidebar-link">总结</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Vuex源码解析</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/vue/vuex/abstract.html" class="sidebar-link">摘要</a></li><li><a href="/blog/vue/vuex/warmUp.html" class="sidebar-link">准备工作</a></li><li><a href="/blog/vue/vuex/initialization.html" class="sidebar-link">初始化与模块安装</a></li><li><a href="/blog/vue/vuex/state.html" class="sidebar-link">State 相关</a></li><li><a href="/blog/vue/vuex/getters.html" class="sidebar-link">Getters 相关</a></li><li><a href="/blog/vue/vuex/mutations.html" class="sidebar-link">Mutations 相关</a></li><li><a href="/blog/vue/vuex/actions.html" class="sidebar-link">Actions 相关</a></li><li><a href="/blog/vue/vuex/modules.html" class="sidebar-link">Modules 相关</a></li><li><a href="/blog/vue/vuex/others.html" class="sidebar-link">其他</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Vue3新特性</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/vue/vue3.x/abstract.html" class="sidebar-link">摘要</a></li><li><a href="/blog/vue/vue3.x/reactivity.html" class="sidebar-link">响应式系统</a></li><li><a href="/blog/vue/vue3.x/features.html" class="sidebar-link">功能方面</a></li><li><a href="/blog/vue/vue3.x/performance.html" class="sidebar-link">性能方面</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="响应式原理"><a href="#响应式原理" class="header-anchor">#</a> 响应式原理</h1> <p>响应式原理</p> <p>数据驱动是数据(状态)的变化引起视图的变化；数据双向绑定(响应式)是数据的变化引起视图的变化，视图的变化引起数据的变化。公式表示：</p> <p><code>UI = render(state)</code>。</p> <p>那么如何实现数据驱动呢？如何实现数据双向绑定呢？如何实现一个响应式系统呢？<strong>Vue 实现的响应式系统设计思路如下</strong>：</p> <ul><li>侦测数据的变化(数据劫持/数据代理)</li> <li>收集视图依赖了哪些数据(依赖收集)</li> <li>数据变化时，自动通知更新视图(发布订阅模式)</li></ul> <p><strong>基于以上思想 Vue2 的响应式系统实现步骤如下</strong>：</p> <ul><li>实现一个监听器 Observer，用来劫持并监听所有属性，如果属性发生变化，就通知订阅者(Watcher)；</li> <li>实现一个订阅器 Dep，用来收集订阅者，对监听器 Observer 和 订阅者 Watcher 进行统一管理；</li> <li>实现一个订阅者 Watcher，可以收到属性的变化通知并执行相应的方法，从而更新视图；</li> <li>实现一个解析器 Compile，可以解析每个节点的相关指令，对模板数据和订阅器进行初始化。</li></ul> <p><img src="/blog/images/vue/vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%861.png" alt="vue响应式原理1"></p> <h2 id="如何侦测数据的变化"><a href="#如何侦测数据的变化" class="header-anchor">#</a> 如何侦测数据的变化</h2> <p>实现侦测数据的变化，使数据变得“可观测”，JavaScript 有两种办法：</p> <ul><li>使用 Object.defineProperty 数据劫持(vue2)</li> <li>ES6 的 Proxy 数据代理(vue3)</li></ul> <p>在 Vue2 中，基于 Object.defineProperty 对象属性级别的拦截，为每个属性设置 getter/setter。由于局限于 Object.defineProperty 是对象原型上的方法，并且是对象属性层面上的数据劫持，不是对象层面的数据代理。所以 Vue2 侦测数据的变化分为 Object 型的数据和 Array 型数据两种不同的侦测方式。</p> <h3 id="使-object-类型的数据可观测"><a href="#使-object-类型的数据可观测" class="header-anchor">#</a> 使 Object 类型的数据可观测</h3> <p>定义一个 Observer 观察类(监听器)，判断数据是否是 Array 类型，如果不是那么就是 Object 类型数据，进而走 <code>this.walk(value)</code> 逻辑。在 walk 方法中
遍历对象的所有属性走 <code>defineReactive(obj, keys[i])</code> 方法，在 defineReactive 方法中通过 <code>Object.defineProperty</code> 为其添加 getter/setter，在 defineReactive 中如果 obj 对象里嵌套对象，那么需要通过 <code>new Observer(val)</code> <strong>递归</strong>添加响应式，这就是 Object 的<strong>深度侦测</strong>。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 源码位置：src/core/observer/index.js 下面是简化后的代码</span>

<span class="token comment">// Observer类 会通过递归的方式把一个对象的所有属性都转化成可观测对象</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 拿到需要做成响应式的数据(状态)  </span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value
    <span class="token comment">// 新增一个__ob__属性，标记此 value 已经变为响应式了，避免重复操作，值为该 value 的 Observers 实例</span>
    <span class="token function">def</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span><span class="token string">'__ob__'</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">)</span> 
    <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// value 为 Array 型的侦测逻辑</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// value 为 Object 型的侦测逻辑</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">walk</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 观测 Object：遍历对象的所有属性为其添加get/set</span>
  <span class="token function">walk</span> <span class="token punctuation">(</span><span class="token parameter">obj<span class="token operator">:</span> Object</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> keys <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
    <span class="token comment">// for循环的特点： 不可遍历自定义或原型链上的自定义属性</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> keys<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">defineReactive</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">/**
 * 为对象的属性定义响应式，使一个对象转化成可观测对象
 * @param { Object } obj 对象
 * @param { String } key 对象的key
 * @param { Any } val 对象的某个key的值
 * 通过 Object.defineProperty 方法实现了对 Object 数据的可观测，
 * 但是这个方法仅仅只能观测到 Object 数据的取值getter及设置值setter，
 * 当我们向 Object 数据里添加一对新的 key/value 或删除一对已有的 key/value 时，它是无法观测到的，
 * 导致当我们对 Object 数据添加或删除值时，无法通知依赖，无法驱动视图进行响应式更新。
 * 
 * Vue也注意到了这一点，为了解决这一问题，Vue 增加了两个全局API: Vue.set(vm.$set) 和 Vue.delete(vm.$delete)
 */</span>
<span class="token keyword">function</span> <span class="token function">defineReactive</span> <span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span>key<span class="token punctuation">,</span>val</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 如果是不可配置属性，则搞不了响应式，直接结束程序</span>
  <span class="token keyword">const</span> property <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>property <span class="token operator">&amp;&amp;</span> property<span class="token punctuation">.</span>configurable <span class="token operator">===</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 参数处理，只传了obj和key，那么val = obj[key]</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>arguments<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    val <span class="token operator">=</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// obj对象里嵌套对象，递归添加响应式，Object的深度侦测 </span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> val <span class="token operator">===</span> <span class="token string">&quot;object&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">new</span> <span class="token class-name">Observer</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    enumerable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    configurable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">属性被读取了</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> val<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">set</span><span class="token punctuation">(</span>newVal<span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>val <span class="token operator">===</span> newVal<span class="token punctuation">)</span><span class="token punctuation">{</span>
          <span class="token keyword">return</span>
      <span class="token punctuation">}</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">属性被修改了</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      val <span class="token operator">=</span> newVal<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br></div></div><h3 id="使-array-类型的数据可观测"><a href="#使-array-类型的数据可观测" class="header-anchor">#</a> 使 Array 类型的数据可观测</h3> <p>Object 变化时通过 setter 来追踪的，只有某个数据发生了变化，就一定会触发这个数据上的 setter。但是 Array 型数据没有 setter。要想让 Array 型数据发生变化，那必然是操作了 Array，而 JS 中提供的操作数组的方法就那么几种，我们可以把这些方法都重写一遍。</p> <p>为 Array.prototype 添加属性，重写 7 大方法。首先创建了继承自 Array 原型的空对象 arrayMethods，接着在 arrayMethods 上使用 object.defineProperty 方法将这些可以改变数组自身的 7 个方法遍历，逐个进行封装重写。</p> <ul><li>push</li> <li>pop</li> <li>shift</li> <li>unshift</li> <li>splice</li> <li>sort</li> <li>reverse</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> arrayProto <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype <span class="token comment">// 继承原型对象</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> arrayMethods <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>arrayProto<span class="token punctuation">)</span> <span class="token comment">// 建一个自己的原型 并且重写methods这些方法</span>

<span class="token keyword">const</span> methodsToPatch <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token string">'push'</span><span class="token punctuation">,</span>
  <span class="token string">'pop'</span><span class="token punctuation">,</span>
  <span class="token string">'shift'</span><span class="token punctuation">,</span>
  <span class="token string">'unshift'</span><span class="token punctuation">,</span>
  <span class="token string">'splice'</span><span class="token punctuation">,</span>
  <span class="token string">'sort'</span><span class="token punctuation">,</span>
  <span class="token string">'reverse'</span>
<span class="token punctuation">]</span>

<span class="token comment">/**
 * Intercept mutating methods and emit events
 */</span>
methodsToPatch<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">method</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// cache original method 缓存原生方法</span>
  <span class="token keyword">const</span> original <span class="token operator">=</span> arrayProto<span class="token punctuation">[</span>method<span class="token punctuation">]</span>
  <span class="token function">def</span><span class="token punctuation">(</span>arrayMethods<span class="token punctuation">,</span> method<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token function">mutator</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 改变this指向 拦截</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">original</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span>
    <span class="token comment">// 获取Observer实例</span>
    <span class="token keyword">const</span> ob <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>__ob__
    <span class="token comment">// 改变数组的元素,待添加响应式的元素</span>
    <span class="token keyword">let</span> inserted
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>method<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">case</span> <span class="token string">'push'</span><span class="token operator">:</span>
      <span class="token keyword">case</span> <span class="token string">'unshift'</span><span class="token operator">:</span>
        inserted <span class="token operator">=</span> args
        <span class="token keyword">break</span>
      <span class="token keyword">case</span> <span class="token string">'splice'</span><span class="token operator">:</span>
        inserted <span class="token operator">=</span> args<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
        <span class="token keyword">break</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 调用 Observer 类的 observeArray 方法，遍历数组中每一项(inserted)为其添加响应式 </span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>inserted<span class="token punctuation">)</span> ob<span class="token punctuation">.</span><span class="token function">observeArray</span><span class="token punctuation">(</span>inserted<span class="token punctuation">)</span> <span class="token comment">// Array 的深度侦测</span>
    <span class="token comment">// notify change</span>
    ob<span class="token punctuation">.</span>dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> result
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br></div></div><p>Array 类型数据的侦测：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 源码位置：src/core/observer/index.js 下面是简化后的代码</span>

<span class="token comment">// Observer类 会通过递归的方式把一个对象的所有属性都转化成可观测对象</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 拿到需要做成响应式的数据(状态)  </span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value
    <span class="token comment">// 新增一个__ob__属性，标记此 value 已经变为响应式了，避免重复操作，值为该 value 的 Observers 实例</span>
    <span class="token function">def</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span><span class="token string">'__ob__'</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">)</span> 
    <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// value 为 Array 型的侦测逻辑</span>
      <span class="token comment">// 当前环境下的Object是否支持__proto__(隐式原型)属性</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>hasProto<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">protoAugment</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> arrayMethods<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token function">copyAugment</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> arrayMethods<span class="token punctuation">,</span> arrayKeys<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">observeArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// value 为 Object 型的侦测逻辑</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 观测 Array：遍历对象的所有属性为其添加get/set</span>
  <span class="token function">observeArray</span><span class="token punctuation">(</span><span class="token parameter">items<span class="token operator">:</span> Array<span class="token operator">&lt;</span>any<span class="token operator">&gt;</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> item <span class="token keyword">of</span> items<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">new</span> <span class="token class-name">Observer</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token comment">// 实际源码调用 observe Array 的深度侦测</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * 如果支持__proto__访问prototype原型对象，则拦截
 * 将源对象的 __proto__ 指向目标对象 value.__proto__ = arrayMethods
 * @param target
 * @param src
 */</span>
<span class="token keyword">function</span> <span class="token function">protoAugment</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token operator">:</span> Array<span class="token operator">&lt;</span>any<span class="token operator">&gt;</span><span class="token punctuation">,</span> src<span class="token operator">:</span> Object</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
  target<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> src<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * 如果不支持__proto__访问prototype原型对象，则把拦截器中重写的7个方法循环加入到value上
 * @param target
 * @param src
 * @param keys
 */</span>
<span class="token keyword">function</span> <span class="token function">copyAugment</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token operator">:</span> Object<span class="token punctuation">,</span> src<span class="token operator">:</span> Object<span class="token punctuation">,</span> keys<span class="token operator">:</span> Array<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span></span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">of</span> keys<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">def</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> src<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br></div></div><div class="custom-block tip"><p class="custom-block-title">补充</p> <p>从 2.6 起，v-for 也可以在实现了可迭代协议的值上使用，包括原生的 Map 和 Set。不过应该注意的是 Vue 2.x 目前并不支持可响应的 Map 和 Set 值，所以无法自动探测变更。v-for 的优先级比 v-if 更高。</p></div> <h3 id="小结"><a href="#小结" class="header-anchor">#</a> 小结</h3> <p><strong>数据侦测的目的是</strong>监测数据何时发生了变化，从而收集或更新依赖。为侦测数据的变化，使数据变得“可观测”，JavaScript 有两种办法：<code>使用 Object.defineProperty 数据劫持(vue2)</code> 和 <code>ES6 的 Proxy 数据代理(vue3)</code>。在 Vue2 中，是基于 <code>Object.defineProperty</code> 实现数据劫持。由于局限于 Object.defineProperty 是对象原型上的方法，并且是对象属性层面上的数据劫持，不是对象层面的数据代理。所以 Vue2 侦测数据的变化分为 Object 型的数据和 Array 型数据两种不同的侦测方式。对于 Object 类型的数据，<strong>Vue 在 defineReactive 方法中通过 <code>Object.defineProperty</code> 为其添加 getter/setter 追踪数据的变化，监测数据何时发生了变化</strong>；对于 Array 类型的数据，<strong>Vue 通过拦截重写数组原型上可以改变数组的 7 大操作数组方法监测数据何时发生了变化</strong>。以上实现了数据的侦测，知道数据何时发生了变化，从而知道在什么时候收集依赖，在什么时候更新依赖。</p> <h2 id="依赖收集与更新"><a href="#依赖收集与更新" class="header-anchor">#</a> 依赖收集与更新</h2> <p><strong>为什么进行依赖收集</strong>：数据变的可观测以后，我们就能知道数据什么时候发生了变化，那么当数据发生变化时，我们去通知视图更新就好了。那么问题又来了，视图那么大，我们到底该通知谁去变化？总不能一个数据变化了，把整个视图全部更新一遍吧，这样显然是不合理的。</p> <p><strong>什么是依赖收集</strong>：谁用到了这个数据就是谁依赖了这个数据，我们给每个数据都建一个依赖数组(因为一个数据可能被多处使用)，谁依赖了这个数据(即谁用到了这个数据)我们就把谁放入这个依赖数组中，那么当这个数据发生变化的时候，我们就去它对应的依赖数组中，把每个依赖都通知一遍，告诉他们：&quot;你们依赖的数据变啦，你们该更新啦！&quot;。这个过程就是依赖收集。</p> <p><strong>何时收集依赖，何时更新依赖</strong>：在 getter 中收集依赖，在 setter 中通知依赖更新。在 getter 中调用了 <code>dep.depend()</code> 方法收集依赖，在 setter 中调用 <code>dep.notify()</code> 方法通知所有依赖更新。</p> <p><strong>Array 的依赖收集疑问</strong>：不是说 Array 无法使用 Object.defineProperty 方法吗？无法使用怎么还在 getter 中收集依赖呢？其实在平常开发的时候，全局的 data 是一个对象，组件的 data 是一个函数并 return 一个对象，不论是全局还是组件中的 data 都是通过 <code>{}</code> 包裹需要响应式的数据，所以 Array 型数据还是在getter 中收集依赖。</p> <p><strong>依赖收集到哪里</strong>：收集依赖需要为依赖找一个存储依赖的地方，我们给每个数据都建一个依赖数组，谁依赖了这个数据我们就把谁放入这个依赖数组中。单单用一个数组来存放依赖的话，功能好像有点欠缺并且代码过于耦合。我们应该将依赖数组的功能扩展一下，更好的做法是我们应该为每一个数据都建立一个依赖管理器，把这个数据所有的依赖都管理起来。为此 Vue 定义了一个订阅器 Dep，用来收集订阅者，主要作用是用来存放 Watcher 观察者对象。它用来收集依赖、删除依赖和向依赖发送消息等。Watcher 可以理解成一个中介，数据发生变化时通知 Watcher，然后 Watcher 再通知其他地方。</p> <h3 id="发布者-dep"><a href="#发布者-dep" class="header-anchor">#</a> 发布者 Dep</h3> <p>如何管理依赖？Dep 订阅器类。主要做两件事情：</p> <ul><li>用 addSub 方法可以在目前的 Dep 对象中增加一个 Watcher 的订阅操作；</li> <li>用 notify 方法通知目前 Dep 对象的 subs 中的所有 Watcher 对象触发更新操作。</li></ul> <p>其实 Dep 就是一个发布者(被观察者)，可以订阅多个观察者，依赖收集之后 Deps 中会存在一个或多个 Watcher 对象，在数据变更的时候通知所有的 Watcher。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">Dep</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> target<span class="token operator">:</span> <span class="token operator">?</span>Watcher<span class="token punctuation">;</span> <span class="token comment">// 取 Watcher 存放的依赖者</span>
  id<span class="token operator">:</span> number<span class="token punctuation">;</span>
  subs<span class="token operator">:</span> Array<span class="token operator">&lt;</span>Watcher<span class="token operator">&gt;</span><span class="token punctuation">;</span>

  <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> uid<span class="token operator">++</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>subs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment">// 存放依赖(Watcher订阅) 添加 删除 通知</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 添加依赖</span>
  <span class="token function">addSub</span> <span class="token punctuation">(</span><span class="token parameter">sub<span class="token operator">:</span> Watcher</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 删除依赖</span>
  <span class="token function">removeSub</span> <span class="token punctuation">(</span><span class="token parameter">sub<span class="token operator">:</span> Watcher</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">,</span> sub<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 添加一个依赖 调用 Watcher 中的 addDep ,addDep中调用上面的 addSub</span>
  <span class="token function">depend</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      Dep<span class="token punctuation">.</span>target<span class="token punctuation">.</span><span class="token function">addDep</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">//通知依赖更新</span>
  <span class="token function">notify</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// stabilize the subscriber list first 不改变原数组，浅拷贝</span>
    <span class="token keyword">const</span> subs <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>config<span class="token punctuation">.</span>async<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// subs aren't sorted in scheduler if not running async</span>
      <span class="token comment">// we need to sort them now to make sure they fire in correct</span>
      <span class="token comment">// order</span>
      subs<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> a<span class="token punctuation">.</span>id <span class="token operator">-</span> b<span class="token punctuation">.</span>id<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 遍历Watcher订阅者(subs依赖者实例数组)</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> subs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      subs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// Watcher 实例上的依赖 watcher.update()</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br></div></div><p>之前对 Object 和 Array 数据分别进行了观测，利用 <code>Object.defineProperty</code> 为其属性和元素添加响应式机制，使数据变得可观测。知道了数据何时发生了变化以及何时通知依赖更新，明白在 getter 中触发依赖收集，在 setter 中触发依赖更新。为了使代码解耦，提供接口等因素用一个 Dep类(依赖管理订阅器)代替依赖数组管理依赖。在依赖管理器中添加依赖，删除依赖，以及通知依赖更新，核心方法就是 <code>update()</code>。剩下的问题就是：我们在 getter 中收集的依赖到底是谁的问题。口语层面我们可以说：“谁用到了这个数据谁就是依赖”，那么在代码层面该如何表示呢？</p> <h3 id="订阅者-watcher"><a href="#订阅者-watcher" class="header-anchor">#</a> 订阅者 Watcher</h3> <p>Vue 实现了一个 Watcher 类(观察者)，Watcher 类的实例就是我们上面所说的那个&quot;谁&quot;。换句话说就是：谁用到了数据，谁就是依赖，我们就为谁创建一个 Watcher 实例。在之后数据变化时，我们不直接去通知依赖更新，而是通知依赖对应的 Watcher 实例，由 Watcher 实例去通知真正的视图。</p> <p><strong>为什么要引入 Watcher 类</strong>：当属性发生变化后，我们要通知用到数据的地方，而使用这个数据的地方有很多，而且类型还不一样，既有可能是模板，也有可能是用户写的一个 watch,这时需要抽象出一个能集中处理这些情况的类。然后，我们在依赖收集阶段 <strong>只收集这个封装好的类的实例进来</strong>，通知也只通知它一个，再由它负责通知其他地方。</p> <p><strong>依赖收集的目的</strong> 是将观察者 Watcher 对象存放到当前闭包中的订阅者 Dep 的 subs 中。</p> <p>所谓的依赖，其实就是 Watcher。至于如何收集依赖，总结起来就一句话，在 getter 中收集依赖，在 setter 中触发依赖。先收集依赖，即把用到该数据的地方收集起来，然后等属性发生变化时，把之前收集好的依赖循环触发一遍就行了。具体来说，当外界通过 Watcher 读取数据时，便会触发 getter 从而将 Watcher 添加到依赖中，哪个 Watcher 触发了 getter，就把哪个 Watcher 收集到 Dep 中。当数据发生变化时，会循环依赖列表，把所有的 Watcher 都通知一遍。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// Watcher 简化：</span>
<span class="token function">mountComponent</span><span class="token punctuation">(</span><span class="token parameter">vm<span class="token operator">:</span> Component<span class="token punctuation">,</span> el<span class="token operator">:</span> <span class="token operator">?</span>Element<span class="token punctuation">,</span> <span class="token operator">...</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    vm<span class="token punctuation">.</span>$el <span class="token operator">=</span> el

    <span class="token operator">...</span>

    <span class="token function-variable function">updateComponent</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      vm<span class="token punctuation">.</span><span class="token function">_update</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span><span class="token function">_render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">new</span> <span class="token class-name">Watcher</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> updateComponent<span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">)</span>
    <span class="token operator">...</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">Watcher</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token parameter">vm<span class="token punctuation">,</span>expOrFn<span class="token punctuation">,</span>cb</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>vm <span class="token operator">=</span> vm<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>cb <span class="token operator">=</span> cb<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>getter <span class="token operator">=</span> <span class="token function">parsePath</span><span class="token punctuation">(</span>expOrFn<span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token function">get</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    window<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token comment">// 将 Dep.target 指向自身，从而使得收集到了对应的 Watcher</span>
    <span class="token keyword">const</span> vm <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>vm
    <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getter</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> vm<span class="token punctuation">)</span>
    window<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> value
  <span class="token punctuation">}</span>
  <span class="token function">update</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> oldValue <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value
    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">cb</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>vm<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br></div></div><p>Watcher 先把自己设置到全局唯一的指定位置（window.target），然后读取数据。因为读取了数据，所以会触发这个数据的 getter。接着，在 getter 中就会从全局唯一的那个位置读取当前正在读取数据的 Watcher，并把这个 Watcher 收集到 Dep 中去。收集好之后，当数据发生变化时，会向 Dep 中的每个 Watcher 发送通知。通过这样的方式，Watcher 可以主动去订阅任意一个数据的变化。</p> <p>Dep.target 表示当前正在计算的 Watcher，它是全局唯一的，因为在同一时间只能有一个 Watcher 被计算。</p> <p><img src="/blog/images/vue/vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%862.png" alt="vue响应式原理2"></p> <h3 id="小结-2"><a href="#小结-2" class="header-anchor">#</a> 小结</h3> <ul><li>在 new Vue() 后， Vue 会调用 _init 函数进行初始化，在 init 过程 data 通过 Observer 转换成了 getter/setter 的形式，来对数据追踪变化，当被设置的对象被读取的时候会执行 getter 函数，而在当被赋值的时候会执行 setter 函数。</li> <li>当render function 执行的时候，因为会读取所需对象的值，所以会触发 getter 函数从而将 Watcher 添加到依赖中进行依赖收集。</li> <li>在修改对象的值的时候，会触发对应的 setter， setter 通知之前依赖收集得到的 Dep 中的每一个 Watcher，告诉它们自己的值改变了，需要重新渲染视图。这时候这些 Watcher 就会开始调用 update 来更新视图。</li></ul> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p><strong>数据侦测的目的是</strong>监测数据何时发生了变化，从而收集或更新依赖。为侦测数据的变化，使数据变得“可观测”，JavaScript 有两种办法：<code>使用 Object.defineProperty 数据劫持(vue2)</code> 和 <code>ES6 的 Proxy 数据代理(vue3)</code>。在 Vue2 中，是基于 <code>Object.defineProperty</code> 实现数据劫持。由于局限于 Object.defineProperty 是对象原型上的方法，并且是对象属性层面上的数据劫持，不是对象层面的数据代理。所以 Vue2 侦测数据的变化分为 Object 型的数据和 Array 型数据两种不同的侦测方式。对于 Object 类型的数据，<strong>Vue 在 defineReactive 方法中通过 <code>Object.defineProperty</code> 为其添加 getter/setter 追踪数据的变化，监测数据何时发生了变化</strong>；对于 Array 类型的数据，<strong>Vue 通过拦截重写数组原型上可以改变数组的 7 大操作数组方法监测数据何时发生了变化</strong>。以上实现了数据的侦测，知道数据何时发生了变化，从而知道在什么时候收集依赖，在什么时候更新依赖。在 getter 中收集依赖，在 setter 中通知依赖更新。</p> <p>那么这些依赖存放在哪里呢？为了使代码解耦，提供接口等因素用Vue 定义了一个依赖管理器 Dep 类(发布者，被观察者)代替依赖数组管理依赖。在依赖管理器中添加依赖，删除依赖，以及通知依赖更新。剩下的问题就是：我们在 getter 中收集的依赖到底是谁的问题。谁用到了这个数据谁就是依赖。当属性发生变化后，我们要通知用到数据的地方，而使用这个数据的地方有很多，而且类型还不一样，既有可能是模板，也有可能是用户写的一个 watch（computed watcher，user watcher实例），这时需要抽象出一个能集中处理这些情况的类。然后，我们在依赖收集阶段 <strong>只收集这个封装好的类的实例进来</strong>，通知也只通知它一个，再由它负责通知其他地方。</p> <p>为此 Vue 又定义了一个 Watcher 类(订阅者，观察者)。所谓的依赖，其实就是 Watcher 实例。当外界通过 Watcher 读取数据时，便会触发 getter 从而将 Watcher 添加到依赖中，哪个 Watcher 触发了 getter，就把哪个 Watcher 收集到 Dep 中。当数据发生变化时，会循环依赖列表，把所有的 Watcher 都通知一遍。依赖管理器 Dep 主要用来收集订阅者，主要作用是用来存放 Watcher 观察者对象。它用来收集依赖、删除依赖和向依赖发送消息等。在 mount 阶段的时候，会创建一个 Watcher 类的对象。这个 Watcher 实际上是连接 Vue 组件与 Dep 的桥梁。每一个 Watcher 对应一个 vue component。</p> <p>总之，当创建 Vue 实例时，Vue 会遍历 data 选项的属性，利用 <code>Object.defineProperty</code> 为每个属性添加 getter 和 setter 对数据的读取进行劫持（在 getter 中收集依赖，在 setter 中通知依赖更新），并且在内部追踪依赖，在属性被访问和修改时通知变化。每个组件实例会有相应的 Watcher 实例，会在组件渲染的过程中记录依赖的所有数据属性（进行依赖收集，还有computed watcher，user watcher实例），之后依赖项被改动时，setter 方法会通知依赖与此 data 的 Watcher 实例重新计算（派发更新），从而使它关联的组件重新渲染。</p> <ul><li>组件初始化的时候，先给每一个 data 属性都注册 getter，setter，也就是 reactive 化。然后再 new 一个自己的 Watcher 对象，此时 Watcher 会立即调用组件的 render 函数去生成虚拟 DOM。在调用 render 的时候，就会需要用到 data 的属性值，此时会触发 getter 函数，将当前的 Watcher 函数注册进 Dep 的 subs 里。</li> <li>当 data 属性发生改变之后，就会遍历 subs 里所有的 Watcher 对象，通知它们去重新渲染组件。</li></ul> <p>Vue 是如何给 data 对象添加 Observer 的？我们知道，Vue 实例创建的过程会有一个生命周期，其中有一个过程就是调用 vm.initData 方法处理 data 选项。在 initData 中我们要特别注意 proxy 方法，它的功能就是遍历 data 的 key，把 data 上的属性代理到 vm 实例上。proxy 方法主要通过 Object.defineProperty 的 getter 和 setter 方法实现了代理，把每一个值 vm._data.xxx 都代理到 vm.xxx 上。在 _initData 方法的最后，我们调用了 observe(data, this) 方法来对 data 做监听。observe 方法首先判断 value 是否已经添加了 ob 属性，它是一个 Observer 对象的实例。如果是就直接用，否则在 value 满足一些条件（数组或对象、可扩展、非 vue 组件等）的情况下创建一个 Observer 对象。defineReactive 方法最核心的部分就是通过调用 Object.defineProperty 给 data 的每个属性添加 getter 和 setter 方法。当 data 的某个属性被访问时，则会调用 getter 方法，判断当 Dep.target 不为空时调用 dep.depend 和 childObj.dep.depend 方法做依赖收集。如果访问的属性是一个数组，则会遍历这个数组收集数组元素的依赖。当改变 data 的属性时，则会调用 setter 方法，这时调用 dep.notify 方法进行通知。Dep 类中 subs 用来存储所有订阅它的 Watcher。至此，vm 实例中给 data 对象添加 Observer 的过程就结束了。</p> <p>在给 data 添加 Observer 之后，有一个过程是调用 vm.compile 方法对模板进行编译。compile 方法主要通过 compileNode(el, options) 方法完成节点的解析，如果节点拥有子节点，则调用 compileNodeList(el.childNodes, options) 方法完成子节点的解析。compileNodeList 方法其实就是遍历子节点，递归调用 compileNode 方法。因为 DOM 元素本身就是树结构，这种递归方法也就是常见的树的深度遍历方法，这样就可以完成整个 DOM 树节点的解析。主要通过正则表达式解析模板语法(插值表达式，指令等等)生成 Directive 对象。Directive 在初始化时定义了 this.update 方法，并创建了 Watcher，把 this.update 方法作为 Watcher 的回调函数。这里就把 Directive 和 Watcher 做了关联，当 Watcher 观察到指令表达式值变化时，会调用 Directive 实例的 _update 方法，最终调用 watcher 的 update 方法更新 DOM 节点。至此，vm 实例中编译模板、解析指令、绑定 Watcher 的过程就结束了</p> <p>Watcher 巧妙地把 Observer 和 Directive 关联起来，实现了数据一旦更新，视图就会自动变化的效果。</p> <h2 id="问题"><a href="#问题" class="header-anchor">#</a> 问题</h2> <h3 id="q1-为什么-object-和-array-型数据会有两种不同的变化侦测方式"><a href="#q1-为什么-object-和-array-型数据会有两种不同的变化侦测方式" class="header-anchor">#</a> Q1：为什么 Object 和 Array 型数据会有两种不同的变化侦测方式？</h3> <p>在 Vue2 中，基于 Object.defineProperty 对象属性级别的拦截，为每个属性设置 getter/setter。由于局限于 Object.defineProperty 是对象原型上的方法，并且是对象属性层面上的数据劫持，不是对象层面的数据代理，同理无法对数组进行劫持。所以 Vue2 侦测数据的变化分为 Object 型的数据和 Array 型数据两种不同的侦测方式。</p> <h3 id="q2-怎么实现对象和数组的监听"><a href="#q2-怎么实现对象和数组的监听" class="header-anchor">#</a> Q2：怎么实现对象和数组的监听？</h3> <p>Object.defineProperty() 只能对属性进行数据劫持，不能对整个对象进行劫持，同理无法对数组进行劫持。对于 Object 类型的数据，<strong>Vue 在 defineReactive 方法中通过 <code>Object.defineProperty</code> 为其添加 getter/setter 追踪数据的变化，监测数据何时发生了变化</strong>；对于 Array 类型的数据，<strong>Vue 通过拦截重写数组原型上可以改变数组的 7 大操作数组方法监测数据何时发生了变化</strong>。</p> <h3 id="q3-如何解决对象新增或删除属性不能响应的问题"><a href="#q3-如何解决对象新增或删除属性不能响应的问题" class="header-anchor">#</a> Q3：如何解决对象新增或删除属性不能响应的问题？</h3> <p>通过 Object.defineProperty 数据劫持存在以下几个问题：</p> <ul><li>Object.defineProperty 只能对属性进行数据劫持，不能对整个对象进行劫持，同理无法对数组进行劫持。</li> <li>通过 Object.defineProperty 方法实现了对 Object 数据的可观测，但是这个方法仅仅只能观测到 Object 数据的取值及设置值（getter/setter），无法检测到对象属性的添加或删除，导致当我们对 Object 数据添加或删除值时，无法通知依赖，无法驱动视图进行响应式更新。</li> <li>对于 Array 只要是通过数组原型上的方法对数组进行操作就都可以侦测到，但是在日常开发中，还可以通过数组的下标来操作数据，例如通过修改数组长度，用索引直接设置一个数组项，这也是无法侦测到的。</li> <li>只有在 Vue 初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。</li></ul> <p>由于 Vue 不允许动态添加根级响应式 property，所以你必须在初始化实例前声明所有根级响应式 property，哪怕只是一个空值。如果你未在 data 选项中声明 message，Vue 将警告你渲染函数正在试图访问不存在的 property。这时候就可以用 <code>Vue.set(vm.$set)</code> 和 <code>Vue.delete(vm.$delete)</code> 。这样的限制在背后是有其技术原因的，它消除了在依赖项跟踪系统中的一类边界情况，也使 Vue 实例能更好地配合类型检查系统工作，以及可维护性代码。</p> <p>由于 Vue 会在<strong>初始化实例时</strong>对 property 执行 getter/setter 转化，所以 property 必须在 data 对象上存在才能让 Vue 将它转换为响应式的。对于已经创建的实例，Vue 不允许动态添加根级别的响应式 property。<code>Vue.set(object, propertyName, value)</code> 方法向嵌套对象添加响应式 property</p> <p>Vue 不能检测以下数组的变动：</p> <ul><li>当你利用索引直接设置一个数组项时，例如：<code>vm.items[indexOfItem] = newValue</code>  可以这样解决 <code>vm.items.splice(indexOfItem, 1, newValue)</code> 或 <code>vm.$set(vm.items, indexOfItem, newValue)</code></li> <li>当你修改数组的长度时，例如：<code>vm.items.length = newLength</code>。可以这样解决 <code>vm.items.splice(newLength)</code></li></ul> <p>Vue 不允许动态添加根级别的响应式 property。为了解决这一问题，Vue 增加了两个全局API: <code>Vue.set(vm.$set)</code> 和 <code>Vue.delete(vm.$delete)</code> 。</p> <ul><li>Vue.set( target, propertyName/index, value )</li> <li>Vue.delete( target, propertyName/index )</li></ul> <p>Vue 不允许在已创建的实例上动态添加新的响应式属性。若想实现数据与视图同步更新，可采取下面三种解决方案：</p> <ul><li>Vue.set( target, propertyName/index，value)</li> <li>Object.assign() / deepClone() 浅拷贝与深拷贝</li> <li>利用扩展运算符，以新对象替换老对象。</li> <li>$forceUpdate()</li> <li>Vue.observable(object) 让一个对象可响应。Vue 内部会用它来处理 data 函数返回的对象。2.6.0 新增。</li></ul> <p>vm.$set 的实现原理是：</p> <ul><li>如果目标是数组，直接使用数组的 splice 方法触发响应式；</li> <li>如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理（ defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">set</span> <span class="token punctuation">(</span><span class="token parameter">target<span class="token operator">:</span> Array<span class="token operator">&lt;</span>any<span class="token operator">&gt;</span> <span class="token operator">|</span> Object<span class="token punctuation">,</span> key<span class="token operator">:</span> any<span class="token punctuation">,</span> val<span class="token operator">:</span> any</span><span class="token punctuation">)</span><span class="token operator">:</span> any <span class="token punctuation">{</span>
  <span class="token comment">// target 为数组  </span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isValidArrayIndex</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 修改数组的长度, 避免索引&gt;数组长度导致splcie()执行有误</span>
    target<span class="token punctuation">.</span>length <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>length<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
    <span class="token comment">// 利用数组的splice变异方法触发响应式  </span>
    target<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span>
    <span class="token keyword">return</span> val
  <span class="token punctuation">}</span>
  <span class="token comment">// key 已经存在，直接修改属性值  </span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token keyword">in</span> target <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>key <span class="token keyword">in</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> val
    <span class="token keyword">return</span> val
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> ob <span class="token operator">=</span> <span class="token punctuation">(</span>target<span class="token operator">:</span> any<span class="token punctuation">)</span><span class="token punctuation">.</span>__ob__
  <span class="token comment">// target 本身就不是响应式数据, 直接赋值</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ob<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> val
    <span class="token keyword">return</span> val
  <span class="token punctuation">}</span>
  <span class="token comment">// 对属性进行响应式处理</span>
  <span class="token function">defineReactive</span><span class="token punctuation">(</span>ob<span class="token punctuation">.</span>value<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span>
  ob<span class="token punctuation">.</span>dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> val
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p>Vue.delete( target, propertyName/index ) 的实现：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">del</span> <span class="token punctuation">(</span><span class="token parameter">target<span class="token operator">:</span> Array<span class="token operator">&lt;</span>any<span class="token operator">&gt;</span> <span class="token operator">|</span> Object<span class="token punctuation">,</span> key<span class="token operator">:</span> any</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span>
    <span class="token punctuation">(</span><span class="token function">isUndef</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">isPrimitive</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">warn</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Cannot delete reactive property on undefined, null, or primitive value: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token punctuation">(</span>target<span class="token operator">:</span> any<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isValidArrayIndex</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    target<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> ob <span class="token operator">=</span> <span class="token punctuation">(</span>target<span class="token operator">:</span> any<span class="token punctuation">)</span><span class="token punctuation">.</span>__ob__
  <span class="token keyword">if</span> <span class="token punctuation">(</span>target<span class="token punctuation">.</span>_isVue <span class="token operator">||</span> <span class="token punctuation">(</span>ob <span class="token operator">&amp;&amp;</span> ob<span class="token punctuation">.</span>vmCount<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">warn</span><span class="token punctuation">(</span>
      <span class="token string">'Avoid deleting properties on a Vue instance or its root $data '</span> <span class="token operator">+</span>
      <span class="token string">'- just set it to null.'</span>
    <span class="token punctuation">)</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasOwn</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">delete</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ob<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>
  ob<span class="token punctuation">.</span>dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p>有时你可能需要为已有对象赋值多个新 property，比如使用 <code>Object.assign()</code> 或 <code>_.extend()</code>。但是，这样添加到对象上的新 property 不会触发更新。在这种情况下，你应该用原对象与要混合进去的对象的 property 一起创建一个新的对象。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 代替 `Object.assign(this.someObject, { a: 1, b: 2 })`</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>someObject <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>someObject<span class="token punctuation">,</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>使用 <code>$forceUpdate()</code> 在 Vue 中做一次强制更新，<code>$forceUpdate()</code> 迫使 vue 重新渲染。仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。</p> <ul><li>如果为对象添加少量的新属性，可以直接采用 <code>Vue.set()</code></li> <li>如果需要为新对象添加大量的新属性，则通过 <code>Object.assign()</code> 创建新对象</li> <li>如果你需要进行强制刷新时，可采取 <code>$forceUpdate()</code> (不建议)</li> <li>vue3 是用过 proxy 实现数据响应式的，直接动态添加新属性仍可以实现数据响应式</li></ul> <h3 id="q4-发布订阅设计模式"><a href="#q4-发布订阅设计模式" class="header-anchor">#</a> Q4：发布订阅设计模式</h3> <p>​发布-订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态改变时，所有依赖于它的对象都将得到通知。</p> <p>优点：</p> <ul><li>发布-订阅模式广泛应用于异步编程中，这是一种替代传递回调函数的方案(异步编程实现的一种方案，在JS专栏中有讲)。比如，我们可以订阅 ajax 请求的 error 、success 等事件。在异步编程中使用发布-订阅模式， 我们就无需过多关注对象在异步运行期间的内部状态，而只需要订阅感兴趣的事件发生点。</li> <li>发布-订阅模式可以取代对象之间硬编码的通知机制，一个对象不用再显式地调用另外一个对象的某个接口。发布-订阅模式让两个对象松耦合地联系在一起，虽然不太清楚彼此的细节，但这不影响它们之间相互通信。当有新的订阅者出现时，发布者的代码不需要任何修改；同样发布者需要改变时，也不会影响到之前的订阅者。只要之前约定的事件名没有变化，就可以自由地改变它们。</li></ul> <p>生活实例：</p> <p>​我们以售楼处的例子来举例说明发布-订阅模式：</p> <p>小明最近看上了一套房子，到了售楼处之后才被告知，该楼盘的房子早已售罄。好在售楼 MM 告诉小明，不久后还有一些尾盘推出，开发商正在办理相关手续，手续办好后便可以购买。</p> <p>但到底是什么时候，目前还没有人能够知道。 于是小明记下了售楼处的电话，以后每天都会打电话过去询问是不是已经到了购买时间。除 了小明，还有小红、小强、小龙也会每天向售楼处咨询这个问题。一个星期过后，售楼 MM 决定辞职，因为厌倦了每天回答 1000个相同内容的电话。</p> <p>当然现实中没有这么笨的销售公司，实际上故事是这样的：小明离开之前，把电话号码留在 了售楼处。售楼 MM 答应他，新楼盘一推出就马上发信息通知小明。小红、小强和小龙也是一样，他们的电话号码都被记在售楼处的花名册上，新楼盘推出的时候，售楼 MM会翻开花名册，遍历上面的电话号码，依次发送一条短信来通知他们。</p> <h3 id="q5-组件中-data-为什么是一个函数"><a href="#q5-组件中-data-为什么是一个函数" class="header-anchor">#</a> Q5: 组件中 data 为什么是一个函数</h3> <p>为什么组件中的 data 必须是一个函数，然后 return 一个对象，而 new Vue 实例里，data 可以直接是一个对象？</p> <ol><li><p>组件是一个具有单独自身功能模块的封装，这个模块有属于自己的HTML模板，也应该有属于自己的数据 data，组件也有自己的方法 methods。组件不能直接访问 Vue 实例中定义的数据。就算可以访问，若将所有的数据都放在 Vue 实例中，Vue 实例就会变得非常臃肿（数据很多），所以组件应该有自己保存数据的地方。</p></li> <li><p>因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响，如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。</p></li></ol> <p>Vue 实例的数据对象。Vue 将会递归将 data 的 property 转换为 getter/setter，从而让 data 的 property 能够响应数据变化。对象必须是纯粹的对象 (含有零个或多个的 key/value 对)：浏览器 API 创建的原生对象，原型上的 property 会被忽略。大概来说，data 应该只能是数据 - 不推荐观察拥有状态行为的对象。一旦观察过，你就无法在根数据对象上添加响应式 property。因此推荐在创建实例之前，就声明所有的根级响应式 property。</p> <p>当一个组件被定义，data 必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。如果 data 仍然是一个纯粹的对象，则所有的实例将共享引用同一个数据对象！通过提供 data 函数，每次创建一个新实例后，我们能够调用 data 函数，从而返回初始数据的一个全新副本数据对象。如果需要，可以通过将 <code>vm.$data</code> 传入 <code>JSON.parse(JSON.stringify(...))</code> 得到深拷贝的原始数据对象。</p> <p>注意，如果你为 data property 使用了箭头函数，则 this 不会指向这个组件的实例，不过你仍然可以将其实例作为函数的第一个参数来访问。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token function-variable function">data</span><span class="token operator">:</span> <span class="token parameter">vm</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token operator">:</span> vm<span class="token punctuation">.</span>myProp <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="q6-proxy-与-object-defineproperty-优劣对比"><a href="#q6-proxy-与-object-defineproperty-优劣对比" class="header-anchor">#</a> Q6: Proxy 与 Object.defineProperty 优劣对比</h3> <p>Proxy 的优势如下:</p> <ul><li>Proxy 可以直接监听对象而非属性；</li> <li>Proxy 可以直接监听数组的变化；</li> <li>Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；</li> <li>Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；</li> <li>Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；</li></ul> <p>Object.defineProperty 的优势如下:</p> <ul><li>兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。</li></ul> <div class="custom-block warning"><p class="custom-block-title">参考文献</p> <p><a href="https://mp.weixin.qq.com/s/SypAULMnbaSu8MSm2Ugl6g" target="_blank" rel="noopener noreferrer">深入理解vue响应式原理 8000字<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://www.imooc.com/article/14466" target="_blank" rel="noopener noreferrer">Vue 源码解析：深入响应式原理<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://juejin.cn/post/6844903903822086151#heading-12" target="_blank" rel="noopener noreferrer">0 到 1 掌握：Vue 核心之数据双向绑定<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://mp.weixin.qq.com/s/FxeXNAFuOrVBV-GK__nh6g" target="_blank" rel="noopener noreferrer">你可以手写Vue3的响应式原理吗<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/vue/vue/vue-init.html" class="prev">
        构建与初始化
      </a></span> <span class="next"><a href="/blog/vue/vue/vue-template.html">
        模板编译与渲染
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----><!----><!----></div></div>
    <script src="/blog/assets/js/app.7d7aee42.js" defer></script><script src="/blog/assets/js/2.55125c9d.js" defer></script><script src="/blog/assets/js/106.7b57d9e3.js" defer></script><script src="/blog/assets/js/4.f8e09ced.js" defer></script>
  </body>
</html>
