<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>渲染层面优化 | 花帽子的博客</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/blog/logo.png">
    <link rel="manifest" href="/blog/manifest.json">
    <link rel="apple-touch-icon" href="/blog/images/icons/apple-icon-152x152.png">
    <meta name="description" content="我命由我不由天，学习吧少年">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
    <meta name="msapplication-TileColor" content="#000000">
    
    <link rel="preload" href="/blog/assets/css/0.styles.1c8ccece.css" as="style"><link rel="preload" href="/blog/assets/js/app.b3209530.js" as="script"><link rel="preload" href="/blog/assets/js/2.8bf77cff.js" as="script"><link rel="preload" href="/blog/assets/js/27.df70c5e4.js" as="script"><link rel="preload" href="/blog/assets/js/4.ff6074e9.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.59bd7815.js"><link rel="prefetch" href="/blog/assets/js/100.858b44e3.js"><link rel="prefetch" href="/blog/assets/js/101.4b99c6f8.js"><link rel="prefetch" href="/blog/assets/js/102.f9d8aa03.js"><link rel="prefetch" href="/blog/assets/js/103.e2f065c1.js"><link rel="prefetch" href="/blog/assets/js/104.be1b57f6.js"><link rel="prefetch" href="/blog/assets/js/105.de6e3141.js"><link rel="prefetch" href="/blog/assets/js/106.e177ad64.js"><link rel="prefetch" href="/blog/assets/js/107.522ee48f.js"><link rel="prefetch" href="/blog/assets/js/108.2c07eae1.js"><link rel="prefetch" href="/blog/assets/js/109.1026bd2f.js"><link rel="prefetch" href="/blog/assets/js/11.cbbf834d.js"><link rel="prefetch" href="/blog/assets/js/110.3474ddbe.js"><link rel="prefetch" href="/blog/assets/js/111.8a6d1533.js"><link rel="prefetch" href="/blog/assets/js/112.345ee884.js"><link rel="prefetch" href="/blog/assets/js/113.42a44a95.js"><link rel="prefetch" href="/blog/assets/js/114.109d57f9.js"><link rel="prefetch" href="/blog/assets/js/115.d345e8e8.js"><link rel="prefetch" href="/blog/assets/js/116.56372cc1.js"><link rel="prefetch" href="/blog/assets/js/117.b991c624.js"><link rel="prefetch" href="/blog/assets/js/118.0cfc10e8.js"><link rel="prefetch" href="/blog/assets/js/119.f41389ff.js"><link rel="prefetch" href="/blog/assets/js/12.f09b152a.js"><link rel="prefetch" href="/blog/assets/js/120.c5d2ac90.js"><link rel="prefetch" href="/blog/assets/js/121.140f91a1.js"><link rel="prefetch" href="/blog/assets/js/122.5dc82921.js"><link rel="prefetch" href="/blog/assets/js/123.181b897d.js"><link rel="prefetch" href="/blog/assets/js/124.fbea5e13.js"><link rel="prefetch" href="/blog/assets/js/125.76905808.js"><link rel="prefetch" href="/blog/assets/js/126.bb28c67f.js"><link rel="prefetch" href="/blog/assets/js/127.58fa443d.js"><link rel="prefetch" href="/blog/assets/js/128.dc852f53.js"><link rel="prefetch" href="/blog/assets/js/129.7b8d33ae.js"><link rel="prefetch" href="/blog/assets/js/13.f1214399.js"><link rel="prefetch" href="/blog/assets/js/130.645c45d5.js"><link rel="prefetch" href="/blog/assets/js/131.4102269c.js"><link rel="prefetch" href="/blog/assets/js/132.94e89735.js"><link rel="prefetch" href="/blog/assets/js/133.b1e0aaeb.js"><link rel="prefetch" href="/blog/assets/js/134.2d878fe6.js"><link rel="prefetch" href="/blog/assets/js/135.547140ec.js"><link rel="prefetch" href="/blog/assets/js/136.8cd08a0c.js"><link rel="prefetch" href="/blog/assets/js/137.864b24ef.js"><link rel="prefetch" href="/blog/assets/js/138.5c88ccec.js"><link rel="prefetch" href="/blog/assets/js/139.31c79a50.js"><link rel="prefetch" href="/blog/assets/js/14.d085f628.js"><link rel="prefetch" href="/blog/assets/js/140.b9ec5d6a.js"><link rel="prefetch" href="/blog/assets/js/141.9aa49d8e.js"><link rel="prefetch" href="/blog/assets/js/142.b7532cf7.js"><link rel="prefetch" href="/blog/assets/js/143.ac9fcc86.js"><link rel="prefetch" href="/blog/assets/js/144.566a7621.js"><link rel="prefetch" href="/blog/assets/js/145.5ded4805.js"><link rel="prefetch" href="/blog/assets/js/146.addd9e67.js"><link rel="prefetch" href="/blog/assets/js/147.e60b30d5.js"><link rel="prefetch" href="/blog/assets/js/148.3214b821.js"><link rel="prefetch" href="/blog/assets/js/149.323bdbc9.js"><link rel="prefetch" href="/blog/assets/js/15.5b042421.js"><link rel="prefetch" href="/blog/assets/js/150.0133d123.js"><link rel="prefetch" href="/blog/assets/js/151.87634cad.js"><link rel="prefetch" href="/blog/assets/js/152.b0197ea0.js"><link rel="prefetch" href="/blog/assets/js/153.e119408f.js"><link rel="prefetch" href="/blog/assets/js/154.df0f5c6a.js"><link rel="prefetch" href="/blog/assets/js/155.27382c94.js"><link rel="prefetch" href="/blog/assets/js/156.efeb2e06.js"><link rel="prefetch" href="/blog/assets/js/157.6b314ec4.js"><link rel="prefetch" href="/blog/assets/js/158.d74b0b58.js"><link rel="prefetch" href="/blog/assets/js/159.fb1a2ffb.js"><link rel="prefetch" href="/blog/assets/js/16.d0cca31c.js"><link rel="prefetch" href="/blog/assets/js/160.9c4aa3de.js"><link rel="prefetch" href="/blog/assets/js/161.528d482f.js"><link rel="prefetch" href="/blog/assets/js/162.e524056a.js"><link rel="prefetch" href="/blog/assets/js/163.6cde151b.js"><link rel="prefetch" href="/blog/assets/js/164.065addff.js"><link rel="prefetch" href="/blog/assets/js/165.757e480b.js"><link rel="prefetch" href="/blog/assets/js/166.339496a6.js"><link rel="prefetch" href="/blog/assets/js/17.7d627321.js"><link rel="prefetch" href="/blog/assets/js/18.cf67db1a.js"><link rel="prefetch" href="/blog/assets/js/19.aaf720d3.js"><link rel="prefetch" href="/blog/assets/js/20.2a683d98.js"><link rel="prefetch" href="/blog/assets/js/21.7d63b327.js"><link rel="prefetch" href="/blog/assets/js/22.c64711a7.js"><link rel="prefetch" href="/blog/assets/js/23.b23738eb.js"><link rel="prefetch" href="/blog/assets/js/24.50023b4e.js"><link rel="prefetch" href="/blog/assets/js/25.e5d71466.js"><link rel="prefetch" href="/blog/assets/js/26.b262f9d3.js"><link rel="prefetch" href="/blog/assets/js/28.59714010.js"><link rel="prefetch" href="/blog/assets/js/29.63a13b59.js"><link rel="prefetch" href="/blog/assets/js/3.6c93b5c9.js"><link rel="prefetch" href="/blog/assets/js/30.b2202a30.js"><link rel="prefetch" href="/blog/assets/js/31.95707786.js"><link rel="prefetch" href="/blog/assets/js/32.a217e37c.js"><link rel="prefetch" href="/blog/assets/js/33.a41a393b.js"><link rel="prefetch" href="/blog/assets/js/34.5f125b33.js"><link rel="prefetch" href="/blog/assets/js/35.d91d092d.js"><link rel="prefetch" href="/blog/assets/js/36.cd6b2a6d.js"><link rel="prefetch" href="/blog/assets/js/37.b96aeb1c.js"><link rel="prefetch" href="/blog/assets/js/38.c58f044b.js"><link rel="prefetch" href="/blog/assets/js/39.614d5d15.js"><link rel="prefetch" href="/blog/assets/js/40.5e5f0850.js"><link rel="prefetch" href="/blog/assets/js/41.19130b01.js"><link rel="prefetch" href="/blog/assets/js/42.b9520ca2.js"><link rel="prefetch" href="/blog/assets/js/43.dd91c09f.js"><link rel="prefetch" href="/blog/assets/js/44.c64d18ba.js"><link rel="prefetch" href="/blog/assets/js/45.664d1516.js"><link rel="prefetch" href="/blog/assets/js/46.907b5d06.js"><link rel="prefetch" href="/blog/assets/js/47.7ca653b7.js"><link rel="prefetch" href="/blog/assets/js/48.6de388b2.js"><link rel="prefetch" href="/blog/assets/js/49.21ca9c2f.js"><link rel="prefetch" href="/blog/assets/js/5.2328d578.js"><link rel="prefetch" href="/blog/assets/js/50.3b64cda4.js"><link rel="prefetch" href="/blog/assets/js/51.1dacae85.js"><link rel="prefetch" href="/blog/assets/js/52.8f2954df.js"><link rel="prefetch" href="/blog/assets/js/53.a5abc8a9.js"><link rel="prefetch" href="/blog/assets/js/54.c496f635.js"><link rel="prefetch" href="/blog/assets/js/55.757c6215.js"><link rel="prefetch" href="/blog/assets/js/56.43a8d14c.js"><link rel="prefetch" href="/blog/assets/js/57.562dd3c3.js"><link rel="prefetch" href="/blog/assets/js/58.70248302.js"><link rel="prefetch" href="/blog/assets/js/59.bc34be66.js"><link rel="prefetch" href="/blog/assets/js/6.539ab69c.js"><link rel="prefetch" href="/blog/assets/js/60.0b62463e.js"><link rel="prefetch" href="/blog/assets/js/61.1358ca4f.js"><link rel="prefetch" href="/blog/assets/js/62.5b29d313.js"><link rel="prefetch" href="/blog/assets/js/63.fe6cc3c9.js"><link rel="prefetch" href="/blog/assets/js/64.5ac3a895.js"><link rel="prefetch" href="/blog/assets/js/65.437a2860.js"><link rel="prefetch" href="/blog/assets/js/66.20bf2a93.js"><link rel="prefetch" href="/blog/assets/js/67.68461294.js"><link rel="prefetch" href="/blog/assets/js/68.3dddf877.js"><link rel="prefetch" href="/blog/assets/js/69.516021b5.js"><link rel="prefetch" href="/blog/assets/js/7.c55f6e83.js"><link rel="prefetch" href="/blog/assets/js/70.a0523390.js"><link rel="prefetch" href="/blog/assets/js/71.8b6cd8c5.js"><link rel="prefetch" href="/blog/assets/js/72.69d25064.js"><link rel="prefetch" href="/blog/assets/js/73.2598099d.js"><link rel="prefetch" href="/blog/assets/js/74.c3b702b6.js"><link rel="prefetch" href="/blog/assets/js/75.cc0e9553.js"><link rel="prefetch" href="/blog/assets/js/76.a218436f.js"><link rel="prefetch" href="/blog/assets/js/77.1a9b67f2.js"><link rel="prefetch" href="/blog/assets/js/78.823b26bf.js"><link rel="prefetch" href="/blog/assets/js/79.15f0377a.js"><link rel="prefetch" href="/blog/assets/js/8.60aa9c8a.js"><link rel="prefetch" href="/blog/assets/js/80.8cebe95c.js"><link rel="prefetch" href="/blog/assets/js/81.785a38ab.js"><link rel="prefetch" href="/blog/assets/js/82.e4b6977a.js"><link rel="prefetch" href="/blog/assets/js/83.a2ae2280.js"><link rel="prefetch" href="/blog/assets/js/84.6cfbf6ea.js"><link rel="prefetch" href="/blog/assets/js/85.b199eee3.js"><link rel="prefetch" href="/blog/assets/js/86.fc0402d0.js"><link rel="prefetch" href="/blog/assets/js/87.1f039e64.js"><link rel="prefetch" href="/blog/assets/js/88.e08e74ea.js"><link rel="prefetch" href="/blog/assets/js/89.26656b6b.js"><link rel="prefetch" href="/blog/assets/js/9.1dc34dd8.js"><link rel="prefetch" href="/blog/assets/js/90.c88f580e.js"><link rel="prefetch" href="/blog/assets/js/91.68f8b3e7.js"><link rel="prefetch" href="/blog/assets/js/92.35735724.js"><link rel="prefetch" href="/blog/assets/js/93.ced12c21.js"><link rel="prefetch" href="/blog/assets/js/94.214330bd.js"><link rel="prefetch" href="/blog/assets/js/95.82bf7e0d.js"><link rel="prefetch" href="/blog/assets/js/96.a9eefec5.js"><link rel="prefetch" href="/blog/assets/js/97.24abbf05.js"><link rel="prefetch" href="/blog/assets/js/98.18e30f0b.js"><link rel="prefetch" href="/blog/assets/js/99.b7954e4e.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.1c8ccece.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/logo.png" alt="花帽子的博客" class="logo"> <span class="site-name can-hide">花帽子的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/blog/vue/" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/blog/react/" class="nav-link">
  React
</a></div><div class="nav-item"><a href="/blog/css/" class="nav-link">
  CSS
</a></div><div class="nav-item"><a href="/blog/javascript/" class="nav-link">
  JS&amp;TS
</a></div><div class="nav-item"><a href="/blog/node/" class="nav-link">
  Node
</a></div><div class="nav-item"><a href="/blog/devops/" class="nav-link router-link-active">
  前端工程化
</a></div><div class="nav-item"><a href="/blog/mobile/" class="nav-link">
  泛客户端
</a></div><div class="nav-item"><a href="/blog/framework/" class="nav-link">
  架构&amp;方案
</a></div><div class="nav-item"><a href="/blog/code/" class="nav-link">
  算法&amp;编程
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="GitHub" class="dropdown-title"><span class="title">GitHub</span> <span class="arrow down"></span></button> <button type="button" aria-label="GitHub" class="mobile-dropdown-title"><span class="title">GitHub</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/jonny-wei" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub地址
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/blog/vue/" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/blog/react/" class="nav-link">
  React
</a></div><div class="nav-item"><a href="/blog/css/" class="nav-link">
  CSS
</a></div><div class="nav-item"><a href="/blog/javascript/" class="nav-link">
  JS&amp;TS
</a></div><div class="nav-item"><a href="/blog/node/" class="nav-link">
  Node
</a></div><div class="nav-item"><a href="/blog/devops/" class="nav-link router-link-active">
  前端工程化
</a></div><div class="nav-item"><a href="/blog/mobile/" class="nav-link">
  泛客户端
</a></div><div class="nav-item"><a href="/blog/framework/" class="nav-link">
  架构&amp;方案
</a></div><div class="nav-item"><a href="/blog/code/" class="nav-link">
  算法&amp;编程
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="GitHub" class="dropdown-title"><span class="title">GitHub</span> <span class="arrow down"></span></button> <button type="button" aria-label="GitHub" class="mobile-dropdown-title"><span class="title">GitHub</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/jonny-wei" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub地址
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Webpack</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/devops/" aria-current="page" class="sidebar-link">Webpack 常用配置</a></li><li><a href="/blog/devops/webpack/building.html" class="sidebar-link">构建流程与原理</a></li><li><a href="/blog/devops/webpack/dependency-graph.html" class="sidebar-link">模块依赖关系</a></li><li><a href="/blog/devops/webpack/chunk.html" class="sidebar-link">产物打包逻辑</a></li><li><a href="/blog/devops/webpack/compile.html" class="sidebar-link">模块编译及运行时</a></li><li><a href="/blog/devops/webpack/hmr.html" class="sidebar-link">HMR 热更新</a></li><li><a href="/blog/devops/webpack/loader.html" class="sidebar-link">Webpack Loader</a></li><li><a href="/blog/devops/webpack/plugin.html" class="sidebar-link">Webpack Plugin</a></li><li><a href="/blog/devops/webpack/module-federation.html" class="sidebar-link">模块联邦</a></li><li><a href="/blog/devops/webpack/cache.html" class="sidebar-link">持久化缓存</a></li><li><a href="/blog/devops/webpack/parallel.html" class="sidebar-link">并行构建</a></li><li><a href="/blog/devops/webpack/split-chunks.html" class="sidebar-link">分包策略</a></li><li><a href="/blog/devops/webpack/compress.html" class="sidebar-link">代码压缩</a></li><li><a href="/blog/devops/webpack/tree-shaking.html" class="sidebar-link">Tree Shaking</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Vite</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/devops/vite/esm.html" class="sidebar-link">模块化规范</a></li><li><a href="/blog/devops/vite/css.html" class="sidebar-link">CSS 工程化</a></li><li><a href="/blog/devops/vite/prebuild.html" class="sidebar-link">依赖预构建</a></li><li><a href="/blog/devops/vite/engines.html" class="sidebar-link">双引擎架构</a></li><li><a href="/blog/devops/vite/rollup.html" class="sidebar-link">Rollup 打包</a></li><li><a href="/blog/devops/vite/building.html" class="sidebar-link">Vite 构建原理</a></li><li><a href="/blog/devops/vite/plugin.html" class="sidebar-link">Vite Plugin</a></li><li><a href="/blog/devops/vite/hmr.html" class="sidebar-link">Vite HMR 热更新</a></li><li><a href="/blog/devops/vite/ssr.html" class="sidebar-link">SSR 工程化</a></li><li><a href="/blog/devops/vite/legacy.html" class="sidebar-link">兼容性问题</a></li><li><a href="/blog/devops/vite/split-code.html" class="sidebar-link">代码分割</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>性能优化</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/devops/performance/network.html" class="sidebar-link">网络层面优化</a></li><li><a href="/blog/devops/performance/webpack.html" class="sidebar-link">构建层面优化</a></li><li><a href="/blog/devops/performance/render.html" aria-current="page" class="active sidebar-link">渲染层面优化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/devops/performance/render.html#热身" class="sidebar-link">热身</a></li><li class="sidebar-sub-header"><a href="/blog/devops/performance/render.html#阻塞渲染的因素" class="sidebar-link">阻塞渲染的因素</a></li><li class="sidebar-sub-header"><a href="/blog/devops/performance/render.html#关键渲染路径优化" class="sidebar-link">关键渲染路径优化</a></li><li class="sidebar-sub-header"><a href="/blog/devops/performance/render.html#白屏渲染优化" class="sidebar-link">白屏渲染优化</a></li></ul></li><li><a href="/blog/devops/performance/code.html" class="sidebar-link">代码层面优化</a></li><li><a href="/blog/devops/performance/analysis.html" class="sidebar-link">性能分析</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="渲染层面优化"><a href="#渲染层面优化" class="header-anchor">#</a> 渲染层面优化</h1> <p>结合 <strong>渲染进程(浏览器内核)</strong> 即 <strong>关键渲染路径</strong> 优化首屏渲染，减少白屏。</p> <h2 id="热身"><a href="#热身" class="header-anchor">#</a> 热身</h2> <h3 id="什么是-crp"><a href="#什么是-crp" class="header-anchor">#</a> 什么是 CRP</h3> <p>CRP（关键渲染路径）: 指浏览器通过把 HTML、CSS 和 JavaScript 转化成屏幕上的像素的步骤顺序。优化关键渲染路径可以提高渲染性能。关键渲染路径包含了 Document Object Model (DOM)，CSS Object Model (CSSOM)，渲染树和布局。优化关键渲染路径可以提升首屏渲染时间。理解和优化关键渲染路径对于确保回流和重绘可以每秒 60 帧、确保高性能的用户交互和避免无意义渲染至关重要。</p> <h3 id="为何-js-是单线程"><a href="#为何-js-是单线程" class="header-anchor">#</a> 为何 js 是单线程</h3> <p>JavaScript 的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM。这决定了它只能是单线程。如果 JS 是多线程的方式来操作这些 UI DOM，则可能出现UI操作的冲突；如果在多线程的交互下，处于 UI中的 DOM节点就可能成为一个临界资源，假设存在两个线程同时操作一个 DOM，一个负责修改一个负责删除，那么这个时候就需要浏览器来裁决如何生效哪个线程的执行结果，当然我们可以通过锁来解决上面的问题。但为了避免因为引入了锁而带来更大的复杂性，JS 在最初就选择了单线程执行。</p> <h3 id="css-的阻塞"><a href="#css-的阻塞" class="header-anchor">#</a> CSS 的阻塞</h3> <p>CSS 被视为 <strong>渲染阻塞资源</strong>(包括JS)，这意味着浏览器将不会渲染任何已处理的内容，直至 CSSOM 构建完毕，才会进行下一阶段。</p> <p>存在阻塞的 CSS 资源时，浏览器会延迟 JavaScript 的执行和 DOM 构建。另外：当浏览器遇到一个 script 标记时，DOM 构建将暂停，直至脚本完成执行。JavaScript 可以查询和修改 DOM 与 CSSOM。CSSOM 构建时，JavaScript 执行将暂停，直至 CSSOM 就绪。</p> <p>关于CSS加载的阻塞情况：</p> <ul><li>css 加载不会阻塞 DOM 树的解析，但会阻塞 DOM 树的渲染</li> <li>css 加载会阻塞后面 js 语句的执行，样式表会在后面的 js 执行前先加载执行完毕</li></ul> <p>没有 js 的理想情况下，html 与 css 会并行解析，分别生成 DOM 与 CSSOM，然后合并成 Render Tree，进入 Rendering Pipeline；但如果有 js，css 加载会阻塞后面 js 语句的执行，而（同步）js 脚本执行会阻塞其后的 DOM 解析（所以通常会把 css 放在头部，js 放在 body 尾）</p> <h3 id="js-的阻塞"><a href="#js-的阻塞" class="header-anchor">#</a> JS 的阻塞</h3> <p>由于 JavaScript 是可操纵 DOM 的，如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。
因此为了防止渲染出现不可预期的结果，浏览器设置 <strong>GUI 渲染线程与 JavaScript 引擎为互斥的关系</strong>。当 JavaScript 引擎执行时 GUI 线程会被挂起，GUI 更新会被保存在一个队列中等到引擎线程空闲时立即被执行。因此如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。</p> <p>JavaScript 被认为是 <strong>解释器阻塞资源</strong>，浏览器解析文档，当遇到 <code>&lt;script&gt;</code> 标签的时候，会立即交给 JS 引擎解析脚本，停止解析 DOM 与 CSSOM（因为JS可能会改动 DOM 和 CSS，所以继续解析会造成浪费）。如果脚本是外部的，会等待脚本下载完毕，再继续解析文档。现在可以在 script 标签上增加属性 defer 或者 async。脚本解析会将脚本中改变 DOM 和 CSS 的地方分别解析出来，追加到 DOM Tree 和 Style Rules 上。</p> <p>JS 对关键路径渲染的影响不只是阻塞 DOM 构建，也会导致 CSSOM 阻塞 DOM 构建。如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟脚本执行和 DOM 构建，直至其完成 CSSOM 的下载和构建。</p> <p>如果没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的HTML元素之前，也就是说不等待后续载入的 HTML 元素，读到就加载并执行。</p> <p>解析过程中无论遇到的 JavaScript 是内联还是外链，只要浏览器遇到 script 标记，唤醒 JavaScript 解析器，就会进行暂停 (blocked) 浏览器解析 HTML，并等到 CSSOM 构建完毕，才去执行 js 脚本。因为脚本中可能会操作 DOM 元素，而如果在加载执行脚本的时候 DOM 元素并没有被解析，脚本就会因为 DOM 元素没有生成取不到响应元素，所以实际工程中，我们常常将资源放到文档底部。</p> <h3 id="domcontentloaded-与-load-的区别"><a href="#domcontentloaded-与-load-的区别" class="header-anchor">#</a> DOMContentLoaded 与 load 的区别</h3> <p>当 DOMContentLoaded 事件触发时，仅当 DOM 解析完成后，不包括样式表，图片。我们前面提到 CSS 加载会阻塞 Dom 的渲染和后面 js 的执行，js 会阻塞 Dom 解析，所以我们可以得到结论:</p> <p>当文档中没有脚本时，浏览器解析完文档便能触发 DOMContentLoaded 事件。如果文档中包含脚本，则脚本会阻塞文档的解析，而脚本需要等 CSSOM 构建完成才能执行。在任何情况下，DOMContentLoaded 的触发不需要等待图片等其他资源加载完成。</p> <p>当 onload 事件触发时，页面上所有的 DOM，样式表，脚本，图片等资源已经加载完毕。</p> <p>DOMContentLoaded -&gt; load。</p> <h3 id="preload-和-prefetch-的区别"><a href="#preload-和-prefetch-的区别" class="header-anchor">#</a> preload 和 prefetch 的区别</h3> <ul><li><p><strong>preload 优先加载</strong>。会提升资源的优先级因为它标明这个资源是本页肯定会用到 —— <strong>本页优先</strong>。使用 preload 来提升资源加载的优先级。 preload 最大的作用就是将下载与执行分离，并且将下载的优先级提到了一个很高的地步，再由我们去控制资源执行的位置。</p></li> <li><p><strong>prefetch 预加载</strong>。会降低这个资源的优先级因为它标明这个资源是下一页可能用到的 —— <strong>为下一页提前加载</strong>。</p></li></ul> <h3 id="defer-与-async-的区别"><a href="#defer-与-async-的区别" class="header-anchor">#</a> defer 与 async 的区别</h3> <p>没有 defer 或 async,浏览器会立即加载并执行指定的脚本，“立即” 指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。</p> <p><strong>defer</strong> ：</p> <p>延迟执行引入的 js。即 js 加载时 HTML 未停止解析，两个过程是并行的。 整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的 JavaScript 代码，再触发 DOMContentLoaded(初始的 HTML 文档被完全加载和解析完成之后触发，无需等待样式表图像和子框架的完成加载) 事件。</p> <ul><li>载入 JavaScript 文件时不阻塞 HTML 的解析</li> <li>执行阶段被放到 HTML 标签解析完成之后</li></ul> <p>有 defer，加载后续文档元素的过程将和 js 的加载并行进行（异步），但是 js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。</p> <p><strong>async</strong>：</p> <p>异步执行引入的 js。如果已经加载好，就会开始执行，无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发(HTML解析完成事件)之后。</p> <ul><li>依然会阻塞 load 事件。换句话说，async-script 可能在 DOMContentLoaded 触发之前或之后执行，但一定在 load 触发之前执行。</li> <li>多个 async-script 的执行顺序是不确定的，谁先加载完谁执行。值得注意的是，向 document 动态添加 script 标签时，async 属性默认是 true。</li> <li>使用 document.createElement(&quot;script&quot;) 创建的 script 默认是异步的。所以，通过动态添加 script 标签引入 JavaScript 文件默认是不会阻塞页面的。</li></ul> <p>有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）</p> <ul><li>defer 和 async 在网络读取（下载）这块儿是一样的,都是异步的（相较于 HTML 解析）</li> <li>它俩的差别在于脚本下载完之后何时执行,显然 defer 是最接近我们对于应用脚本加载和执行的要求的</li> <li>defer 是按照加载顺序执行脚本的，这一点要善加利用</li> <li>async 则是一个乱序执行的主，反正对它来说脚本的加载和执行是紧紧挨着的，所以不管你声明的顺序如何，只要它加载完了就会立刻执行。仔细想 ,async 对于应用脚本的用处不大，因为它完全不考虑依赖（哪怕是最低级的顺序执行），不过它对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适的。</li></ul> <p><a href="https://juejin.cn/post/6894629999215640583" target="_blank" rel="noopener noreferrer">图解 script 标签中的 async 和 defer 属性<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="阻塞渲染的因素"><a href="#阻塞渲染的因素" class="header-anchor">#</a> 阻塞渲染的因素</h2> <h3 id="外部样式表"><a href="#外部样式表" class="header-anchor">#</a> 外部样式表</h3> <p>浏览器的渲染需要 render tree， render tree 需要 CSSOM 树才行，所以样式表的加载是会阻塞页面的渲染的，如果有一个外部的样式表处于下载中，那么即使 HTML 已经下载完毕，也会等待外部样式表下载并解析完毕才会开始构建 render tree。</p> <h3 id="脚本"><a href="#脚本" class="header-anchor">#</a> 脚本</h3> <p>脚本就更麻烦了，先明确一点， JS 引擎和 UI 的渲染引擎是互斥的，所以当脚本在执行的时候浏览器要将控制权就给 JS 引擎，等到 JS 执行完毕再还给 UI 引擎，不论这个脚本是以何种形式加载的，在执行时均会阻塞 UI 的渲染。</p> <p>接下来分别看不同形式加载的脚本对页面渲染的阻塞情况：</p> <h4 id="内联脚本"><a href="#内联脚本" class="header-anchor">#</a> 内联脚本</h4> <p><code>&lt;script&gt;...&lt;/script&gt;</code> 内联的脚本随着 HTML 一起下载，在开始执行时已经完成了 <code>字节 → 字符 → 令牌 → 节点 → 对象模型</code> 的整个过程，所以不存在下载的时间（其实也不能这么说，下载的时间算在了 HTML 的下载时间中），执行时是会阻塞关键渲染路径的。</p> <h4 id="外部脚本"><a href="#外部脚本" class="header-anchor">#</a> 外部脚本</h4> <p><code>&lt;script src=&quot;sample.js&quot;&gt;&lt;/script&gt;</code>外部脚本的整个加载过程及执行过程都是阻塞关键渲染路径的。</p> <h4 id="带-defer-和-async-的外部脚本"><a href="#带-defer-和-async-的外部脚本" class="header-anchor">#</a> 带 defer 和 async 的外部脚本</h4> <p><code>&lt;script src=&quot;sample.js&quot; defer&gt;&lt;/script&gt;</code> <code>&lt;script src=&quot;sample.js&quot; async&gt;&lt;/script&gt;</code> 带 defer/async 的脚本会与 HTML 并行下载，下载的过程不会阻塞 DOM 的构建，但是执行是会的，不同的是 defer 是在 DomContentLoaded 之前执行，async 是加载完之后立刻执行。</p> <p>defer/async 的脚本在下载期间不会阻塞页面解析不是一个技术原因而是一个选择，因为内联脚本/外部脚本是要等待他们执行，所以不得不等待他们下载。而页面并不需要等待 defer/async 的脚本，所以他们的下载与页面的解析是并行的。</p> <h4 id="动态生成的脚本"><a href="#动态生成的脚本" class="header-anchor">#</a> 动态生成的脚本</h4> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> dynamicScript <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">creatElement</span><span class="token punctuation">(</span><span class="token string">'script'</span><span class="token punctuation">)</span>
dynamicScript<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">'sample.js'</span>
document<span class="token punctuation">.</span>head<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>dynamicScript<span class="token punctuation">)</span>
dynamicScript<span class="token punctuation">.</span><span class="token function-variable function">onload</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>动态生成的脚本的下载过程不会阻塞页面的解析，执行会阻塞解析，有点 async 的感觉。</p> <h4 id="脚本与样式表的依赖关系"><a href="#脚本与样式表的依赖关系" class="header-anchor">#</a> 脚本与样式表的依赖关系</h4> <p>脚本不仅能够访问 DOM 元素，还能访问 DOM 的样式，如果将要执行脚本时浏览器尚未完成 CSSOM 的下载及构建，浏览器将延迟脚本执行和 DOM 构建，直至其完成 CSSOM 的下载和构建。</p> <p>所以，CSSOM 的构建会阻塞 HTML 的渲染，也会阻塞 JS 的执行，但不会阻塞 JS 的下载；JS 的下载与执行（内联及外部样式表）也会阻塞 HTML 的渲染。</p> <h2 id="关键渲染路径优化"><a href="#关键渲染路径优化" class="header-anchor">#</a> 关键渲染路径优化</h2> <p><img src="/blog/images/devops/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B.png" alt="浏览器渲染过程"></p> <p><img src="/blog/images/devops/%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF.png" alt="渲染流水线"></p> <p>为尽快完成首次渲染，我们需要最大限度减小以下三种可变因素:</p> <ul><li><p>关键资源的数量: 可能阻止网页首次渲染的资源。</p></li> <li><p>关键路径长度: 获取所有关键资源所需的往返次数或总时间。</p></li> <li><p>关键字节: 实现网页首次渲染所需的总字节数,等同于所有关键资源传送文件大小的总和。</p></li></ul> <p>优化关键渲染路径的常规步骤如下：</p> <ul><li>对关键路径进行分析和特性描述：资源数、字节数、长度。</li> <li>减少关键资源的大小。可以压缩 CSS 和 JavaScript 资源，移除 HTML、CSS、JavaScript 文件中一些注释内容。</li> <li>最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。一种方式是可以将 JavaScript 和 CSS 改成内联的形式；另一种方式，如果 JavaScript 代码没有 DOM 或者 CSSOM 的操作，则可以改成 async 或者 defer 属性</li> <li>优化关键字节数以缩短下载时间 RTT（往返次数）。通过减少关键资源的个数和减少关键资源的大小搭配来实现。除此之外，还可以使用 CDN 来减少每次 RTT 时长</li> <li>优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度。</li></ul> <p>总的优化原则就是 <strong>减少关键资源个数，降低关键资源大小，降低关键资源的 RTT 次数</strong>：</p> <h3 id="优化-css"><a href="#优化-css" class="header-anchor">#</a> 优化 CSS</h3> <p>样式表会阻塞渲染，在加载完毕之前是不会显示的，为了让用户以最快的速度看到页面上的内容，可以将页面的某一部分的样式抽离出来，单独放在一个样式表中或者内联在页面中，这样的样式称为 <strong>关键样式</strong>，这部分样式会优先它可以是页面的骨架屏或者是用户刚加载进页面时看到的首屏的内容。</p> <ul><li>样式分离，webpack 使用 <strong>mini-css-extract-plugin</strong> 分离样式，生成单独的 css 样式文件，压缩净化 CSS 文件。</li> <li>减少关键 CSS 元素数量</li> <li>当我们声明样式表时，请密切关注媒体查询的类型，它们极大地影响了 CRP 的性能 。</li> <li>可以利用 gzip 压缩文件。</li> <li>浏览器缓存</li></ul> <h3 id="preload-prefetch"><a href="#preload-prefetch" class="header-anchor">#</a> preload &amp; prefetch</h3> <ul><li><p><strong>preload 优先加载</strong>。会提升资源的优先级因为它标明这个资源是本页肯定会用到 —— <strong>本页优先</strong>。使用 preload 来提升资源加载的优先级。 preload 最大的作用就是将下载与执行分离，并且将下载的优先级提到了一个很高的地步，再由我们去控制资源执行的位置。</p></li> <li><p><strong>prefetch 预加载</strong>。会降低这个资源的优先级因为它标明这个资源是下一页可能用到的 —— <strong>为下一页提前加载</strong>。</p></li></ul> <p>PreloadWebpackPlugin 用于预加载资源。 匹配其他页面可能用到的资源进行预先加载，从而达到无 loading，用户无感知的跳转。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 1. 配置置于 HtmlWebpackPlugin 之后</span>
<span class="token comment">// 2. Webpack4之后，请使用最新版 npm install --save-dev preload-webpack-plugin@next</span>
<span class="token keyword">new</span> <span class="token class-name">PreloadWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    rel<span class="token operator">:</span> <span class="token string">'prefetch'</span><span class="token punctuation">,</span>
    <span class="token keyword">as</span><span class="token operator">:</span> <span class="token string">'script'</span><span class="token punctuation">,</span>
    <span class="token comment">// as(entry){</span>
    <span class="token comment">//   if(/\.css$/.test(entry)) return 'style';</span>
    <span class="token comment">//   return 'script'</span>
    <span class="token comment">// }</span>
    include<span class="token operator">:</span> <span class="token string">'asyncChunks'</span><span class="token punctuation">,</span>
    <span class="token comment">// fileBlacklist: [&quot;index.css&quot;]</span>
    fileBlackList<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\index.css|index.js|vendors.js]</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.whatever</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h4 id="加速样式表下载"><a href="#加速样式表下载" class="header-anchor">#</a> 加速样式表下载</h4> <p>样式表是阻塞页面呈现的（注意是呈现，不是解析），正常通过 link 加载的外部样式表要等下载，构建 CSSOM 树才会让页面呈现完成，但是 preload 能够让样式表的下载和呈现分离。</p> <p>试想，当你在页面的 head 中写了如下的两个样式表：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>critial.css<span class="token punctuation">&quot;</span></span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>stylesheet<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>non-critial.css<span class="token punctuation">&quot;</span></span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>stylesheet<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>第一个是关键 CSS，第二个不是关键 CSS，当页面解析了这两个 link 标签后开始下载，但是即使 critical.css 下载解析完毕也不会呈现页面，因为页面还要下载和解析 non-critical.css。</p> <p>这时候，就要将 non-critial.css 作为预加载，当样式表作为被 preload 后，他就不会再阻塞页面的呈现，也就是所谓的异步下载，修改后的代码如下：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>critial.css<span class="token punctuation">&quot;</span></span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>stylesheet<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>preload<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>non-critial.css<span class="token punctuation">&quot;</span></span> <span class="token attr-name">as</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>style<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>如此一来，页面在解析完 <code>critical.css</code> 之后就会呈现（暂不考虑脚本），而 <code>non-critial</code> 也在下载，但是并不阻塞页面，指导它下载和解析完毕后才会应用到页面上。</p> <p>现在并不是所有的浏览器都支持 preload，我们可以用 <a href="https://github.com/filamentgroup/loadCSS" target="_blank" rel="noopener noreferrer">loadCSS<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 这个库来做 polyfill，其实现的思路也是遍历所有带 preload 和 as 的标签，然后修改标签的 media 为不匹配任何条件并开始下载，在下载完毕后再还原该 link 原来的 media 标签将它应用。</p> <h4 id="加速脚本下载"><a href="#加速脚本下载" class="header-anchor">#</a> 加速脚本下载</h4> <p>preload 将脚本的加载及执行分离，加了 preload 的 <code>&lt;link&gt;</code> 标签的作用是将脚本提到高优先级尽快完成下载，但并未执行。</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>preload<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>//cdn.staticfile.org/jquery/3.2.1/jquery.min.js<span class="token punctuation">&quot;</span></span> <span class="token attr-name">as</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>script<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>还需要在你想要他执行的地方引入一个正常的 <code>&lt;script&gt;</code> 标签执行这个脚本</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>//cdn.staticfile.org/jquery/3.2.1/jquery.min.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>否则 chrome 大约会在 3s 后报一个 warning 来提醒你这个资源被浪费了完全没有被使用到。</p> <div class="custom-block tip"><p class="custom-block-title">preload 与 defer</p> <p>preload 的功能听起来很像被 defer 的脚本，但是：</p> <ul><li>defer 无法控制脚本执行的时机，是在 DOMContentLoaded 执行前触发</li> <li>defer 会阻塞 DOMContentLoaded 事件</li> <li>defer 会阻塞 onload 事件，preload 不会阻塞 onload 事件</li> <li>defer 的脚本下载的优先级是 low，preload 的脚本优先级是 high</li></ul></div> <div class="custom-block tip"><p class="custom-block-title">加载优先级</p> <p>根据脚本在文档中的位置不同和他们是否是 async，defer 和阻塞，它们会有不同的优先级：</p> <ul><li>阻塞脚本在第一个图片前发起请求的优先级为：Medium（DevTools 中为 high）</li> <li>阻塞脚本在第一个图片后发情请求的优先级为：Low（DevTools 中为 Medium）</li> <li>async/defer/动态插入的脚本（不论他们在文档中的什么位置）的优先级为：Lowest（DevTools 中为 Low）</li></ul></div> <h4 id="加速字体下载"><a href="#加速字体下载" class="header-anchor">#</a> 加速字体下载</h4> <p>自定义的字体在加载之前会处于 FOIT（Flash of Invisible Text）现象，具体的可以看 <a href="https://github.com/fi3ework/blog/issues/8" target="_blank" rel="noopener noreferrer">关于@font-face加载前空白(FOIT)的解决方案<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，虽然我们可以使用类似 webFont 一类的库来控制字体的闪现和添加钩子函数，但最佳解决方法还是让字体的加载达到最快的速度。</p> <p>使用 preload 也可以来加速字体的下载，在 head 中声明 preload，比先下载样式表再从中读到 @font-face 的 src 再去加载要快得多。</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>preload<span class="token punctuation">&quot;</span></span> <span class="token attr-name">as</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>font<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>https://at.alicdn.com/t/font_zck90zmlh7hf47vi.woff<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>但是要注意，preload 字体不带 <code>crossorigin</code> 也将会二次获取！ 确保你对 preload 的字体添加 <code>crossorigin</code> 属性，否则他会被下载两次，这个请求使用匿名的跨域模式。这个建议也适用于字体文件在相同域名下，也适用于其他域名的获取(比如说默认的异步获取)。preload 如果不带 <code>crossorigin meta</code> ，默认情况下 （即未指定 crossorigin 属性时）, CORS 根本不会使用，这样 http 的 request header 中就不会有 origin，默认不去跨域，但是 @font-face 中去加载字体是默认跨域请求的，所以会造成两次的 request header 不同，无法命中缓存，造成重复请求。</p> <p>解决方法就是带上 <code>crossorigin</code>，空关键字和无效关键字都会被当做 <code>anonymous</code></p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>preload<span class="token punctuation">&quot;</span></span> <span class="token attr-name">as</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>font<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>//at.alicdn.com/t/font_327081_19o9k2m6va4np14i.woff<span class="token punctuation">&quot;</span></span> <span class="token attr-name">crossorigin</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>preload<span class="token punctuation">&quot;</span></span> <span class="token attr-name">as</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>font<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>//at.alicdn.com/t/font_327081_19o9k2m6va4np14i.woff<span class="token punctuation">&quot;</span></span> <span class="token attr-name">crossorigin</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>anonymous<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>preload<span class="token punctuation">&quot;</span></span> <span class="token attr-name">as</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>font<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>//at.alicdn.com/t/font_327081_19o9k2m6va4np14i.woff<span class="token punctuation">&quot;</span></span> <span class="token attr-name">crossorigin</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>fi3ework<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h4 id="其他资源"><a href="#其他资源" class="header-anchor">#</a> 其他资源</h4> <p>preload 不仅可以将这些在 head 中的资源加速，还可以提前加载一些隐藏在 CSS 和 JS 中的资源，比如刚才隐藏在 CSS 中的字体资源，或者 JS 中请求的资源。</p> <p>preload 的标签可以动态生成，这意味着在任何时候你都可以在页面中提前加载但不执行一个脚本，然后通过动态脚本来立刻执行它。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> preload <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">&quot;link&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
link<span class="token punctuation">.</span>href <span class="token operator">=</span> <span class="token string">&quot;myscript.js&quot;</span><span class="token punctuation">;</span>
link<span class="token punctuation">.</span>rel <span class="token operator">=</span> <span class="token string">&quot;preload&quot;</span><span class="token punctuation">;</span>
link<span class="token punctuation">.</span>as <span class="token operator">=</span> <span class="token string">&quot;script&quot;</span><span class="token punctuation">;</span>
document<span class="token punctuation">.</span>head<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>link<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">&quot;script&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
script<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">&quot;myscript.js&quot;</span><span class="token punctuation">;</span>
document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h4 id="媒体查询"><a href="#媒体查询" class="header-anchor">#</a> 媒体查询</h4> <p>现在的页面基本上都具有响应式设计，即针对移动端或桌面端会采用 media 进行媒体查询，有两种包含媒体查询的 CSS 代码的方法：</p> <ol><li>将需要媒体查询的代码和基础样式代码放在同一文件中，使用 @media 来使媒体查询生效。</li> <li>将需要媒体查询的代码放在单独的一个外部样式表中，使用 media meta 对需要媒体查询的 link 进行控制。</li></ol> <p>这两种方法各有好处，如果需要媒体查询的代码量很小，那么和基础样式放在一起也没有关系，可以节省一次 HTTP 请求。如果比较大的话，那么就会让样式表的体积增加，造成 FOUC 的时间变长，这时候更适合使用第二种。</p> <p>另外请注意“阻塞渲染”仅是指浏览器是否需要暂停网页的首次渲染，直至该资源准备就绪。无论哪一种情况，浏览器仍会下载 CSS 资源，但是不阻塞渲染的资源优先级较低。</p> <p>优先级较低意味着浏览器在解析 HTML 时发现要下载这个样式表，但并不一定会立刻开始下载，而是可能会将它滞后一段时间再下载（等级低没人权），从 DevTools 上也可以看到 Highest 和 Lowest 的区别。如果媒体查询的样式表符合当前的页面，那么媒体查询的样式表也会阻塞关键路径渲染（就好像他是个正常的一样），同时，它的下载优先级也会恢复到最高（恢复人权）。</p> <p>media 配合 preload 能做到响应式加载资源。如下代码，分别是两副图片适配移动端与 PC 端，如果不加 preload 的话，那么其中一幅就会以 Lowest 的等级延迟加载，但是如果我们是一个移动端优先的网站，不希望用户浪费流量及网速下载PC 端的大图的话，就在每个 link 上加上 preload 即可，只有在打开网页时符合 media 的资源会被加载，不符合 media 的资源始终不会被加载，即使后面将浏览器的宽度拉宽也不会加载。</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>preload<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>bg-image-narrow.png<span class="token punctuation">&quot;</span></span> <span class="token attr-name">as</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>image<span class="token punctuation">&quot;</span></span> <span class="token attr-name">media</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>(max-width: 600px)<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>preload<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>bg-image-wide.png<span class="token punctuation">&quot;</span></span> <span class="token attr-name">as</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>image<span class="token punctuation">&quot;</span></span> <span class="token attr-name">media</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>(min-width: 601px)<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>如果用户真的拉宽了屏幕，或者切换端设备，可以使用 Window.matchMedia，来进行 media 的匹配。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> mediaQueryList <span class="token operator">=</span> window<span class="token punctuation">.</span><span class="token function">matchMedia</span><span class="token punctuation">(</span><span class="token string">&quot;(max-width: 600px)&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> header <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'header'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">if</span><span class="token punctuation">(</span>mediaQueryList<span class="token punctuation">.</span>matches<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    header<span class="token punctuation">.</span>style<span class="token punctuation">.</span>backgroundImage <span class="token operator">=</span> <span class="token string">'url(bg-image-narrow.png)'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    header<span class="token punctuation">.</span>style<span class="token punctuation">.</span>backgroundImage <span class="token operator">=</span> <span class="token string">'url(bg-image-wide.png)'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="dns-预解析"><a href="#dns-预解析" class="header-anchor">#</a> DNS 预解析</h3> <p>dns-prefetch 主要用来在用户点击一个链接之前解析对应的域名，这会自动去调用用户浏览器的解析机制。浏览器会在用户浏览网页时多线程完成预加载，当用户真正点击的时候就节省了用户等待域名解析的时间。</p> <p>Chromium 的官方文档中很详细的介绍了 pre-fetch：</p> <ul><li>Chromium 会根据页面中超链接的 href 去寻找主机名自动去 prefetch</li> <li>如果访问的链接被重定向，那么浏览器可能无法自动识别出真正的主机进行 prefetch，此时需要我么手工预加载，也就是使用 prefetch 标签来指定主机。（这也是决定是否使用 dns-prefetch 的判断方法）</li> <li>预加载不会对页面渲染造成损害，因为 Chromium 有8个专门用来预加载的线程。</li> <li>dns-prefetch 带来的网络消耗是很小的，用最小的网络开销代价可以换来较好的用户体验。</li> <li>默认情况下，Chromium 和 Firefox 出于安全考虑会关闭在 https 下的自动预加载，可以通过指定 <code>meta http-equiv</code> 来开启自动预加载。</li></ul> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>x-dns-prefetch-control<span class="token punctuation">&quot;</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>on<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>如果通过 meta 显示的关闭了预加载，之后将无法再次开启预加载。</p> <p>以上优化是一些资源加载方面的优化，下面介绍页面合成交互方面的优化：</p> <h3 id="避免重排与重绘"><a href="#避免重排与重绘" class="header-anchor">#</a> 避免重排与重绘</h3> <p>避免 DOM 的回流。也就是尽量避免重排和重绘操作。</p> <h3 id="减少-js-执行时间"><a href="#减少-js-执行时间" class="header-anchor">#</a> 减少 JS 执行时间</h3> <p>有时 JavaScript 函数的一次执行时间可能有几百毫秒，这就严重霸占了主线程执行其他渲染任务的时间。针对这种情况我们可以采用以下两种策略：</p> <ul><li>一种是将一次执行的函数分解为多个任务，使得每次的执行时间不要过久。</li> <li>另一种是采用 Web Workers。</li></ul> <h3 id="dom-操作优化"><a href="#dom-操作优化" class="header-anchor">#</a> DOM 操作优化</h3> <p>浏览器有渲染引擎和 JS 引擎，所以当用 JS 操作 DOM 时，这两个引擎要通过接口互相“交流”，因此每一次操作 DOM（包括只是访问DOM的属性），都要进行引擎之间解析的开销，所以常说要减少 DOM 操作。总结下来有以下几点：</p> <ul><li>缓存一些计算属性，如 let left = el.offsetLeft。</li> <li>通过 DOM 的 class 来集中改变样式，而不是通过 style 一条条的去修改。</li> <li>分离读写操作。现代的浏览器都有渲染队列的机制。</li> <li>放弃传统操作 DOM 的时代，基于 vue/react 等采用 virtual dom 的框架</li></ul> <h3 id="css选择器优化"><a href="#css选择器优化" class="header-anchor">#</a> CSS选择器优化</h3> <p>我们知道 CSS 引擎查找是从右向左匹配的。所以基于此有以下几条优化方案：</p> <ul><li>尽量不要使用通配符</li> <li>少用标签选择器</li> <li>尽量利用属性继承特性</li></ul> <h3 id="css属性优化"><a href="#css属性优化" class="header-anchor">#</a> CSS属性优化</h3> <p>浏览器绘制图像时，CSS 的计算也是耗费性能的，一些属性需浏览器进行大量的计算，属于昂贵的属性（box-shadows、border-radius、transforms、filters、opcity、:nth-child等），这些属性在日常开发中经常用到，所以并不是说不要用这些属性，而是在开发中，如果有其它简单可行的方案，那可以优先选择没有昂贵属性的方案。</p> <h3 id="合理利用-css-合成动画"><a href="#合理利用-css-合成动画" class="header-anchor">#</a> 合理利用 CSS 合成动画</h3> <p>合成动画是直接在合成线程上执行的，这和在主线程上执行的布局、绘制等操作不同，如果主线程被 JavaScript 或者一些布局任务占用，CSS 动画依然能继续执行。所以要尽量利用好 CSS 合成动画，如果能让 CSS 处理动画，就尽量交给 CSS 来操作。</p> <h3 id="动画使用-transform-实现"><a href="#动画使用-transform-实现" class="header-anchor">#</a> 动画使用 transform 实现</h3> <p>对于一些体验要求较高的关键动画，比如一些交互复杂的玩法页面，存在持续变化位置的 animation 元素，我们最好是使用 transform 来实现而不是通过改变 left/top 的方式。这样做的原因是，如果使用 left/top 来实现位置变化，animation 节点和 Document 将被放到了同一个 GraphicsLayer 中进行渲染，持续的动画效果将导致整个 Document 不断地执行重绘，而使用 transform 的话，能够让 animation 节点被放置到一个独立合成层中进行渲染绘制，动画发生时不会影响到其它层。并且另一方面，动画会完全运行在 GPU 上，相比起 CPU 处理图层后再发送给显卡进行显示绘制来说，这样的动画往往更加流畅。</p> <h3 id="减少隐式合成"><a href="#减少隐式合成" class="header-anchor">#</a> 减少隐式合成</h3> <p>虽然隐式合成从根本上来说是为了保证正确的图层重叠顺序，但具体到实际开发中，隐式合成很容易就导致一些无意义的合成层生成，归根结底其实就要求我们在开发时约束自己的布局习惯，避免踩坑。</p> <p>比如 z-index 属性值设置得大一些，让层叠顺序高过于页面其他无关节点就行。当然并不是盲目地设置 z-index 就能避免，有时候 z-index 也还是会导致隐式合成，这个时候可以试着调整一下文档中节点的先后顺序直接让后边的节点来覆盖前边的节点，而不用 z-index 来调整重叠关系。方法不是唯一的，具体方式还是得根据不同的页面具体分析。</p> <h3 id="避免频繁的垃圾回收"><a href="#避免频繁的垃圾回收" class="header-anchor">#</a> 避免频繁的垃圾回收</h3> <p>我们知道 JavaScript 使用了自动垃圾回收机制，如果在一些函数中频繁创建临时对象，那么垃圾回收器也会频繁地去执行垃圾回收策略。这样当垃圾回收操作发生时，就会占用主线程，从而影响到其他任务的执行，严重的话还会让用户产生掉帧、不流畅的感觉。</p> <div class="custom-block tip"><p class="custom-block-title">图层渲染优化小结</p> <p>优化渲染性能</p> <ul><li>优化 JS 的执行效率</li> <li>降低样式计算的范围和复杂度</li> <li>避免大规模、复杂的布局</li> <li>简化绘制的复杂度、减少绘制区域</li> <li>优先使用渲染层合并属性、控制层数量</li> <li>对用户输入事件的处理函数去抖动（移动设备）</li> <li>避免频繁使用 style，而是采用修改 class 的方式。</li> <li>使用 createDocumentFragment 文档碎片进行批量的 DOM 操作。</li> <li>对于 resize、scroll 等进行防抖/节流处理。</li> <li>添加 will-change: tranform ，让渲染引擎为其单独实现一个图层，当这些变换发生时，仅仅只是利用合成线程去处理这些变换，而不牵扯到主线程，大大提高渲染效率。当然这个变化不限于 tranform, 任何可以实现合成效果的 CSS 属性都能用 will-change 来声明。</li></ul> <p><a href="https://www.jianshu.com/p/a32b890c29b1" target="_blank" rel="noopener noreferrer">渲染优化<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <p>除了页面加载速度之外，还有一个特别影响用户体验的问题，就是页面的白屏，下面介绍白屏优化方案：</p> <h2 id="白屏渲染优化"><a href="#白屏渲染优化" class="header-anchor">#</a> 白屏渲染优化</h2> <p>白屏优化是前端界面体验的一个重要优化方向，Web 前端诞生了 SSR 、CSR、预渲染等技术。白屏出现的原因是因为要等待文件加载、CSSOM 构建、JS 解析等过程，而这些过程比较耗时，导致用户会长时间出于不可交互的首屏灰白屏状态，从而给用户一种网页很“慢”的感觉。</p> <table><thead><tr><th></th> <th style="text-align:left;">CSR</th> <th style="text-align:left;">预渲染</th> <th style="text-align:left;">SSR</th> <th style="text-align:left;">同构</th></tr></thead> <tbody><tr><td>优点</td> <td style="text-align:left;">不依赖数据 FP；时间最快；客户端用户体验好；内存数据共享</td> <td style="text-align:left;">不依赖数据 FCP；时间比 CSR 快；客户端用户体验好；内存数据共享</td> <td style="text-align:left;">SEO 友好首屏性能高；FMP 比 CSR 和预渲染快</td> <td style="text-align:left;">SEO 友好首屏性能高；FMP 比 CSR 和预渲染快；客户端用户体验好；内存数据共享客户端与服务端代码公用，开发效率高</td></tr> <tr><td>缺点</td> <td style="text-align:left;">SEO 不友好FCP 、FMP 慢</td> <td style="text-align:left;">SEO 不友好FMP 慢</td> <td style="text-align:left;">客户端数据共享成本高模板维护成本高</td> <td style="text-align:left;">Node 容易形成性能瓶颈</td></tr></tbody></table> <p>通过对比，同构方案集合 CSR 与 SSR 的优点，可以适用于大部分业务场景。但由于在同构的系统架构中，连接前后端的 Node 中间层处于核心链路，系统可用性的瓶颈就依赖于 Node ，一旦作为短板的 Node 挂了，整个服务都不可用。</p> <p>通过对比 FP、FCP、FMP 这三个时期 DOM 的差异，发现区别在于：</p> <ul><li>FP：仅有一个 div 根节点。</li> <li>FCP：包含页面的基本框架，但没有数据内容。</li> <li>FMP：包含页面所有元素及数据。</li></ul> <p>在 FP 的灰白屏界面停留了很长时间，用户不清楚网站是否有在正常加载，用户体验很差。
试想：如果我们可以将 FCP 或 FMP 完整的 HTML 文档提前到 FP 时机预渲染，用户看到页面框架，能感受到页面正在加载而不是冷冰冰的灰白屏，那么用户更愿意等待页面加载完成，从而降低了流失率。并且这种改观在弱网环境下更明显。</p> <p>以 Vue 为例， 在其生命周期中，mounted 对应的是 FCP，updated 对应的是 FMP。那么具体应该使用哪个生命周期的 HTML 结构呢？</p> <table><thead><tr><th></th> <th style="text-align:left;">mounted (FCP)</th> <th style="text-align:left;">updated (FMP)</th></tr></thead> <tbody><tr><td>缺点</td> <td style="text-align:left;">只是视觉体验将 FCP 提前，实际的 TTI 时间变化不大</td> <td style="text-align:left;">构建时需要获取数据，编译速度慢构建时与运行时的数据存在差异性有复杂交互的页面，仍需等待，实际的 TTI 时间变化不大</td></tr> <tr><td>优点</td> <td style="text-align:left;">不受数据影响，编译速度快</td> <td style="text-align:left;">首屏体验好对于纯展示类型的页面，FP 与 TTI 时间近乎一致</td></tr></tbody></table> <p>通过以上的对比，最终选择在 mounted 时触发构建时预渲染。由于我们采用的是 CSR 的架构，没有 Node 作为中间层，因此要实现 DOM 内容的预渲染，就需要在项目构建编译时完成对原始模板的更新替换。</p> <h3 id="服务端渲染-ssr"><a href="#服务端渲染-ssr" class="header-anchor">#</a> 服务端渲染 SSR</h3> <p>服务端渲染，服务端直出页面。在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的 html 片段直接返回给客户端这个过程就叫做服务端渲染。</p> <h4 id="服务端渲染的优点"><a href="#服务端渲染的优点" class="header-anchor">#</a> 服务端渲染的优点</h4> <ul><li>更好的 SEO： 因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；</li> <li>更快的内容到达时间（首屏加载更快）： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；</li></ul> <h4 id="服务端渲染的缺点"><a href="#服务端渲染的缺点" class="header-anchor">#</a> 服务端渲染的缺点</h4> <ul><li>更多的开发条件限制： 例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；
-更多的服务器负载：在 Node.js  中渲染完整的应用程序，显然会比仅仅提供静态文件的  server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果</li></ul> <h3 id="预渲染"><a href="#预渲染" class="header-anchor">#</a> 预渲染</h3> <p>所谓预渲染，就是在项目的构建过程中，通过一些渲染机制，比如 puppeteer或则 jsdom 将页面在构建的过程中就渲染好，然后插入到 html 中，这样在页面启动之前首先看到的就是预渲染的页面了。</p> <p>可以用 <code>prerender-spa-plugin</code> 做预渲染，这样就可以在浏览器进行渲染，而不需要将 Vue 或者 React 代码部署到服务器上。</p> <p>预渲染有什么缺点呢？</p> <ul><li>动态数据无法展示，不同的用户看到的都是同样的页面</li> <li>路由很多时，代码构建时间太长</li> <li>用户容易误操作，由于预渲染时 js 还没有加载，因此展示出来的内容没有 js 的交互逻辑，比如按钮点击，在 js 加载完成之前用户点击是没有反应的</li> <li>预加载内容很少，当页面有内容是依赖动态数据加载时，在编译时是无法加载出动态数据的，因此会导致这部分内容编译不出来</li></ul> <h3 id="骨架屏"><a href="#骨架屏" class="header-anchor">#</a> 骨架屏</h3> <p>骨架屏的实现原理和预加载类似，都是利用了 Puppeteer 爬取页面的功能，Puppeteer 是 chrome 出的一个 headlessChromenode 库，提供了 API 可以抓取 SPA 并生成预渲染内容，和预加载不太一样的是骨架屏技术会在 Puppeteer 生成内容后，利用算法将生成的内容进行替换，生成骨架页面，<code>page-skeleton-webpack-plugin</code> 是一个用来生成骨架屏的 webpack 插件。</p> <ul><li><p>CSS 属性读写分离：浏览器每次对元素样式进行读操作时，都必须进行一次重新渲染（重排 + 重绘），所以我们在使用 JS 对元素样式进行读写操作时，最好将两者分离开，先读后写，避免出现两者交叉使用的情况。最最最客观的解决方案，就是不用 JS 去操作元素样式，这也是我最推荐的。</p></li> <li><p>通过切换 class 或者 style.csstext 属性去批量操作元素样式</p></li> <li><p>DOM 元素离线更新：当对 DOM 进行相关操作时，例如 innerHTML、appendChild 等都可以使用 Document Fragment 对象进行离线操作，带元素“组装”完成后再一次插入页面，或者使用 display:none 对元素隐藏，在元素“消失”后进行相关操作。</p></li> <li><p>将没用的元素设为不可见：visibility: hidden，这样可以减小重绘的压力，必要的时候再将元素显示。</p></li> <li><p>压缩 DOM 的深度，一个渲染层内不要有过深的子元素，少用 DOM 完成页面样式，多使用伪元素或者 box-shadow 取代。</p></li> <li><p>图片在渲染前指定大小：因为 img 元素是内联元素，所以在加载图片后会改变宽高，严重的情况会导致整个页面重排，所以最好在渲染前就指定其大小，或者让其脱离文档流。</p></li> <li><p>对页面中可能发生大量重排重绘的元素单独触发渲染层，使用 GPU 分担 CPU 压力。（这项策略需要慎用，得着重考量以牺牲 GPU 占用率能否换来可期的性能优化，毕竟页面中存在太多的渲染层对与 GPU 而言也是一种不必要的压力，通常情况下，我们会对动画元素采取硬件加速。）</p></li></ul> <div class="custom-block warning"><p class="custom-block-title">参考文献</p> <p><a href="https://github.com/fi3ework/blog/issues/9" target="_blank" rel="noopener noreferrer">前端性能优化之浏览器渲染优化 —— 打造60FPS页面<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://github.com/fi3ework/blog/issues/16" target="_blank" rel="noopener noreferrer">前端性能优化之关键路径渲染优化<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://www.jianshu.com/p/a32b890c29b1" target="_blank" rel="noopener noreferrer">深度剖析浏览器渲染性能原理，你到底知道多少<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://juejin.cn/post/6844904040346681358#heading-24" target="_blank" rel="noopener noreferrer">从 8 道面试题看浏览器渲染过程与性能优化<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://juejin.cn/post/6847902219761778695#heading-14" target="_blank" rel="noopener noreferrer">聊一聊前端性能优化 CRP<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://github.com/fi3ework/blog/issues/3" target="_blank" rel="noopener noreferrer">页面生命周期：DOMContentLoaded, load, beforeunload, unload解析<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://github.com/fi3ework/blog/issues/32" target="_blank" rel="noopener noreferrer">资源提示 —— 什么是 Preload，Prefetch 和 Preconnect？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://github.com/fi3ework/blog/issues/33" target="_blank" rel="noopener noreferrer">Prefetch &amp; preconnect-dns 的优先级<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://juejin.cn/post/6844903966573068301#heading-4" target="_blank" rel="noopener noreferrer">浏览器层合成与页面渲染优化<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://juejin.cn/post/6847902219761778695#heading-15" target="_blank" rel="noopener noreferrer">聊一聊前端性能优化 CRP<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://juejin.cn/post/6844903941713428487#heading-2" target="_blank" rel="noopener noreferrer">首页白屏优化实践<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://juejin.cn/post/6844903715262955533#heading-2" target="_blank" rel="noopener noreferrer">前端黑科技：美团网页首帧优化实践<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://juejin.cn/post/6876011410061852680" target="_blank" rel="noopener noreferrer">今日头条品质优化 - 图文详情页秒开实践<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/devops/performance/webpack.html" class="prev">
        构建层面优化
      </a></span> <span class="next"><a href="/blog/devops/performance/code.html">
        代码层面优化
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----><!----><!----></div></div>
    <script src="/blog/assets/js/app.b3209530.js" defer></script><script src="/blog/assets/js/2.8bf77cff.js" defer></script><script src="/blog/assets/js/27.df70c5e4.js" defer></script><script src="/blog/assets/js/4.ff6074e9.js" defer></script>
  </body>
</html>
