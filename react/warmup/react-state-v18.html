<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>V18 - Automatic Batching | 前端那些事儿</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/blog/logo.png">
    <link rel="manifest" href="/blog/manifest.json">
    <link rel="apple-touch-icon" href="/blog/images/icons/apple-icon-152x152.png">
    <meta name="description" content="我命由我不由天，学习吧少年">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
    <meta name="msapplication-TileColor" content="#000000">
    
    <link rel="preload" href="/blog/assets/css/0.styles.7b6e3ec2.css" as="style"><link rel="preload" href="/blog/assets/js/app.592a7189.js" as="script"><link rel="preload" href="/blog/assets/js/2.dec2e75d.js" as="script"><link rel="preload" href="/blog/assets/js/1.5b9e135c.js" as="script"><link rel="preload" href="/blog/assets/js/158.30fb93be.js" as="script"><link rel="preload" href="/blog/assets/js/20.badbb211.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.cc7e09f3.js"><link rel="prefetch" href="/blog/assets/js/100.f009cb15.js"><link rel="prefetch" href="/blog/assets/js/101.44648072.js"><link rel="prefetch" href="/blog/assets/js/102.28843225.js"><link rel="prefetch" href="/blog/assets/js/103.aab0add9.js"><link rel="prefetch" href="/blog/assets/js/104.89eb0b88.js"><link rel="prefetch" href="/blog/assets/js/105.bc14ea6c.js"><link rel="prefetch" href="/blog/assets/js/106.342eddd1.js"><link rel="prefetch" href="/blog/assets/js/107.8253578a.js"><link rel="prefetch" href="/blog/assets/js/108.5872c305.js"><link rel="prefetch" href="/blog/assets/js/109.3927a3a0.js"><link rel="prefetch" href="/blog/assets/js/11.b60c9933.js"><link rel="prefetch" href="/blog/assets/js/110.58074e92.js"><link rel="prefetch" href="/blog/assets/js/111.ee401401.js"><link rel="prefetch" href="/blog/assets/js/112.04e46ffa.js"><link rel="prefetch" href="/blog/assets/js/113.f1eca1b4.js"><link rel="prefetch" href="/blog/assets/js/114.ae6f2858.js"><link rel="prefetch" href="/blog/assets/js/115.2187c5ad.js"><link rel="prefetch" href="/blog/assets/js/116.c5a70ef7.js"><link rel="prefetch" href="/blog/assets/js/117.77a4d551.js"><link rel="prefetch" href="/blog/assets/js/118.c51e9a57.js"><link rel="prefetch" href="/blog/assets/js/119.0e04fa57.js"><link rel="prefetch" href="/blog/assets/js/12.c53283e7.js"><link rel="prefetch" href="/blog/assets/js/120.cbb7c7cd.js"><link rel="prefetch" href="/blog/assets/js/121.fcb01a46.js"><link rel="prefetch" href="/blog/assets/js/122.3baf9beb.js"><link rel="prefetch" href="/blog/assets/js/123.33cd7efb.js"><link rel="prefetch" href="/blog/assets/js/124.3d747923.js"><link rel="prefetch" href="/blog/assets/js/125.0d613d02.js"><link rel="prefetch" href="/blog/assets/js/126.a06072e9.js"><link rel="prefetch" href="/blog/assets/js/127.64c144a2.js"><link rel="prefetch" href="/blog/assets/js/128.750b93e3.js"><link rel="prefetch" href="/blog/assets/js/129.7a2c1503.js"><link rel="prefetch" href="/blog/assets/js/13.6bdc6b5d.js"><link rel="prefetch" href="/blog/assets/js/130.a04a8792.js"><link rel="prefetch" href="/blog/assets/js/131.2b17bd4b.js"><link rel="prefetch" href="/blog/assets/js/132.bf2075ae.js"><link rel="prefetch" href="/blog/assets/js/133.0f5b4d94.js"><link rel="prefetch" href="/blog/assets/js/134.3836bf71.js"><link rel="prefetch" href="/blog/assets/js/135.f4634df0.js"><link rel="prefetch" href="/blog/assets/js/136.816a3fa5.js"><link rel="prefetch" href="/blog/assets/js/137.9e05f669.js"><link rel="prefetch" href="/blog/assets/js/138.00f7b353.js"><link rel="prefetch" href="/blog/assets/js/139.89855c0e.js"><link rel="prefetch" href="/blog/assets/js/14.c3201a23.js"><link rel="prefetch" href="/blog/assets/js/140.ce1eae96.js"><link rel="prefetch" href="/blog/assets/js/141.cf5a0152.js"><link rel="prefetch" href="/blog/assets/js/142.cc1d8036.js"><link rel="prefetch" href="/blog/assets/js/143.8080ae07.js"><link rel="prefetch" href="/blog/assets/js/144.5f13b5cd.js"><link rel="prefetch" href="/blog/assets/js/145.6f1f8878.js"><link rel="prefetch" href="/blog/assets/js/146.2e040907.js"><link rel="prefetch" href="/blog/assets/js/147.194143ec.js"><link rel="prefetch" href="/blog/assets/js/148.78fbcb83.js"><link rel="prefetch" href="/blog/assets/js/149.a2dec735.js"><link rel="prefetch" href="/blog/assets/js/15.a0b9e44e.js"><link rel="prefetch" href="/blog/assets/js/150.3e299256.js"><link rel="prefetch" href="/blog/assets/js/151.98ef1d9c.js"><link rel="prefetch" href="/blog/assets/js/152.9df529cd.js"><link rel="prefetch" href="/blog/assets/js/153.bbb550c8.js"><link rel="prefetch" href="/blog/assets/js/154.70fa6638.js"><link rel="prefetch" href="/blog/assets/js/155.4ea75c9c.js"><link rel="prefetch" href="/blog/assets/js/156.fa538b02.js"><link rel="prefetch" href="/blog/assets/js/157.417623cc.js"><link rel="prefetch" href="/blog/assets/js/159.a09f0412.js"><link rel="prefetch" href="/blog/assets/js/16.491191e4.js"><link rel="prefetch" href="/blog/assets/js/160.e8bf123d.js"><link rel="prefetch" href="/blog/assets/js/161.737c0f93.js"><link rel="prefetch" href="/blog/assets/js/162.4701a2c8.js"><link rel="prefetch" href="/blog/assets/js/163.eff19d1e.js"><link rel="prefetch" href="/blog/assets/js/164.7610e666.js"><link rel="prefetch" href="/blog/assets/js/165.c3c46eeb.js"><link rel="prefetch" href="/blog/assets/js/166.4956efa7.js"><link rel="prefetch" href="/blog/assets/js/167.2a6d6981.js"><link rel="prefetch" href="/blog/assets/js/168.f7c66b27.js"><link rel="prefetch" href="/blog/assets/js/169.63562a92.js"><link rel="prefetch" href="/blog/assets/js/17.89ec8c57.js"><link rel="prefetch" href="/blog/assets/js/170.0270af03.js"><link rel="prefetch" href="/blog/assets/js/171.15f185d7.js"><link rel="prefetch" href="/blog/assets/js/172.e40a0cad.js"><link rel="prefetch" href="/blog/assets/js/173.43b51a85.js"><link rel="prefetch" href="/blog/assets/js/174.dc8a48c7.js"><link rel="prefetch" href="/blog/assets/js/175.d2d2e3bf.js"><link rel="prefetch" href="/blog/assets/js/176.74ba2ca6.js"><link rel="prefetch" href="/blog/assets/js/177.4acb4a82.js"><link rel="prefetch" href="/blog/assets/js/178.27ccd449.js"><link rel="prefetch" href="/blog/assets/js/179.86b3817a.js"><link rel="prefetch" href="/blog/assets/js/18.b91f1411.js"><link rel="prefetch" href="/blog/assets/js/180.49fe9854.js"><link rel="prefetch" href="/blog/assets/js/181.d19535ba.js"><link rel="prefetch" href="/blog/assets/js/182.047049a4.js"><link rel="prefetch" href="/blog/assets/js/183.407e683c.js"><link rel="prefetch" href="/blog/assets/js/184.709831a8.js"><link rel="prefetch" href="/blog/assets/js/185.9616e4e5.js"><link rel="prefetch" href="/blog/assets/js/186.8694c50f.js"><link rel="prefetch" href="/blog/assets/js/187.b09ee5cf.js"><link rel="prefetch" href="/blog/assets/js/188.6c0ed7cf.js"><link rel="prefetch" href="/blog/assets/js/189.5d590ff0.js"><link rel="prefetch" href="/blog/assets/js/19.cb1f17c8.js"><link rel="prefetch" href="/blog/assets/js/190.1aa7c152.js"><link rel="prefetch" href="/blog/assets/js/191.8c729d92.js"><link rel="prefetch" href="/blog/assets/js/192.809b138a.js"><link rel="prefetch" href="/blog/assets/js/193.ad2cc20e.js"><link rel="prefetch" href="/blog/assets/js/194.17951bbf.js"><link rel="prefetch" href="/blog/assets/js/195.1d26bc8e.js"><link rel="prefetch" href="/blog/assets/js/196.7c3dc247.js"><link rel="prefetch" href="/blog/assets/js/197.3d792558.js"><link rel="prefetch" href="/blog/assets/js/198.aada5fe3.js"><link rel="prefetch" href="/blog/assets/js/199.b22969ef.js"><link rel="prefetch" href="/blog/assets/js/200.c25f16af.js"><link rel="prefetch" href="/blog/assets/js/201.ea0c93fc.js"><link rel="prefetch" href="/blog/assets/js/202.2f36f6c6.js"><link rel="prefetch" href="/blog/assets/js/203.2a3a5313.js"><link rel="prefetch" href="/blog/assets/js/204.0910c802.js"><link rel="prefetch" href="/blog/assets/js/205.4c98682b.js"><link rel="prefetch" href="/blog/assets/js/206.9c2c69f0.js"><link rel="prefetch" href="/blog/assets/js/207.43945140.js"><link rel="prefetch" href="/blog/assets/js/208.2aff2bce.js"><link rel="prefetch" href="/blog/assets/js/209.161593c3.js"><link rel="prefetch" href="/blog/assets/js/21.bf0041b7.js"><link rel="prefetch" href="/blog/assets/js/210.dd46aa0c.js"><link rel="prefetch" href="/blog/assets/js/22.48390d4f.js"><link rel="prefetch" href="/blog/assets/js/23.35c4ba93.js"><link rel="prefetch" href="/blog/assets/js/24.cc3b12df.js"><link rel="prefetch" href="/blog/assets/js/25.8a4f7dd6.js"><link rel="prefetch" href="/blog/assets/js/26.5c75d1ea.js"><link rel="prefetch" href="/blog/assets/js/27.26cff721.js"><link rel="prefetch" href="/blog/assets/js/28.ac3ed880.js"><link rel="prefetch" href="/blog/assets/js/29.e396a427.js"><link rel="prefetch" href="/blog/assets/js/3.cb0627fa.js"><link rel="prefetch" href="/blog/assets/js/30.694c4961.js"><link rel="prefetch" href="/blog/assets/js/31.a0b27c8d.js"><link rel="prefetch" href="/blog/assets/js/32.b677e055.js"><link rel="prefetch" href="/blog/assets/js/33.84478543.js"><link rel="prefetch" href="/blog/assets/js/34.57468f40.js"><link rel="prefetch" href="/blog/assets/js/35.ca6edaad.js"><link rel="prefetch" href="/blog/assets/js/36.3800a81e.js"><link rel="prefetch" href="/blog/assets/js/37.c950026d.js"><link rel="prefetch" href="/blog/assets/js/38.0cc2a8a2.js"><link rel="prefetch" href="/blog/assets/js/39.830d1d26.js"><link rel="prefetch" href="/blog/assets/js/4.cbb57fa7.js"><link rel="prefetch" href="/blog/assets/js/40.fa1e4cd7.js"><link rel="prefetch" href="/blog/assets/js/41.0eb4cd77.js"><link rel="prefetch" href="/blog/assets/js/42.056b5a78.js"><link rel="prefetch" href="/blog/assets/js/43.a207d5de.js"><link rel="prefetch" href="/blog/assets/js/44.821e6261.js"><link rel="prefetch" href="/blog/assets/js/45.180c14d5.js"><link rel="prefetch" href="/blog/assets/js/46.62a215f2.js"><link rel="prefetch" href="/blog/assets/js/47.b46e55c8.js"><link rel="prefetch" href="/blog/assets/js/48.e4f7f3e1.js"><link rel="prefetch" href="/blog/assets/js/49.874c0d73.js"><link rel="prefetch" href="/blog/assets/js/5.fe065607.js"><link rel="prefetch" href="/blog/assets/js/50.92bd78e3.js"><link rel="prefetch" href="/blog/assets/js/51.cf734c09.js"><link rel="prefetch" href="/blog/assets/js/52.b5171a6c.js"><link rel="prefetch" href="/blog/assets/js/53.3f2fd0d8.js"><link rel="prefetch" href="/blog/assets/js/54.8c561128.js"><link rel="prefetch" href="/blog/assets/js/55.9034dd3c.js"><link rel="prefetch" href="/blog/assets/js/56.dfc5e772.js"><link rel="prefetch" href="/blog/assets/js/57.8fdbc788.js"><link rel="prefetch" href="/blog/assets/js/58.63a8354d.js"><link rel="prefetch" href="/blog/assets/js/59.01489279.js"><link rel="prefetch" href="/blog/assets/js/6.68cda050.js"><link rel="prefetch" href="/blog/assets/js/60.63c1fc8d.js"><link rel="prefetch" href="/blog/assets/js/61.c656490a.js"><link rel="prefetch" href="/blog/assets/js/62.e1e90ca4.js"><link rel="prefetch" href="/blog/assets/js/63.0f8029d4.js"><link rel="prefetch" href="/blog/assets/js/64.69daf65d.js"><link rel="prefetch" href="/blog/assets/js/65.7b23bfe5.js"><link rel="prefetch" href="/blog/assets/js/66.04071f66.js"><link rel="prefetch" href="/blog/assets/js/67.f62c7d05.js"><link rel="prefetch" href="/blog/assets/js/68.d9dddb86.js"><link rel="prefetch" href="/blog/assets/js/69.d3d5ee70.js"><link rel="prefetch" href="/blog/assets/js/7.3b8d63a0.js"><link rel="prefetch" href="/blog/assets/js/70.aff87992.js"><link rel="prefetch" href="/blog/assets/js/71.1ff968ec.js"><link rel="prefetch" href="/blog/assets/js/72.2b219836.js"><link rel="prefetch" href="/blog/assets/js/73.6dc5f3db.js"><link rel="prefetch" href="/blog/assets/js/74.30f7ec1e.js"><link rel="prefetch" href="/blog/assets/js/75.4187dd8f.js"><link rel="prefetch" href="/blog/assets/js/76.169e2ac1.js"><link rel="prefetch" href="/blog/assets/js/77.f842d2c7.js"><link rel="prefetch" href="/blog/assets/js/78.d02f1ff6.js"><link rel="prefetch" href="/blog/assets/js/79.c10fb69e.js"><link rel="prefetch" href="/blog/assets/js/80.12567dbe.js"><link rel="prefetch" href="/blog/assets/js/81.985b8f42.js"><link rel="prefetch" href="/blog/assets/js/82.4f7950ce.js"><link rel="prefetch" href="/blog/assets/js/83.e66b6beb.js"><link rel="prefetch" href="/blog/assets/js/84.6993f55e.js"><link rel="prefetch" href="/blog/assets/js/85.cfe8905d.js"><link rel="prefetch" href="/blog/assets/js/86.0b4102e0.js"><link rel="prefetch" href="/blog/assets/js/87.cb9427a3.js"><link rel="prefetch" href="/blog/assets/js/88.d3bd696a.js"><link rel="prefetch" href="/blog/assets/js/89.d24d59f3.js"><link rel="prefetch" href="/blog/assets/js/90.53ba9b76.js"><link rel="prefetch" href="/blog/assets/js/91.edbd8ef7.js"><link rel="prefetch" href="/blog/assets/js/92.9bb1cc7e.js"><link rel="prefetch" href="/blog/assets/js/93.2f81f8f5.js"><link rel="prefetch" href="/blog/assets/js/94.58f0719a.js"><link rel="prefetch" href="/blog/assets/js/95.2a0c4724.js"><link rel="prefetch" href="/blog/assets/js/96.5f3a1452.js"><link rel="prefetch" href="/blog/assets/js/97.7c5f2609.js"><link rel="prefetch" href="/blog/assets/js/98.c95f69c1.js"><link rel="prefetch" href="/blog/assets/js/99.a359b4b7.js"><link rel="prefetch" href="/blog/assets/js/vendors~docsearch.bd3cdb54.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.7b6e3ec2.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/logo.png" alt="前端那些事儿" class="logo"> <span class="site-name can-hide">前端那些事儿</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/blog/base/" class="nav-link">
  前端基础
</a></div><div class="nav-item"><a href="/blog/vue/" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/blog/react/" class="nav-link router-link-active">
  React
</a></div><div class="nav-item"><a href="/blog/node/" class="nav-link">
  Node
</a></div><div class="nav-item"><a href="/blog/devops/" class="nav-link">
  前端工程化
</a></div><div class="nav-item"><a href="/blog/mobile/" class="nav-link">
  泛客户端
</a></div><div class="nav-item"><a href="/blog/architecture/" class="nav-link">
  架构&amp;方案
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="GitHub" class="dropdown-title"><span class="title">GitHub</span> <span class="arrow down"></span></button> <button type="button" aria-label="GitHub" class="mobile-dropdown-title"><span class="title">GitHub</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/jonny-wei" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/jonny-wei/sushi-js" target="_blank" rel="noopener noreferrer" class="nav-link external">
  JS 寿司
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/blog/base/" class="nav-link">
  前端基础
</a></div><div class="nav-item"><a href="/blog/vue/" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/blog/react/" class="nav-link router-link-active">
  React
</a></div><div class="nav-item"><a href="/blog/node/" class="nav-link">
  Node
</a></div><div class="nav-item"><a href="/blog/devops/" class="nav-link">
  前端工程化
</a></div><div class="nav-item"><a href="/blog/mobile/" class="nav-link">
  泛客户端
</a></div><div class="nav-item"><a href="/blog/architecture/" class="nav-link">
  架构&amp;方案
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="GitHub" class="dropdown-title"><span class="title">GitHub</span> <span class="arrow down"></span></button> <button type="button" aria-label="GitHub" class="mobile-dropdown-title"><span class="title">GitHub</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/jonny-wei" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/jonny-wei/sushi-js" target="_blank" rel="noopener noreferrer" class="nav-link external">
  JS 寿司
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>React</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/react/" aria-current="page" class="sidebar-link">React JSX</a></li><li><a href="/blog/react/warmup/react-component.html" class="sidebar-link">React 组件及通信</a></li><li><a href="/blog/react/warmup/react-state.html" class="sidebar-link">React State</a></li><li><a href="/blog/react/warmup/react-props.html" class="sidebar-link">React Props</a></li><li><a href="/blog/react/warmup/react-lifecycle.html" class="sidebar-link">React 生命周期</a></li><li><a href="/blog/react/warmup/react-ref.html" class="sidebar-link">React Ref</a></li><li><a href="/blog/react/warmup/react-context.html" class="sidebar-link">React Context</a></li><li><a href="/blog/react/warmup/react-css.html" class="sidebar-link">React 中 CSS 的模块化</a></li><li><a href="/blog/react/warmup/react-hoc.html" class="sidebar-link">React HOC</a></li><li><a href="/blog/react/warmup/react-render.html" class="sidebar-link">React 渲染优化</a></li><li><a href="/blog/react/warmup/react-router.html" class="sidebar-link">React Router</a></li><li><a href="/blog/react/warmup/react-redux.html" class="sidebar-link">React Rudex</a></li><li><a href="/blog/react/warmup/react-mobx.html" class="sidebar-link">React Mobx</a></li><li><a href="/blog/react/warmup/react-keepalive.html" class="sidebar-link">实现 KeepAlive</a></li><li><a href="/blog/react/warmup/react-state-v18.html" aria-current="page" class="active sidebar-link">V18 - Automatic Batching</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/react/warmup/react-state-v18.html#批量更新" class="sidebar-link">批量更新</a></li><li class="sidebar-sub-header"><a href="/blog/react/warmup/react-state-v18.html#更新原理" class="sidebar-link">更新原理</a></li></ul></li><li><a href="/blog/react/warmup/react-transition.html" class="sidebar-link">V18 - Transition</a></li><li><a href="/blog/react/warmup/react-suspense.html" class="sidebar-link">V18 - Suspense</a></li><li><a href="/blog/react/warmup/react-useSyncExternalStore.html" class="sidebar-link">V18 - useSyncExternalStore</a></li><li><a href="/blog/react/warmup/react-ssr.html" class="sidebar-link">V18 - Streaming SSR</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>React源码解析</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/react/react/react-reconciler.html" class="sidebar-link">Reconciler 调和器</a></li><li><a href="/blog/react/react/react-priority.html" class="sidebar-link">React 优先级管理</a></li><li><a href="/blog/react/react/react-scheduler.html" class="sidebar-link">Scheduler 调度器</a></li><li><a href="/blog/react/react/react-render.html" class="sidebar-link">Render 阶段</a></li><li><a href="/blog/react/react/react-commit.html" class="sidebar-link">Commit 阶段</a></li><li><a href="/blog/react/react/react-diff.html" class="sidebar-link">React Diff 算法</a></li><li><a href="/blog/react/react/react-hooks.html" class="sidebar-link">React Hooks 理解</a></li><li><a href="/blog/react/react/react-context.html" class="sidebar-link">React Context 原理</a></li><li><a href="/blog/react/react/react-event.html" class="sidebar-link">React 事件系统</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="v18-automatic-batching"><a href="#v18-automatic-batching" class="header-anchor">#</a> V18 - Automatic Batching</h1> <p>在 React State 章节介绍了在 legacy 模式下的 state 更新流程，这种模式下的批量更新原理本质上是通过不同的更新上下文开关 Context ，比如 batch 或者 event 来让更新变成<strong>可控的</strong>。那么在 <code>v18 concurrent</code> 下 React 的更新又有哪些特点呢？</p> <p>在了解 <code>v18 concurrent</code> 之前，先来看一下主流框架中两种批量更新的原理：</p> <ul><li>微任务、宏任务实现集中更新</li> <li>可控任务实现批量更新</li></ul> <h2 id="批量更新"><a href="#批量更新" class="header-anchor">#</a> 批量更新</h2> <h3 id="微任务、宏任务实现集中更新"><a href="#微任务、宏任务实现集中更新" class="header-anchor">#</a> 微任务、宏任务实现集中更新</h3> <p>试想一下，比如每次更新，我们先并不去立即执行更新任务，而是先把每一个更新任务放入一个待更新队列 <code>updateQueue</code> 里面，然后 js 执行完毕，用一个微任务统一去批量更新队列里面的任务，如果微任务存在兼容性，那么降级成一个宏任务。这里<strong>优先采用微任务</strong>的原因就是微任务的执行时机要早于下一次宏任务的执行。</p> <p>这种在微任务、宏任务实现集中更新典型的案例就是 vue 更新原理，<code>vue.$nextTick</code>原理 ，还有接下来要介绍的 v18 中 <code>scheduleMicrotask</code> 的更新原理。</p> <p><img src="/blog/images/react/v18-state1.png" alt="v18-state1"></p> <p>模拟一下整个流程的实现。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Scheduler</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>callbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token comment">/* 微任务批量处理 */</span>
        <span class="token function">queueMicrotask</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">runTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/* 增加任务 */</span>
    <span class="token function">addTask</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>callbacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">runTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'------合并更新开始------'</span><span class="token punctuation">)</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>callbacks<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">const</span> cur <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>callbacks<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token function">cur</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'------合并更新结束------'</span><span class="token punctuation">)</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'------开始更新组件------'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token parameter">cb</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">const</span> scheduler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">cb</span><span class="token punctuation">(</span>scheduler<span class="token punctuation">.</span><span class="token function">addTask</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>scheduler<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 模拟一次更新 */</span>
<span class="token keyword">function</span> <span class="token function">mockOnclick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">add</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
       <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
           console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'第一次更新'</span><span class="token punctuation">)</span>
       <span class="token punctuation">}</span><span class="token punctuation">)</span>
       console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'----宏任务逻辑----'</span><span class="token punctuation">)</span>
       <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'第二次更新'</span><span class="token punctuation">)</span>
       <span class="token punctuation">}</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">mockOnclick</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// ----宏任务逻辑---- -&gt; ------合并更新开始------ -&gt; 第一次更新 -&gt; 第二次更新 -&gt; ------合并更新结束------</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br></div></div><p>模拟一下具体实现细节：</p> <ul><li>通过一个 Scheduler 调度器来完成整个流程。</li> <li>通过 addTask 每次向队列中放入任务。</li> <li>用 queueMicrotask 创建一个微任务，来统一处理这些任务。</li> <li>mockOnclick 模拟一次更新。我们用 nextTick 来模拟一下更新函数的处理逻辑。</li></ul> <h3 id="可控任务实现批量更新"><a href="#可控任务实现批量更新" class="header-anchor">#</a> 可控任务实现批量更新</h3> <p>通过拦截把任务变成<strong>可控的</strong>，典型的就是 React v17 之前的 batchEventUpdate 批量更新，。这种情况的更新来源于对事件进行拦截，比如 React 的事件系统。以 React 的事件批量更新为例子，比如我们的 onClick ，onChange 事件都是被 React 的事件系统处理的。外层用一个统一的处理函数进行拦截。而我们绑定的事件都是在该函数的执行上下文内部被调用的。</p> <p>那么比如在一次点击事件中触发了多次更新。本质上外层在 React 事件系统处理函数的上下文中，这样的情况下，就可以通过一个开关，证明当前更新是可控的，可以做批量处理。接下来 React 就用一次就可以了。</p> <p><img src="/blog/images/react/v18-state2.png" alt="v18-state2"></p> <p>模拟一下具体的实现：</p> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">  
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token special-attr"><span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token value javascript language-javascript"><span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token punctuation">&quot;</span></span></span> <span class="token punctuation">&gt;</span></span><span class="token plain-text">点击</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
  let  batchEventUpdate = false 
  let callbackQueue = []

  function flushSyncCallbackQueue(){
      console.log('-----执行批量更新-------')
      while(callbackQueue.length &gt; 0 ){
          const cur = callbackQueue.shift()
          cur()
      }
      console.log('-----批量更新结束-------')
  }

  function wrapEvent(fn){
     return function (){
         /* 开启批量更新状态 */
        batchEventUpdate = true
        fn()
        /* 立即执行更新任务 */
        flushSyncCallbackQueue()
        /* 关闭批量更新状态 */
        batchEventUpdate = false
     }
  }

  function setState(fn){
      /* 如果在批量更新状态下，那么批量更新 */
      if(batchEventUpdate){
          callbackQueue.push(fn)
      }else{
          /* 如果没有在批量更新条件下，那么直接更新。 */
          fn()
      }
  }

  function handleClick(){
      setState(()=&gt;{
          console.log('---更新1---')
      })
      console.log('上下文执行')
      setState(()=&gt;{
          console.log('---更新2---')
      })
  }
  /* 让 handleClick 变成可控的  */
  handleClick = wrapEvent(handleClick)
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token comment">// 上下文执行 -&gt; -----执行批量更新------- -&gt; ---更新1--- -&gt; ---更新2--- -&gt; -----批量更新结束-------</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br></div></div><ul><li>本方式的核心就是让 handleClick 通过 wrapEvent 变成可控的。首先 wrapEvent 类似于事件处理函数，在内部通过开关 batchEventUpdate 来判断是否开启批量更新状态，最后通过 flushSyncCallbackQueue 来清空待更新队列。</li> <li>在批量更新条件下，事件会被放入到更新队列中，非批量更新条件下，那么立即执行更新任务。</li></ul> <h3 id="与传统-legacy-模式的区别"><a href="#与传统-legacy-模式的区别" class="header-anchor">#</a> 与传统 legacy 模式的区别</h3> <p>首先对于传统的 legacy 模式，有可控任务批量处理的概念，也就是采用了上面第二种批量更新模式：</p> <ul><li>通过不同的更新上下文开关，在开关里的任务是可控的，可以进行批量处理。</li> <li>在事件之行完毕后，通过 <code>flushSyncCallback</code> 来进行更新任务之行。</li></ul> <p>那么在 concurrent 模式下的更新采用了一个什么方式呢？首先在这种模式下，取消了批量更新的感念。我们以事件系统的更新例子，研究一下两种的区别。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// react-dom/src/events/ReactDOMUpdateBatching.js</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">batchedEventUpdates</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span>a</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    isBatchingEventUpdates <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">//打开批量更新开关</span>
    <span class="token keyword">try</span><span class="token punctuation">{</span>
       <span class="token function">fn</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>  <span class="token comment">// 事件在这里执行</span>
    <span class="token punctuation">}</span><span class="token keyword">finally</span><span class="token punctuation">{</span>
        isBatchingEventUpdates <span class="token operator">=</span> <span class="token boolean">false</span> <span class="token comment">//关闭批量更新开关</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>executionContext <span class="token operator">===</span> NoContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">flushSyncCallbackQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// TODO: 这个很重要，用来同步执行更新队列中的任务</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><ul><li>通过开关 <code>isBatchingEventUpdates</code> 来让 fn 里面的更新变成可控的，所以可以进行批量更新。</li> <li>重点就是 <code>flushSyncCallbackQueue</code> 用来同步执行更新队列中的任务。</li></ul> <p>在最新版本的 v18 alpha 系统中，事件变成了这样 ：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">batchedEventUpdates</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> prevExecutionContext <span class="token operator">=</span> executionContext<span class="token punctuation">;</span>
    executionContext <span class="token operator">|=</span> EventContext<span class="token punctuation">;</span>  <span class="token comment">// 运算赋值</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 执行函数</span>
    <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>
        executionContext <span class="token operator">=</span> prevExecutionContext<span class="token punctuation">;</span> <span class="token comment">// 重置之前的状态</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>executionContext <span class="token operator">===</span> NoContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">flushSyncCallbacksOnlyInLegacyMode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 同步执行更新队列中的任务</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>从上述代码中可以清晰的看到，v18 alpha 版本的流程大致是这样的：</p> <ul><li>也是通过类似开关状态来控制的，在刚开始的时候将赋值给 <code>EventContext</code> ，然后在事件执行之后，赋值给 <code>prevExecutionContext</code>。</li> <li>之后同样会触发 flushSyncCallbacksOnlyInLegacyMode ，不过通过函数名称就可以大胆猜想，这个方法主要是针对 legacy 模式的更新，那么 concurrent mode 下也就不会走 flushSyncCallback 的逻辑了。</li></ul> <p>再看一下 <code>flushSyncCallbacksOnlyInLegacyMode</code> 做了些什么事：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// react-reconciler/src/ReactFiberSyncTaskQueue.js</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">flushSyncCallbacksOnlyInLegacyMode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>includesLegacySyncCallbacks<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">/* 只有在 legacy 模式下，才会走这里的流程。 */</span>
        <span class="token function">flushSyncCallbacks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>结论：<strong>只有在 legacy 模式下，才会执行 flushSyncCallbacks 来同步执行任务。</strong> flushSyncCallbacks 主要作用是，能够在一次更新中，直接同步更新任务，防止任务在下一次的宏任务中执行。</p> <p>那么对于 concurrent 下的更新流程是怎么样的呢？一次更新 state 会发生什么？</p> <h2 id="更新原理"><a href="#更新原理" class="header-anchor">#</a> 更新原理</h2> <p>在了解更新原理之前，先了解以下 v18 中新增的API  <code>ReactDOM.createRoot()</code>，只要使用<code>ReactDOM.createRoot()</code> 方法，就能<strong>直接享受自动 batching 的能力</strong>。</p> <h3 id="createroot"><a href="#createroot" class="header-anchor">#</a> createRoot</h3> <p>在 React18 中， <code>ReactDOM.render()</code> 正式成为 Legacy，并增加了新的 API  <code>ReactDOM.createRoot()</code> ，他们的用法差别如下：</p> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token keyword">import</span> ReactDOM from ‘react<span class="token operator">-</span>dom’<span class="token punctuation">;</span>
<span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">'App'</span><span class="token punctuation">;</span>

ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">App</span></span> <span class="token punctuation">/&gt;</span></span><span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// v18 - createRoot</span>
<span class="token keyword">import</span> ReactDOM from ‘react<span class="token operator">-</span>dom’<span class="token punctuation">;</span>
<span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">'App'</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> root <span class="token operator">=</span> ReactDOM<span class="token punctuation">.</span><span class="token function">createRoot</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

root<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">App</span></span> <span class="token punctuation">/&gt;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>通过新的 API，我们可以为一个 React App <strong>创建多个根节点</strong>，甚至在未来可以<strong>用不同版本的 React 来创建</strong>。React18 保留了上述两种用法，老项目不想改仍然可以用 <code>ReactDOM.render()</code> ；新项目想提升性能，可以用  <code>ReactDOM.createRoot()</code> 且可借并发渲染的好处。</p> <h3 id="什么是-automatic-batching"><a href="#什么是-automatic-batching" class="header-anchor">#</a> 什么是 Automatic Batching</h3> <p>为了使应用获得更好的性能，React把多次的状态更新（state updates），合并到一次渲染中。 React17 只会把浏览器事件（如点击）发生期间的状态更新合并掉。而 React18 会把事件处理器发生后的状态更新也合并掉。</p> <p>batching 是安全的，但也存在一些特殊情况不希望 batching 发生，比如：你需要在状态更新后，立刻读取新 DOM 上的数据等。这种情况下请使用 <code>ReactDOM.flushSync()</code></p> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> flushSync <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react-dom'</span><span class="token punctuation">;</span> <span class="token comment">// Note: react-dom, not react</span>

<span class="token keyword">function</span> <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">flushSync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setCounter</span><span class="token punctuation">(</span><span class="token parameter">c</span> <span class="token operator">=&gt;</span> c <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// React has updated the DOM by now</span>
  <span class="token function">flushSync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setFlag</span><span class="token punctuation">(</span><span class="token parameter">f</span> <span class="token operator">=&gt;</span> <span class="token operator">!</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// React has updated the DOM by now</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>那么 Automatic Batching 对 Hooks/Classes 有什么影响呢？</p> <ul><li>对 Hooks 没有任何影响</li> <li>对 classes 大部分情况下没影响，关注一种模式：是否在两次 setState 之间读取了state 值。差异如下：</li></ul> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token function-variable function">handleClick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> count <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">count</span><span class="token operator">:</span> count <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 在 React17 及之前，打印出来是 { count: 1, flag: false }</span>
    <span class="token comment">// 在 React18，打印出来是 { count: 0, flag: false }</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> flag <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">flag</span><span class="token operator">:</span> <span class="token operator">!</span>flag <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>如果不想通过调整代码逻辑的方式进行修正，可以直接采用 <code>ReactDOM.flushSync()</code> :</p> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token function-variable function">handleClick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    ReactDOM<span class="token punctuation">.</span><span class="token function">flushSync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> count <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">count</span><span class="token operator">:</span> count <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 在 React18，打印出来是 { count: 1, flag: false }</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> flag <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">flag</span><span class="token operator">:</span> <span class="token operator">!</span>flag <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h3 id="更新原理-2"><a href="#更新原理-2" class="header-anchor">#</a> 更新原理</h3> <p>无论是那种条件下，只要触发 React 的 <code>setState</code> 或者 <code>useState</code>，最终进入调度任务开始更新的入口函数都是 <code>ensureRootIsScheduled</code> :</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// react-reconciler/src/ReactFiberWorkLoop.js -&gt; ensureRootIsScheduled</span>
<span class="token keyword">function</span> <span class="token function">ensureRootIsScheduled</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">,</span>currentTime</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> existingCallbackNode <span class="token operator">=</span> root<span class="token punctuation">.</span>callbackNode<span class="token punctuation">;</span>

    <span class="token keyword">var</span> newCallbackPriority <span class="token operator">=</span> <span class="token function">getHighestPriorityLane</span><span class="token punctuation">(</span>nextLanes<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">var</span> existingCallbackPriority <span class="token operator">=</span> root<span class="token punctuation">.</span>callbackPriority<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>existingCallbackPriority <span class="token operator">===</span> newCallbackPriority <span class="token operator">&amp;&amp;</span> 
    <span class="token operator">!</span><span class="token punctuation">(</span> ReactCurrentActQueue<span class="token punctuation">.</span>current <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> existingCallbackNode <span class="token operator">!==</span> fakeActCallbackNode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/* 批量更新退出* */</span>  
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">/* 同步更新条件下，会走这里的逻辑 */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCallbackPriority <span class="token operator">===</span> SyncLane<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">scheduleSyncCallback</span><span class="token punctuation">(</span><span class="token function">performSyncWorkOnRoot</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">/* 用微任务去立即执行更新  */</span>
        <span class="token function">scheduleMicrotask</span><span class="token punctuation">(</span>flushSyncCallbacks<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
        newCallbackNode <span class="token operator">=</span> <span class="token function">scheduleCallback</span><span class="token punctuation">(</span>
            schedulerPriorityLevel<span class="token punctuation">,</span>
            <span class="token function">performConcurrentWorkOnRoot</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/* 这里很重要就是给当前 root 赋予 callbackPriority 和 callbackNode 状态 */</span>
    root<span class="token punctuation">.</span>callbackPriority <span class="token operator">=</span> newCallbackPriority<span class="token punctuation">;</span>
    root<span class="token punctuation">.</span>callbackNode <span class="token operator">=</span> newCallbackNode<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><h4 id="同步条件下的逻辑"><a href="#同步条件下的逻辑" class="header-anchor">#</a> 同步条件下的逻辑</h4> <p>首先我们来看一下，同步更新的逻辑，上面讲到在 concurrent 中已经没有可控任务那一套逻辑。所以核心更新流程如下：</p> <p>当同步状态下触发多次 useState 的时候：</p> <ul><li>首先第一次进入到 <code>ensureRootIsScheduled</code> ，会计算出 <code>newCallbackPriority</code> 可以理解成执行新的更新任务的优先级。那么和之前的 <code>callbackPriority</code> 进行对比，如果相等那么退出流程，那么第一次两者肯定是不想等的。</li> <li>同步状态下常规的更新 <code>newCallbackPriority</code> 是等于 <code>SyncLane</code> 的，那么会执行两个函数，<code>scheduleSyncCallback</code> 和 <code>scheduleMicrotask</code>。</li></ul> <p><code>scheduleSyncCallback</code> 会把任务 <code>syncQueue</code> 同步更新队列中。来看一下这个函数：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// react-reconciler/src/ReactFiberSyncTaskQueue.js -&gt; scheduleSyncCallback</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">scheduleSyncCallback</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">callback</span><span class="token operator">:</span> SchedulerCallback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>syncQueue <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    syncQueue <span class="token operator">=</span> <span class="token punctuation">[</span>callback<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    syncQueue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><div class="custom-block tip"><p class="custom-block-title">注意</p> <p>接下来就是 concurrent 下更新的区别了。在老版本的 React 是基于事件处理函数执行的 <code>flushSyncCallbacks</code> ，而新版本 React 是通过 <code>scheduleMicrotask</code> 执行的。</p></div> <p>我们看一下 <code>scheduleMicrotask</code> 到底是什么？</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// react-reconciler/src/ReactFiberHostConfig.js -&gt; scheduleMicrotask</span>
<span class="token keyword">var</span> scheduleMicrotask <span class="token operator">=</span> <span class="token keyword">typeof</span> queueMicrotask <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">?</span> queueMicrotask <span class="token operator">:</span> <span class="token keyword">typeof</span> Promise <span class="token operator">!==</span> <span class="token string">'undefined'</span> <span class="token operator">?</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span>handleErrorInNextTick<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token operator">:</span> scheduleTimeout<span class="token punctuation">;</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><code>scheduleMicrotask</code> 本质上就是 <code>Promise.resolve</code> ，还有一个 <code>setTimeout</code> 向下兼容的情况。通过 <code>scheduleMicrotask</code> 去进行调度更新。</p> <p>那么如果发生第二次 <code>useState</code> ，则会出现 <code>existingCallbackPriority === newCallbackPriority</code> 的情况，接下来就会 return 退出更新流程了。</p> <h4 id="异步条件下的逻辑"><a href="#异步条件下的逻辑" class="header-anchor">#</a> 异步条件下的逻辑</h4> <p>在异步情况下，比如在 <code>setTimeout</code> 或者是 <code>Promise.resolve</code> 条件下的更新，会走哪些逻辑呢？</p> <ul><li>第一步也会判断 <code>existingCallbackPriority === newCallbackPriority</code> 是否相等，相等则退出。</li> <li>第二步则就有点区别了。会直接执行 <code>scheduleCallback</code> ，然后得到最新的 <code>newCallbackNode</code>，并赋值给 root 。</li> <li>接下来第二次 <code>useState</code> ，同样会 return 跳出 <code>ensureRootIsScheduled</code> 。</li></ul> <p>看一下 <code>scheduleCallback</code> 做了哪些事。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// react-reconciler/src/ReactFiberWorkLoop.js -&gt; scheduleCallback</span>
<span class="token keyword">function</span> <span class="token function">scheduleCallback</span><span class="token punctuation">(</span><span class="token parameter">priorityLevel<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> actQueue <span class="token operator">=</span> ReactCurrentActQueue<span class="token punctuation">.</span>current<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>actQueue <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      actQueue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> fakeActCallbackNode<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">scheduleCallback</span><span class="token punctuation">(</span>priorityLevel<span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>最后用一幅流程图描述一下流程：</p> <p><img src="/blog/images/react/v18-state3.png" alt="v18-state3"></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/react/warmup/react-keepalive.html" class="prev">
        实现 KeepAlive
      </a></span> <span class="next"><a href="/blog/react/warmup/react-transition.html">
        V18 - Transition
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----><!----><!----></div></div>
    <script src="/blog/assets/js/app.592a7189.js" defer></script><script src="/blog/assets/js/2.dec2e75d.js" defer></script><script src="/blog/assets/js/1.5b9e135c.js" defer></script><script src="/blog/assets/js/158.30fb93be.js" defer></script><script src="/blog/assets/js/20.badbb211.js" defer></script>
  </body>
</html>
