<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>V18 - Automatic Batching | 前端那些事儿</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/blog/logo.png">
    <link rel="manifest" href="/blog/manifest.json">
    <link rel="apple-touch-icon" href="/blog/images/icons/apple-icon-152x152.png">
    <meta name="description" content="我命由我不由天，学习吧少年">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
    <meta name="msapplication-TileColor" content="#000000">
    
    <link rel="preload" href="/blog/assets/css/0.styles.329e1c2e.css" as="style"><link rel="preload" href="/blog/assets/js/app.3fadfb99.js" as="script"><link rel="preload" href="/blog/assets/js/2.8bf77cff.js" as="script"><link rel="preload" href="/blog/assets/js/136.ff41831c.js" as="script"><link rel="preload" href="/blog/assets/js/4.ff6074e9.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.2e1f1296.js"><link rel="prefetch" href="/blog/assets/js/100.8ac8cdbc.js"><link rel="prefetch" href="/blog/assets/js/101.aee2b8c0.js"><link rel="prefetch" href="/blog/assets/js/102.c45d0ab0.js"><link rel="prefetch" href="/blog/assets/js/103.55d03437.js"><link rel="prefetch" href="/blog/assets/js/104.f80d61a8.js"><link rel="prefetch" href="/blog/assets/js/105.4830356c.js"><link rel="prefetch" href="/blog/assets/js/106.a2ed4cbe.js"><link rel="prefetch" href="/blog/assets/js/107.14a8c6ff.js"><link rel="prefetch" href="/blog/assets/js/108.29dcdcad.js"><link rel="prefetch" href="/blog/assets/js/109.ed3ad5de.js"><link rel="prefetch" href="/blog/assets/js/11.423e07d5.js"><link rel="prefetch" href="/blog/assets/js/110.7dfde934.js"><link rel="prefetch" href="/blog/assets/js/111.11760cd5.js"><link rel="prefetch" href="/blog/assets/js/112.64fd31e7.js"><link rel="prefetch" href="/blog/assets/js/113.6e607dd1.js"><link rel="prefetch" href="/blog/assets/js/114.0d59c206.js"><link rel="prefetch" href="/blog/assets/js/115.a65d839e.js"><link rel="prefetch" href="/blog/assets/js/116.79ecc0ca.js"><link rel="prefetch" href="/blog/assets/js/117.80adbafb.js"><link rel="prefetch" href="/blog/assets/js/118.5860f134.js"><link rel="prefetch" href="/blog/assets/js/119.27520fb2.js"><link rel="prefetch" href="/blog/assets/js/12.a29783e3.js"><link rel="prefetch" href="/blog/assets/js/120.ca4462e8.js"><link rel="prefetch" href="/blog/assets/js/121.0fedffee.js"><link rel="prefetch" href="/blog/assets/js/122.c5f2e267.js"><link rel="prefetch" href="/blog/assets/js/123.60b1183f.js"><link rel="prefetch" href="/blog/assets/js/124.c85e571d.js"><link rel="prefetch" href="/blog/assets/js/125.2ce564a2.js"><link rel="prefetch" href="/blog/assets/js/126.57179830.js"><link rel="prefetch" href="/blog/assets/js/127.eba05af9.js"><link rel="prefetch" href="/blog/assets/js/128.d02d115e.js"><link rel="prefetch" href="/blog/assets/js/129.137859bf.js"><link rel="prefetch" href="/blog/assets/js/13.0a0a8660.js"><link rel="prefetch" href="/blog/assets/js/130.15698453.js"><link rel="prefetch" href="/blog/assets/js/131.c6af0ef1.js"><link rel="prefetch" href="/blog/assets/js/132.df0e87ae.js"><link rel="prefetch" href="/blog/assets/js/133.559a8ff5.js"><link rel="prefetch" href="/blog/assets/js/134.969af9a8.js"><link rel="prefetch" href="/blog/assets/js/135.a5e55ce8.js"><link rel="prefetch" href="/blog/assets/js/137.c2c76065.js"><link rel="prefetch" href="/blog/assets/js/138.6a7b69e5.js"><link rel="prefetch" href="/blog/assets/js/139.d99f7f2c.js"><link rel="prefetch" href="/blog/assets/js/14.89bb6d33.js"><link rel="prefetch" href="/blog/assets/js/140.6bb0993e.js"><link rel="prefetch" href="/blog/assets/js/141.5f33ca9e.js"><link rel="prefetch" href="/blog/assets/js/142.fe7960b3.js"><link rel="prefetch" href="/blog/assets/js/143.bd329147.js"><link rel="prefetch" href="/blog/assets/js/144.da409c18.js"><link rel="prefetch" href="/blog/assets/js/145.d7804b81.js"><link rel="prefetch" href="/blog/assets/js/146.f42159d2.js"><link rel="prefetch" href="/blog/assets/js/147.ea18f004.js"><link rel="prefetch" href="/blog/assets/js/148.5c91fde6.js"><link rel="prefetch" href="/blog/assets/js/149.2656f9e9.js"><link rel="prefetch" href="/blog/assets/js/15.9c15f645.js"><link rel="prefetch" href="/blog/assets/js/150.20abb057.js"><link rel="prefetch" href="/blog/assets/js/151.eca0b8b7.js"><link rel="prefetch" href="/blog/assets/js/152.47b6a10b.js"><link rel="prefetch" href="/blog/assets/js/153.0e54d6fd.js"><link rel="prefetch" href="/blog/assets/js/154.24b843b3.js"><link rel="prefetch" href="/blog/assets/js/155.f4fc6d20.js"><link rel="prefetch" href="/blog/assets/js/156.017df8ca.js"><link rel="prefetch" href="/blog/assets/js/157.a3263d57.js"><link rel="prefetch" href="/blog/assets/js/158.3329d7f5.js"><link rel="prefetch" href="/blog/assets/js/159.a7caba92.js"><link rel="prefetch" href="/blog/assets/js/16.135dcaf5.js"><link rel="prefetch" href="/blog/assets/js/160.6a6e8ec8.js"><link rel="prefetch" href="/blog/assets/js/161.afa62aa5.js"><link rel="prefetch" href="/blog/assets/js/162.71d828b5.js"><link rel="prefetch" href="/blog/assets/js/163.c88692f1.js"><link rel="prefetch" href="/blog/assets/js/164.8251bf67.js"><link rel="prefetch" href="/blog/assets/js/165.e2875702.js"><link rel="prefetch" href="/blog/assets/js/166.e8e1e6e6.js"><link rel="prefetch" href="/blog/assets/js/167.ef2059fb.js"><link rel="prefetch" href="/blog/assets/js/168.cdc23b02.js"><link rel="prefetch" href="/blog/assets/js/169.2eefab1b.js"><link rel="prefetch" href="/blog/assets/js/17.6f58cfd1.js"><link rel="prefetch" href="/blog/assets/js/170.ce3fa57a.js"><link rel="prefetch" href="/blog/assets/js/171.2fff6416.js"><link rel="prefetch" href="/blog/assets/js/172.2b2d7eb7.js"><link rel="prefetch" href="/blog/assets/js/173.61637ed5.js"><link rel="prefetch" href="/blog/assets/js/174.c97e4800.js"><link rel="prefetch" href="/blog/assets/js/175.eff3398b.js"><link rel="prefetch" href="/blog/assets/js/176.dd941595.js"><link rel="prefetch" href="/blog/assets/js/177.90e9b27b.js"><link rel="prefetch" href="/blog/assets/js/178.51484ab5.js"><link rel="prefetch" href="/blog/assets/js/179.ea1cfce8.js"><link rel="prefetch" href="/blog/assets/js/18.11e73e23.js"><link rel="prefetch" href="/blog/assets/js/180.5fb5a7a5.js"><link rel="prefetch" href="/blog/assets/js/181.6020b17a.js"><link rel="prefetch" href="/blog/assets/js/182.7d8b01ed.js"><link rel="prefetch" href="/blog/assets/js/19.cde4fd51.js"><link rel="prefetch" href="/blog/assets/js/20.1f157ccc.js"><link rel="prefetch" href="/blog/assets/js/21.de811ecc.js"><link rel="prefetch" href="/blog/assets/js/22.b2a042a9.js"><link rel="prefetch" href="/blog/assets/js/23.5f8e06be.js"><link rel="prefetch" href="/blog/assets/js/24.36571354.js"><link rel="prefetch" href="/blog/assets/js/25.fbfe0052.js"><link rel="prefetch" href="/blog/assets/js/26.dc7df3f8.js"><link rel="prefetch" href="/blog/assets/js/27.3ac9e32a.js"><link rel="prefetch" href="/blog/assets/js/28.ee38feac.js"><link rel="prefetch" href="/blog/assets/js/29.a5515808.js"><link rel="prefetch" href="/blog/assets/js/3.6c93b5c9.js"><link rel="prefetch" href="/blog/assets/js/30.1dfd6b11.js"><link rel="prefetch" href="/blog/assets/js/31.42465964.js"><link rel="prefetch" href="/blog/assets/js/32.e4754258.js"><link rel="prefetch" href="/blog/assets/js/33.b3a02dc2.js"><link rel="prefetch" href="/blog/assets/js/34.6250006d.js"><link rel="prefetch" href="/blog/assets/js/35.62bbfabe.js"><link rel="prefetch" href="/blog/assets/js/36.f971cd67.js"><link rel="prefetch" href="/blog/assets/js/37.d7f9fc12.js"><link rel="prefetch" href="/blog/assets/js/38.7711db6a.js"><link rel="prefetch" href="/blog/assets/js/39.8326e514.js"><link rel="prefetch" href="/blog/assets/js/40.4aa5d949.js"><link rel="prefetch" href="/blog/assets/js/41.499a6f33.js"><link rel="prefetch" href="/blog/assets/js/42.e006b59b.js"><link rel="prefetch" href="/blog/assets/js/43.c2a93c21.js"><link rel="prefetch" href="/blog/assets/js/44.7b616777.js"><link rel="prefetch" href="/blog/assets/js/45.1e19e6c8.js"><link rel="prefetch" href="/blog/assets/js/46.848dd628.js"><link rel="prefetch" href="/blog/assets/js/47.e245a3a9.js"><link rel="prefetch" href="/blog/assets/js/48.12678395.js"><link rel="prefetch" href="/blog/assets/js/49.0cb83b5e.js"><link rel="prefetch" href="/blog/assets/js/5.727adf8a.js"><link rel="prefetch" href="/blog/assets/js/50.7ac657dc.js"><link rel="prefetch" href="/blog/assets/js/51.f4eb6fe0.js"><link rel="prefetch" href="/blog/assets/js/52.ce2a7f26.js"><link rel="prefetch" href="/blog/assets/js/53.4a17df90.js"><link rel="prefetch" href="/blog/assets/js/54.9038851f.js"><link rel="prefetch" href="/blog/assets/js/55.73935787.js"><link rel="prefetch" href="/blog/assets/js/56.17f69ab2.js"><link rel="prefetch" href="/blog/assets/js/57.d41e961f.js"><link rel="prefetch" href="/blog/assets/js/58.7c47fb80.js"><link rel="prefetch" href="/blog/assets/js/59.57c98278.js"><link rel="prefetch" href="/blog/assets/js/6.9723b38d.js"><link rel="prefetch" href="/blog/assets/js/60.2d8d205c.js"><link rel="prefetch" href="/blog/assets/js/61.086a1fac.js"><link rel="prefetch" href="/blog/assets/js/62.e50a6aba.js"><link rel="prefetch" href="/blog/assets/js/63.b2f3efaf.js"><link rel="prefetch" href="/blog/assets/js/64.93885dd3.js"><link rel="prefetch" href="/blog/assets/js/65.23d09604.js"><link rel="prefetch" href="/blog/assets/js/66.84f1ef02.js"><link rel="prefetch" href="/blog/assets/js/67.c0e564bc.js"><link rel="prefetch" href="/blog/assets/js/68.6ae7487c.js"><link rel="prefetch" href="/blog/assets/js/69.694b0591.js"><link rel="prefetch" href="/blog/assets/js/7.ae1b9be9.js"><link rel="prefetch" href="/blog/assets/js/70.5371842b.js"><link rel="prefetch" href="/blog/assets/js/71.63b31649.js"><link rel="prefetch" href="/blog/assets/js/72.92f11f86.js"><link rel="prefetch" href="/blog/assets/js/73.5991f4bf.js"><link rel="prefetch" href="/blog/assets/js/74.bd3d69e1.js"><link rel="prefetch" href="/blog/assets/js/75.6053e6d5.js"><link rel="prefetch" href="/blog/assets/js/76.84a05662.js"><link rel="prefetch" href="/blog/assets/js/77.f611378c.js"><link rel="prefetch" href="/blog/assets/js/78.3936f4e8.js"><link rel="prefetch" href="/blog/assets/js/79.1424f09d.js"><link rel="prefetch" href="/blog/assets/js/8.60aa9c8a.js"><link rel="prefetch" href="/blog/assets/js/80.6eca56ad.js"><link rel="prefetch" href="/blog/assets/js/81.4d525ce4.js"><link rel="prefetch" href="/blog/assets/js/82.7763533d.js"><link rel="prefetch" href="/blog/assets/js/83.c64e86e6.js"><link rel="prefetch" href="/blog/assets/js/84.3451d9d3.js"><link rel="prefetch" href="/blog/assets/js/85.1ce9f5ce.js"><link rel="prefetch" href="/blog/assets/js/86.c37fc614.js"><link rel="prefetch" href="/blog/assets/js/87.6ee9b5db.js"><link rel="prefetch" href="/blog/assets/js/88.60c727e1.js"><link rel="prefetch" href="/blog/assets/js/89.bbe12fed.js"><link rel="prefetch" href="/blog/assets/js/9.46c022d3.js"><link rel="prefetch" href="/blog/assets/js/90.f9d864bf.js"><link rel="prefetch" href="/blog/assets/js/91.6453cd96.js"><link rel="prefetch" href="/blog/assets/js/92.7e059b32.js"><link rel="prefetch" href="/blog/assets/js/93.a29de98a.js"><link rel="prefetch" href="/blog/assets/js/94.cbe8c47d.js"><link rel="prefetch" href="/blog/assets/js/95.81dc41f6.js"><link rel="prefetch" href="/blog/assets/js/96.4b5a16c1.js"><link rel="prefetch" href="/blog/assets/js/97.a68c6f32.js"><link rel="prefetch" href="/blog/assets/js/98.c14068d9.js"><link rel="prefetch" href="/blog/assets/js/99.6b7e7edd.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.329e1c2e.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/logo.png" alt="前端那些事儿" class="logo"> <span class="site-name can-hide">前端那些事儿</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/blog/base/" class="nav-link">
  前端基础
</a></div><div class="nav-item"><a href="/blog/vue/" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/blog/react/" class="nav-link router-link-active">
  React
</a></div><div class="nav-item"><a href="/blog/node/" class="nav-link">
  Node
</a></div><div class="nav-item"><a href="/blog/devops/" class="nav-link">
  前端工程化
</a></div><div class="nav-item"><a href="/blog/mobile/" class="nav-link">
  泛客户端
</a></div><div class="nav-item"><a href="/blog/architecture/" class="nav-link">
  架构&amp;方案
</a></div><div class="nav-item"><a href="/blog/code/" class="nav-link">
  算法&amp;编程
</a></div><div class="nav-item"><a href="/blog/weekly/" class="nav-link">
  前端周刊
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="GitHub" class="dropdown-title"><span class="title">GitHub</span> <span class="arrow down"></span></button> <button type="button" aria-label="GitHub" class="mobile-dropdown-title"><span class="title">GitHub</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/jonny-wei" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/jonny-wei/sushi-js" target="_blank" rel="noopener noreferrer" class="nav-link external">
  JS 寿司
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/blog/base/" class="nav-link">
  前端基础
</a></div><div class="nav-item"><a href="/blog/vue/" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/blog/react/" class="nav-link router-link-active">
  React
</a></div><div class="nav-item"><a href="/blog/node/" class="nav-link">
  Node
</a></div><div class="nav-item"><a href="/blog/devops/" class="nav-link">
  前端工程化
</a></div><div class="nav-item"><a href="/blog/mobile/" class="nav-link">
  泛客户端
</a></div><div class="nav-item"><a href="/blog/architecture/" class="nav-link">
  架构&amp;方案
</a></div><div class="nav-item"><a href="/blog/code/" class="nav-link">
  算法&amp;编程
</a></div><div class="nav-item"><a href="/blog/weekly/" class="nav-link">
  前端周刊
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="GitHub" class="dropdown-title"><span class="title">GitHub</span> <span class="arrow down"></span></button> <button type="button" aria-label="GitHub" class="mobile-dropdown-title"><span class="title">GitHub</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/jonny-wei" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/jonny-wei/sushi-js" target="_blank" rel="noopener noreferrer" class="nav-link external">
  JS 寿司
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>React</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/react/" aria-current="page" class="sidebar-link">React JSX</a></li><li><a href="/blog/react/warmup/react-component.html" class="sidebar-link">React 组件及通信</a></li><li><a href="/blog/react/warmup/react-state.html" class="sidebar-link">React State</a></li><li><a href="/blog/react/warmup/react-props.html" class="sidebar-link">React Props</a></li><li><a href="/blog/react/warmup/react-lifecycle.html" class="sidebar-link">React 生命周期</a></li><li><a href="/blog/react/warmup/react-ref.html" class="sidebar-link">React Ref</a></li><li><a href="/blog/react/warmup/react-context.html" class="sidebar-link">React Context</a></li><li><a href="/blog/react/warmup/react-css.html" class="sidebar-link">React 中 CSS 的模块化</a></li><li><a href="/blog/react/warmup/react-hoc.html" class="sidebar-link">React HOC</a></li><li><a href="/blog/react/warmup/react-render.html" class="sidebar-link">React 渲染优化</a></li><li><a href="/blog/react/warmup/react-router.html" class="sidebar-link">React Router</a></li><li><a href="/blog/react/warmup/react-redux.html" class="sidebar-link">React Rudex</a></li><li><a href="/blog/react/warmup/react-mobx.html" class="sidebar-link">React Mobx</a></li><li><a href="/blog/react/warmup/react-keepalive.html" class="sidebar-link">实现 KeepAlive</a></li><li><a href="/blog/react/warmup/react-state-v18.html" aria-current="page" class="active sidebar-link">V18 - Automatic Batching</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/react/warmup/react-state-v18.html#批量更新" class="sidebar-link">批量更新</a></li><li class="sidebar-sub-header"><a href="/blog/react/warmup/react-state-v18.html#更新原理" class="sidebar-link">更新原理</a></li></ul></li><li><a href="/blog/react/warmup/react-transition.html" class="sidebar-link">V18 - Transition</a></li><li><a href="/blog/react/warmup/react-suspense.html" class="sidebar-link">V18 - Suspense</a></li><li><a href="/blog/react/warmup/react-useMutableSource.html" class="sidebar-link">V18 - useMutableSource</a></li><li><a href="/blog/react/warmup/react-ssr.html" class="sidebar-link">V18 - Streaming SSR</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>React源码解析</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/react/react/react-reconciler.html" class="sidebar-link">Reconciler 调和器</a></li><li><a href="/blog/react/react/react-priority.html" class="sidebar-link">React 优先级管理</a></li><li><a href="/blog/react/react/react-scheduler.html" class="sidebar-link">Scheduler 调度器</a></li><li><a href="/blog/react/react/react-render.html" class="sidebar-link">Render 阶段</a></li><li><a href="/blog/react/react/react-commit.html" class="sidebar-link">Commit 阶段</a></li><li><a href="/blog/react/react/react-diff.html" class="sidebar-link">React Diff 算法</a></li><li><a href="/blog/react/react/react-hooks.html" class="sidebar-link">React Hooks 理解</a></li><li><a href="/blog/react/react/react-context.html" class="sidebar-link">React Context 原理</a></li><li><a href="/blog/react/react/react-event.html" class="sidebar-link">React 事件系统</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="v18-automatic-batching"><a href="#v18-automatic-batching" class="header-anchor">#</a> V18 - Automatic Batching</h1> <p>在 React State 章节介绍了在 legacy 模式下的 state 更新流程，这种模式下的批量更新原理本质上是通过不同的更新上下文开关 Context ，比如 batch 或者 event 来让更新变成<strong>可控的</strong>。那么在 <code>v18 concurrent</code> 下 React 的更新又有哪些特点呢？</p> <p>在了解 <code>v18 concurrent</code> 之前，先来看一下主流框架中两种批量更新的原理：</p> <ul><li>微任务、宏任务实现集中更新</li> <li>可控任务实现批量更新</li></ul> <h2 id="批量更新"><a href="#批量更新" class="header-anchor">#</a> 批量更新</h2> <h3 id="微任务、宏任务实现集中更新"><a href="#微任务、宏任务实现集中更新" class="header-anchor">#</a> 微任务、宏任务实现集中更新</h3> <p>试想一下，比如每次更新，我们先并不去立即执行更新任务，而是先把每一个更新任务放入一个待更新队列 <code>updateQueue</code> 里面，然后 js 执行完毕，用一个微任务统一去批量更新队列里面的任务，如果微任务存在兼容性，那么降级成一个宏任务。这里<strong>优先采用微任务</strong>的原因就是微任务的执行时机要早于下一次宏任务的执行。</p> <p>这种在微任务、宏任务实现集中更新典型的案例就是 vue 更新原理，<code>vue.$nextTick</code>原理 ，还有接下来要介绍的 v18 中 <code>scheduleMicrotask</code> 的更新原理。</p> <p><img src="/blog/images/react/v18-state1.png" alt="v18-state1"></p> <p>模拟一下整个流程的实现。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Scheduler</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>callbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token comment">/* 微任务批量处理 */</span>
        <span class="token function">queueMicrotask</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">runTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/* 增加任务 */</span>
    <span class="token function">addTask</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>callbacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">runTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'------合并更新开始------'</span><span class="token punctuation">)</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>callbacks<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">const</span> cur <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>callbacks<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token function">cur</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'------合并更新结束------'</span><span class="token punctuation">)</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'------开始更新组件------'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token parameter">cb</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">const</span> scheduler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">cb</span><span class="token punctuation">(</span>scheduler<span class="token punctuation">.</span><span class="token function">addTask</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>scheduler<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 模拟一次更新 */</span>
<span class="token keyword">function</span> <span class="token function">mockOnclick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">add</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
       <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
           console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'第一次更新'</span><span class="token punctuation">)</span>
       <span class="token punctuation">}</span><span class="token punctuation">)</span>
       console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'----宏任务逻辑----'</span><span class="token punctuation">)</span>
       <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'第二次更新'</span><span class="token punctuation">)</span>
       <span class="token punctuation">}</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">mockOnclick</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// ----宏任务逻辑---- -&gt; ------合并更新开始------ -&gt; 第一次更新 -&gt; 第二次更新 -&gt; ------合并更新结束------</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br></div></div><p>模拟一下具体实现细节：</p> <ul><li>通过一个 Scheduler 调度器来完成整个流程。</li> <li>通过 addTask 每次向队列中放入任务。</li> <li>用 queueMicrotask 创建一个微任务，来统一处理这些任务。</li> <li>mockOnclick 模拟一次更新。我们用 nextTick 来模拟一下更新函数的处理逻辑。</li></ul> <h3 id="可控任务实现批量更新"><a href="#可控任务实现批量更新" class="header-anchor">#</a> 可控任务实现批量更新</h3> <p>通过拦截把任务变成<strong>可控的</strong>，典型的就是 React v17 之前的 batchEventUpdate 批量更新，。这种情况的更新来源于对事件进行拦截，比如 React 的事件系统。以 React 的事件批量更新为例子，比如我们的 onClick ，onChange 事件都是被 React 的事件系统处理的。外层用一个统一的处理函数进行拦截。而我们绑定的事件都是在该函数的执行上下文内部被调用的。</p> <p>那么比如在一次点击事件中触发了多次更新。本质上外层在 React 事件系统处理函数的上下文中，这样的情况下，就可以通过一个开关，证明当前更新是可控的，可以做批量处理。接下来 React 就用一次就可以了。</p> <p><img src="/blog/images/react/v18-state2.png" alt="v18-state2"></p> <p>模拟一下具体的实现：</p> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">  
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>handleClick()<span class="token punctuation">&quot;</span></span> <span class="token punctuation">&gt;</span></span><span class="token plain-text">点击</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
  let  batchEventUpdate = false 
  let callbackQueue = []

  function flushSyncCallbackQueue(){
      console.log('-----执行批量更新-------')
      while(callbackQueue.length &gt; 0 ){
          const cur = callbackQueue.shift()
          cur()
      }
      console.log('-----批量更新结束-------')
  }

  function wrapEvent(fn){
     return function (){
         /* 开启批量更新状态 */
        batchEventUpdate = true
        fn()
        /* 立即执行更新任务 */
        flushSyncCallbackQueue()
        /* 关闭批量更新状态 */
        batchEventUpdate = false
     }
  }

  function setState(fn){
      /* 如果在批量更新状态下，那么批量更新 */
      if(batchEventUpdate){
          callbackQueue.push(fn)
      }else{
          /* 如果没有在批量更新条件下，那么直接更新。 */
          fn()
      }
  }

  function handleClick(){
      setState(()=&gt;{
          console.log('---更新1---')
      })
      console.log('上下文执行')
      setState(()=&gt;{
          console.log('---更新2---')
      })
  }
  /* 让 handleClick 变成可控的  */
  handleClick = wrapEvent(handleClick)
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token comment">// 上下文执行 -&gt; -----执行批量更新------- -&gt; ---更新1--- -&gt; ---更新2--- -&gt; -----批量更新结束-------</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br></div></div><ul><li>本方式的核心就是让 handleClick 通过 wrapEvent 变成可控的。首先 wrapEvent 类似于事件处理函数，在内部通过开关 batchEventUpdate 来判断是否开启批量更新状态，最后通过 flushSyncCallbackQueue 来清空待更新队列。</li> <li>在批量更新条件下，事件会被放入到更新队列中，非批量更新条件下，那么立即执行更新任务。</li></ul> <h3 id="与传统-legacy-模式的区别"><a href="#与传统-legacy-模式的区别" class="header-anchor">#</a> 与传统 legacy 模式的区别</h3> <p>首先对于传统的 legacy 模式，有可控任务批量处理的概念，也就是采用了上面第二种批量更新模式：</p> <ul><li>通过不同的更新上下文开关，在开关里的任务是可控的，可以进行批量处理。</li> <li>在事件之行完毕后，通过 <code>flushSyncCallback</code> 来进行更新任务之行。</li></ul> <p>那么在 concurrent 模式下的更新采用了一个什么方式呢？首先在这种模式下，取消了批量更新的感念。我们以事件系统的更新例子，研究一下两种的区别。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// react-dom/src/events/ReactDOMUpdateBatching.js</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">batchedEventUpdates</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span>a</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    isBatchingEventUpdates <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">//打开批量更新开关</span>
    <span class="token keyword">try</span><span class="token punctuation">{</span>
       <span class="token function">fn</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>  <span class="token comment">// 事件在这里执行</span>
    <span class="token punctuation">}</span><span class="token keyword">finally</span><span class="token punctuation">{</span>
        isBatchingEventUpdates <span class="token operator">=</span> <span class="token boolean">false</span> <span class="token comment">//关闭批量更新开关</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>executionContext <span class="token operator">===</span> NoContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">flushSyncCallbackQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// TODO: 这个很重要，用来同步执行更新队列中的任务</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><ul><li>通过开关 <code>isBatchingEventUpdates</code> 来让 fn 里面的更新变成可控的，所以可以进行批量更新。</li> <li>重点就是 <code>flushSyncCallbackQueue</code> 用来同步执行更新队列中的任务。</li></ul> <p>在最新版本的 v18 alpha 系统中，事件变成了这样 ：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">batchedEventUpdates</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> prevExecutionContext <span class="token operator">=</span> executionContext<span class="token punctuation">;</span>
    executionContext <span class="token operator">|=</span> EventContext<span class="token punctuation">;</span>  <span class="token comment">// 运算赋值</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 执行函数</span>
    <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>
        executionContext <span class="token operator">=</span> prevExecutionContext<span class="token punctuation">;</span> <span class="token comment">// 重置之前的状态</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>executionContext <span class="token operator">===</span> NoContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">flushSyncCallbacksOnlyInLegacyMode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 同步执行更新队列中的任务</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>从上述代码中可以清晰的看到，v18 alpha 版本的流程大致是这样的：</p> <ul><li>也是通过类似开关状态来控制的，在刚开始的时候将赋值给 <code>EventContext</code> ，然后在事件执行之后，赋值给 <code>prevExecutionContext</code>。</li> <li>之后同样会触发 flushSyncCallbacksOnlyInLegacyMode ，不过通过函数名称就可以大胆猜想，这个方法主要是针对 legacy 模式的更新，那么 concurrent mode 下也就不会走 flushSyncCallback 的逻辑了。</li></ul> <p>再看一下 <code>flushSyncCallbacksOnlyInLegacyMode</code> 做了些什么事：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// react-reconciler/src/ReactFiberSyncTaskQueue.js</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">flushSyncCallbacksOnlyInLegacyMode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>includesLegacySyncCallbacks<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">/* 只有在 legacy 模式下，才会走这里的流程。 */</span>
        <span class="token function">flushSyncCallbacks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>结论：<strong>只有在 legacy 模式下，才会执行 flushSyncCallbacks 来同步执行任务。</strong> flushSyncCallbacks 主要作用是，能够在一次更新中，直接同步更新任务，防止任务在下一次的宏任务中执行。</p> <p>那么对于 concurrent 下的更新流程是怎么样的呢？一次更新 state 会发生什么？</p> <h2 id="更新原理"><a href="#更新原理" class="header-anchor">#</a> 更新原理</h2> <p>在了解更新原理之前，先了解以下 v18 中新增的API  <code>ReactDOM.createRoot()</code>，只要使用<code>ReactDOM.createRoot()</code> 方法，就能<strong>直接享受自动 batching 的能力</strong>。</p> <h3 id="createroot"><a href="#createroot" class="header-anchor">#</a> createRoot</h3> <p>在 React18 中， <code>ReactDOM.render()</code> 正式成为 Legacy，并增加了新的 API  <code>ReactDOM.createRoot()</code> ，他们的用法差别如下：</p> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token keyword">import</span> ReactDOM <span class="token keyword">from</span> ‘react<span class="token operator">-</span>dom’<span class="token punctuation">;</span>
<span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">'App'</span><span class="token punctuation">;</span>

ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">App</span></span> <span class="token punctuation">/&gt;</span></span><span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// v18 - createRoot</span>
<span class="token keyword">import</span> ReactDOM <span class="token keyword">from</span> ‘react<span class="token operator">-</span>dom’<span class="token punctuation">;</span>
<span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">'App'</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> root <span class="token operator">=</span> ReactDOM<span class="token punctuation">.</span><span class="token function">createRoot</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

root<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">App</span></span> <span class="token punctuation">/&gt;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>通过新的 API，我们可以为一个 React App <strong>创建多个根节点</strong>，甚至在未来可以<strong>用不同版本的 React 来创建</strong>。React18 保留了上述两种用法，老项目不想改仍然可以用 <code>ReactDOM.render()</code> ；新项目想提升性能，可以用  <code>ReactDOM.createRoot()</code> 且可借并发渲染的好处。</p> <h3 id="什么是-automatic-batching"><a href="#什么是-automatic-batching" class="header-anchor">#</a> 什么是 Automatic Batching</h3> <p>为了使应用获得更好的性能，React把多次的状态更新（state updates），合并到一次渲染中。 React17 只会把浏览器事件（如点击）发生期间的状态更新合并掉。而 React18 会把事件处理器发生后的状态更新也合并掉。</p> <p>batching 是安全的，但也存在一些特殊情况不希望 batching 发生，比如：你需要在状态更新后，立刻读取新 DOM 上的数据等。这种情况下请使用 <code>ReactDOM.flushSync()</code></p> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> flushSync <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react-dom'</span><span class="token punctuation">;</span> <span class="token comment">// Note: react-dom, not react</span>

<span class="token keyword">function</span> <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">flushSync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setCounter</span><span class="token punctuation">(</span><span class="token parameter">c</span> <span class="token operator">=&gt;</span> c <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// React has updated the DOM by now</span>
  <span class="token function">flushSync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setFlag</span><span class="token punctuation">(</span><span class="token parameter">f</span> <span class="token operator">=&gt;</span> <span class="token operator">!</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// React has updated the DOM by now</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>那么 Automatic Batching 对 Hooks/Classes 有什么影响呢？</p> <ul><li>对 Hooks 没有任何影响</li> <li>对 classes 大部分情况下没影响，关注一种模式：是否在两次 setState 之间读取了state 值。差异如下：</li></ul> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token function-variable function">handleClick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> count <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> count<span class="token operator">:</span> count <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 在 React17 及之前，打印出来是 { count: 1, flag: false }</span>
    <span class="token comment">// 在 React18，打印出来是 { count: 0, flag: false }</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> flag <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> flag<span class="token operator">:</span> <span class="token operator">!</span>flag <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>如果不想通过调整代码逻辑的方式进行修正，可以直接采用 <code>ReactDOM.flushSync()</code> :</p> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token function-variable function">handleClick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    ReactDOM<span class="token punctuation">.</span><span class="token function">flushSync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> count <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> count<span class="token operator">:</span> count <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 在 React18，打印出来是 { count: 1, flag: false }</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> flag <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> flag<span class="token operator">:</span> <span class="token operator">!</span>flag <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h3 id="更新原理-2"><a href="#更新原理-2" class="header-anchor">#</a> 更新原理</h3> <p>无论是那种条件下，只要触发 React 的 <code>setState</code> 或者 <code>useState</code>，最终进入调度任务开始更新的入口函数都是 <code>ensureRootIsScheduled</code> :</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// react-reconciler/src/ReactFiberWorkLoop.js -&gt; ensureRootIsScheduled</span>
<span class="token keyword">function</span> <span class="token function">ensureRootIsScheduled</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">,</span>currentTime</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> existingCallbackNode <span class="token operator">=</span> root<span class="token punctuation">.</span>callbackNode<span class="token punctuation">;</span>

    <span class="token keyword">var</span> newCallbackPriority <span class="token operator">=</span> <span class="token function">getHighestPriorityLane</span><span class="token punctuation">(</span>nextLanes<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">var</span> existingCallbackPriority <span class="token operator">=</span> root<span class="token punctuation">.</span>callbackPriority<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>existingCallbackPriority <span class="token operator">===</span> newCallbackPriority <span class="token operator">&amp;&amp;</span> 
    <span class="token operator">!</span><span class="token punctuation">(</span> ReactCurrentActQueue<span class="token punctuation">.</span>current <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> existingCallbackNode <span class="token operator">!==</span> fakeActCallbackNode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/* 批量更新退出* */</span>  
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">/* 同步更新条件下，会走这里的逻辑 */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCallbackPriority <span class="token operator">===</span> SyncLane<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">scheduleSyncCallback</span><span class="token punctuation">(</span><span class="token function">performSyncWorkOnRoot</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">/* 用微任务去立即执行更新  */</span>
        <span class="token function">scheduleMicrotask</span><span class="token punctuation">(</span>flushSyncCallbacks<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
        newCallbackNode <span class="token operator">=</span> <span class="token function">scheduleCallback</span><span class="token punctuation">(</span>
            schedulerPriorityLevel<span class="token punctuation">,</span>
            <span class="token function">performConcurrentWorkOnRoot</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/* 这里很重要就是给当前 root 赋予 callbackPriority 和 callbackNode 状态 */</span>
    root<span class="token punctuation">.</span>callbackPriority <span class="token operator">=</span> newCallbackPriority<span class="token punctuation">;</span>
    root<span class="token punctuation">.</span>callbackNode <span class="token operator">=</span> newCallbackNode<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><h4 id="同步条件下的逻辑"><a href="#同步条件下的逻辑" class="header-anchor">#</a> 同步条件下的逻辑</h4> <p>首先我们来看一下，同步更新的逻辑，上面讲到在 concurrent 中已经没有可控任务那一套逻辑。所以核心更新流程如下：</p> <p>当同步状态下触发多次 useState 的时候：</p> <ul><li>首先第一次进入到 <code>ensureRootIsScheduled</code> ，会计算出 <code>newCallbackPriority</code> 可以理解成执行新的更新任务的优先级。那么和之前的 <code>callbackPriority</code> 进行对比，如果相等那么退出流程，那么第一次两者肯定是不想等的。</li> <li>同步状态下常规的更新 <code>newCallbackPriority</code> 是等于 <code>SyncLane</code> 的，那么会执行两个函数，<code>scheduleSyncCallback</code> 和 <code>scheduleMicrotask</code>。</li></ul> <p><code>scheduleSyncCallback</code> 会把任务 <code>syncQueue</code> 同步更新队列中。来看一下这个函数：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// react-reconciler/src/ReactFiberSyncTaskQueue.js -&gt; scheduleSyncCallback</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">scheduleSyncCallback</span><span class="token punctuation">(</span><span class="token parameter">callback<span class="token operator">:</span> SchedulerCallback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>syncQueue <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    syncQueue <span class="token operator">=</span> <span class="token punctuation">[</span>callback<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    syncQueue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><div class="custom-block tip"><p class="custom-block-title">注意</p> <p>接下来就是 concurrent 下更新的区别了。在老版本的 React 是基于事件处理函数执行的 <code>flushSyncCallbacks</code> ，而新版本 React 是通过 <code>scheduleMicrotask</code> 执行的。</p></div> <p>我们看一下 <code>scheduleMicrotask</code> 到底是什么？</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// react-reconciler/src/ReactFiberHostConfig.js -&gt; scheduleMicrotask</span>
<span class="token keyword">var</span> scheduleMicrotask <span class="token operator">=</span> <span class="token keyword">typeof</span> queueMicrotask <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">?</span> queueMicrotask <span class="token operator">:</span> <span class="token keyword">typeof</span> Promise <span class="token operator">!==</span> <span class="token string">'undefined'</span> <span class="token operator">?</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span>handleErrorInNextTick<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token operator">:</span> scheduleTimeout<span class="token punctuation">;</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><code>scheduleMicrotask</code> 本质上就是 <code>Promise.resolve</code> ，还有一个 <code>setTimeout</code> 向下兼容的情况。通过 <code>scheduleMicrotask</code> 去进行调度更新。</p> <p>那么如果发生第二次 <code>useState</code> ，则会出现 <code>existingCallbackPriority === newCallbackPriority</code> 的情况，接下来就会 return 退出更新流程了。</p> <h4 id="异步条件下的逻辑"><a href="#异步条件下的逻辑" class="header-anchor">#</a> 异步条件下的逻辑</h4> <p>在异步情况下，比如在 <code>setTimeout</code> 或者是 <code>Promise.resolve</code> 条件下的更新，会走哪些逻辑呢？</p> <ul><li>第一步也会判断 <code>existingCallbackPriority === newCallbackPriority</code> 是否相等，相等则退出。</li> <li>第二步则就有点区别了。会直接执行 <code>scheduleCallback</code> ，然后得到最新的 <code>newCallbackNode</code>，并赋值给 root 。</li> <li>接下来第二次 <code>useState</code> ，同样会 return 跳出 <code>ensureRootIsScheduled</code> 。</li></ul> <p>看一下 <code>scheduleCallback</code> 做了哪些事。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// react-reconciler/src/ReactFiberWorkLoop.js -&gt; scheduleCallback</span>
<span class="token keyword">function</span> <span class="token function">scheduleCallback</span><span class="token punctuation">(</span><span class="token parameter">priorityLevel<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> actQueue <span class="token operator">=</span> ReactCurrentActQueue<span class="token punctuation">.</span>current<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>actQueue <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      actQueue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> fakeActCallbackNode<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">scheduleCallback</span><span class="token punctuation">(</span>priorityLevel<span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>最后用一幅流程图描述一下流程：</p> <p><img src="/blog/images/react/v18-state3.png" alt="v18-state3"></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/react/warmup/react-keepalive.html" class="prev">
        实现 KeepAlive
      </a></span> <span class="next"><a href="/blog/react/warmup/react-transition.html">
        V18 - Transition
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----><!----><!----></div></div>
    <script src="/blog/assets/js/app.3fadfb99.js" defer></script><script src="/blog/assets/js/2.8bf77cff.js" defer></script><script src="/blog/assets/js/136.ff41831c.js" defer></script><script src="/blog/assets/js/4.ff6074e9.js" defer></script>
  </body>
</html>
