<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Render 阶段 | 前端那些事儿</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/blog/logo.png">
    <link rel="manifest" href="/blog/manifest.json">
    <link rel="apple-touch-icon" href="/blog/images/icons/apple-icon-152x152.png">
    <meta name="description" content="我命由我不由天，学习吧少年">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
    <meta name="msapplication-TileColor" content="#000000">
    
    <link rel="preload" href="/blog/assets/css/0.styles.76cb5f71.css" as="style"><link rel="preload" href="/blog/assets/js/app.88ac7007.js" as="script"><link rel="preload" href="/blog/assets/js/2.dc7ae5f9.js" as="script"><link rel="preload" href="/blog/assets/js/1.70fc1187.js" as="script"><link rel="preload" href="/blog/assets/js/142.a29d4427.js" as="script"><link rel="preload" href="/blog/assets/js/20.36f36c92.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.8765323e.js"><link rel="prefetch" href="/blog/assets/js/100.bf26d8d4.js"><link rel="prefetch" href="/blog/assets/js/101.976d4f86.js"><link rel="prefetch" href="/blog/assets/js/102.14eedb5b.js"><link rel="prefetch" href="/blog/assets/js/103.665dad0b.js"><link rel="prefetch" href="/blog/assets/js/104.b2228b10.js"><link rel="prefetch" href="/blog/assets/js/105.3065c3be.js"><link rel="prefetch" href="/blog/assets/js/106.0133a069.js"><link rel="prefetch" href="/blog/assets/js/107.f41f32d0.js"><link rel="prefetch" href="/blog/assets/js/108.f6e93fc5.js"><link rel="prefetch" href="/blog/assets/js/109.ac02adbe.js"><link rel="prefetch" href="/blog/assets/js/11.2cc42d06.js"><link rel="prefetch" href="/blog/assets/js/110.38736bc0.js"><link rel="prefetch" href="/blog/assets/js/111.2173c68d.js"><link rel="prefetch" href="/blog/assets/js/112.5cae8bd8.js"><link rel="prefetch" href="/blog/assets/js/113.fe84b5c8.js"><link rel="prefetch" href="/blog/assets/js/114.49455f09.js"><link rel="prefetch" href="/blog/assets/js/115.6ae25dee.js"><link rel="prefetch" href="/blog/assets/js/116.324f1790.js"><link rel="prefetch" href="/blog/assets/js/117.6b0050af.js"><link rel="prefetch" href="/blog/assets/js/118.207d3e3e.js"><link rel="prefetch" href="/blog/assets/js/119.7fa62ef5.js"><link rel="prefetch" href="/blog/assets/js/12.75981b02.js"><link rel="prefetch" href="/blog/assets/js/120.08404f50.js"><link rel="prefetch" href="/blog/assets/js/121.33252574.js"><link rel="prefetch" href="/blog/assets/js/122.379d9f46.js"><link rel="prefetch" href="/blog/assets/js/123.44ca9fc9.js"><link rel="prefetch" href="/blog/assets/js/124.df07e24c.js"><link rel="prefetch" href="/blog/assets/js/125.87d50edb.js"><link rel="prefetch" href="/blog/assets/js/126.9ed4dca9.js"><link rel="prefetch" href="/blog/assets/js/127.c819299b.js"><link rel="prefetch" href="/blog/assets/js/128.403981e1.js"><link rel="prefetch" href="/blog/assets/js/129.d6710d57.js"><link rel="prefetch" href="/blog/assets/js/13.0209b501.js"><link rel="prefetch" href="/blog/assets/js/130.3900fd4f.js"><link rel="prefetch" href="/blog/assets/js/131.14fc533c.js"><link rel="prefetch" href="/blog/assets/js/132.8fe0776f.js"><link rel="prefetch" href="/blog/assets/js/133.b503545b.js"><link rel="prefetch" href="/blog/assets/js/134.f744876e.js"><link rel="prefetch" href="/blog/assets/js/135.f6fbd562.js"><link rel="prefetch" href="/blog/assets/js/136.21426a2b.js"><link rel="prefetch" href="/blog/assets/js/137.ea5cfd63.js"><link rel="prefetch" href="/blog/assets/js/138.f74ec496.js"><link rel="prefetch" href="/blog/assets/js/139.3683fadb.js"><link rel="prefetch" href="/blog/assets/js/14.099935e4.js"><link rel="prefetch" href="/blog/assets/js/140.ba7a28b9.js"><link rel="prefetch" href="/blog/assets/js/141.4e4bf6f9.js"><link rel="prefetch" href="/blog/assets/js/143.1f2bdec3.js"><link rel="prefetch" href="/blog/assets/js/144.89b915bc.js"><link rel="prefetch" href="/blog/assets/js/145.1751462f.js"><link rel="prefetch" href="/blog/assets/js/146.922091df.js"><link rel="prefetch" href="/blog/assets/js/147.9fb489f5.js"><link rel="prefetch" href="/blog/assets/js/148.4f02d6be.js"><link rel="prefetch" href="/blog/assets/js/149.33a1be32.js"><link rel="prefetch" href="/blog/assets/js/15.1742d511.js"><link rel="prefetch" href="/blog/assets/js/150.2b09a871.js"><link rel="prefetch" href="/blog/assets/js/151.40682293.js"><link rel="prefetch" href="/blog/assets/js/152.309a2016.js"><link rel="prefetch" href="/blog/assets/js/153.c4a96cdb.js"><link rel="prefetch" href="/blog/assets/js/154.75d51a65.js"><link rel="prefetch" href="/blog/assets/js/155.14d8f889.js"><link rel="prefetch" href="/blog/assets/js/156.b9d6a6b0.js"><link rel="prefetch" href="/blog/assets/js/157.bb8d8303.js"><link rel="prefetch" href="/blog/assets/js/158.3557d807.js"><link rel="prefetch" href="/blog/assets/js/159.ec2b7c53.js"><link rel="prefetch" href="/blog/assets/js/16.fd5c64c0.js"><link rel="prefetch" href="/blog/assets/js/160.7c5ba294.js"><link rel="prefetch" href="/blog/assets/js/161.f2f9c93c.js"><link rel="prefetch" href="/blog/assets/js/162.7636ea8a.js"><link rel="prefetch" href="/blog/assets/js/163.468fb0c6.js"><link rel="prefetch" href="/blog/assets/js/164.ae0637d2.js"><link rel="prefetch" href="/blog/assets/js/165.6f204368.js"><link rel="prefetch" href="/blog/assets/js/166.b915eab1.js"><link rel="prefetch" href="/blog/assets/js/167.feb43552.js"><link rel="prefetch" href="/blog/assets/js/168.9eee96b9.js"><link rel="prefetch" href="/blog/assets/js/169.d2228021.js"><link rel="prefetch" href="/blog/assets/js/17.eaa22719.js"><link rel="prefetch" href="/blog/assets/js/170.b0104490.js"><link rel="prefetch" href="/blog/assets/js/171.72b5b5a1.js"><link rel="prefetch" href="/blog/assets/js/172.0c674282.js"><link rel="prefetch" href="/blog/assets/js/173.5c228a59.js"><link rel="prefetch" href="/blog/assets/js/174.2767000c.js"><link rel="prefetch" href="/blog/assets/js/175.24bc60de.js"><link rel="prefetch" href="/blog/assets/js/176.35b74147.js"><link rel="prefetch" href="/blog/assets/js/177.6ca34089.js"><link rel="prefetch" href="/blog/assets/js/178.f501c8d2.js"><link rel="prefetch" href="/blog/assets/js/179.ee06ff18.js"><link rel="prefetch" href="/blog/assets/js/18.4d04ed8a.js"><link rel="prefetch" href="/blog/assets/js/180.6989133a.js"><link rel="prefetch" href="/blog/assets/js/181.481e9d65.js"><link rel="prefetch" href="/blog/assets/js/182.a80546b8.js"><link rel="prefetch" href="/blog/assets/js/183.521e36e6.js"><link rel="prefetch" href="/blog/assets/js/184.edbfff0d.js"><link rel="prefetch" href="/blog/assets/js/185.3f599628.js"><link rel="prefetch" href="/blog/assets/js/186.36b513a4.js"><link rel="prefetch" href="/blog/assets/js/187.058fc2c7.js"><link rel="prefetch" href="/blog/assets/js/188.79114cb6.js"><link rel="prefetch" href="/blog/assets/js/189.97e0be42.js"><link rel="prefetch" href="/blog/assets/js/19.16f8a8f3.js"><link rel="prefetch" href="/blog/assets/js/190.e2c38d0c.js"><link rel="prefetch" href="/blog/assets/js/191.49371655.js"><link rel="prefetch" href="/blog/assets/js/192.a197326e.js"><link rel="prefetch" href="/blog/assets/js/193.c53bca00.js"><link rel="prefetch" href="/blog/assets/js/194.b62998c6.js"><link rel="prefetch" href="/blog/assets/js/195.a077fe40.js"><link rel="prefetch" href="/blog/assets/js/196.114f7c20.js"><link rel="prefetch" href="/blog/assets/js/197.a467f715.js"><link rel="prefetch" href="/blog/assets/js/198.5c2fb1ca.js"><link rel="prefetch" href="/blog/assets/js/199.027cc7a7.js"><link rel="prefetch" href="/blog/assets/js/200.7049a079.js"><link rel="prefetch" href="/blog/assets/js/201.4e0f0fc6.js"><link rel="prefetch" href="/blog/assets/js/202.a030b087.js"><link rel="prefetch" href="/blog/assets/js/203.4672ffcf.js"><link rel="prefetch" href="/blog/assets/js/21.5ff741b6.js"><link rel="prefetch" href="/blog/assets/js/22.4c0a24e0.js"><link rel="prefetch" href="/blog/assets/js/23.6e07f643.js"><link rel="prefetch" href="/blog/assets/js/24.af9e309d.js"><link rel="prefetch" href="/blog/assets/js/25.c4741912.js"><link rel="prefetch" href="/blog/assets/js/26.979c135a.js"><link rel="prefetch" href="/blog/assets/js/27.0e523d5c.js"><link rel="prefetch" href="/blog/assets/js/28.1eca3035.js"><link rel="prefetch" href="/blog/assets/js/29.4f51c83f.js"><link rel="prefetch" href="/blog/assets/js/3.d7509571.js"><link rel="prefetch" href="/blog/assets/js/30.dbfb29cd.js"><link rel="prefetch" href="/blog/assets/js/31.33f6f4a7.js"><link rel="prefetch" href="/blog/assets/js/32.bad38436.js"><link rel="prefetch" href="/blog/assets/js/33.0622c4c3.js"><link rel="prefetch" href="/blog/assets/js/34.03bf07bc.js"><link rel="prefetch" href="/blog/assets/js/35.4582d9ee.js"><link rel="prefetch" href="/blog/assets/js/36.1d9b5dca.js"><link rel="prefetch" href="/blog/assets/js/37.713433a4.js"><link rel="prefetch" href="/blog/assets/js/38.336404fc.js"><link rel="prefetch" href="/blog/assets/js/39.f599088d.js"><link rel="prefetch" href="/blog/assets/js/4.73bf4225.js"><link rel="prefetch" href="/blog/assets/js/40.734debda.js"><link rel="prefetch" href="/blog/assets/js/41.35d5ace2.js"><link rel="prefetch" href="/blog/assets/js/42.872f64cf.js"><link rel="prefetch" href="/blog/assets/js/43.df862bb9.js"><link rel="prefetch" href="/blog/assets/js/44.56928ac0.js"><link rel="prefetch" href="/blog/assets/js/45.6454f828.js"><link rel="prefetch" href="/blog/assets/js/46.e6238789.js"><link rel="prefetch" href="/blog/assets/js/47.55621bd4.js"><link rel="prefetch" href="/blog/assets/js/48.29d90b0b.js"><link rel="prefetch" href="/blog/assets/js/49.6bc15464.js"><link rel="prefetch" href="/blog/assets/js/5.ecec2a91.js"><link rel="prefetch" href="/blog/assets/js/50.8869ad2a.js"><link rel="prefetch" href="/blog/assets/js/51.a9216b6c.js"><link rel="prefetch" href="/blog/assets/js/52.4017fa9a.js"><link rel="prefetch" href="/blog/assets/js/53.2a3d3e6b.js"><link rel="prefetch" href="/blog/assets/js/54.a60d1a2e.js"><link rel="prefetch" href="/blog/assets/js/55.1bf58772.js"><link rel="prefetch" href="/blog/assets/js/56.475fd425.js"><link rel="prefetch" href="/blog/assets/js/57.77076362.js"><link rel="prefetch" href="/blog/assets/js/58.7ac1d37a.js"><link rel="prefetch" href="/blog/assets/js/59.c59d0c49.js"><link rel="prefetch" href="/blog/assets/js/6.0172243e.js"><link rel="prefetch" href="/blog/assets/js/60.4ae0b0ba.js"><link rel="prefetch" href="/blog/assets/js/61.4f784b43.js"><link rel="prefetch" href="/blog/assets/js/62.d2465a03.js"><link rel="prefetch" href="/blog/assets/js/63.870bfe38.js"><link rel="prefetch" href="/blog/assets/js/64.1df3ecdf.js"><link rel="prefetch" href="/blog/assets/js/65.4d18ebd9.js"><link rel="prefetch" href="/blog/assets/js/66.7673dfd2.js"><link rel="prefetch" href="/blog/assets/js/67.478ccbce.js"><link rel="prefetch" href="/blog/assets/js/68.a1733588.js"><link rel="prefetch" href="/blog/assets/js/69.a7d0677b.js"><link rel="prefetch" href="/blog/assets/js/7.f1797797.js"><link rel="prefetch" href="/blog/assets/js/70.1f01bf10.js"><link rel="prefetch" href="/blog/assets/js/71.66939d5c.js"><link rel="prefetch" href="/blog/assets/js/72.7900bcdf.js"><link rel="prefetch" href="/blog/assets/js/73.7f8066ca.js"><link rel="prefetch" href="/blog/assets/js/74.2b28f89c.js"><link rel="prefetch" href="/blog/assets/js/75.af97f519.js"><link rel="prefetch" href="/blog/assets/js/76.75646650.js"><link rel="prefetch" href="/blog/assets/js/77.1b4579d3.js"><link rel="prefetch" href="/blog/assets/js/78.d2e23619.js"><link rel="prefetch" href="/blog/assets/js/79.14cc166d.js"><link rel="prefetch" href="/blog/assets/js/80.4fd27dbe.js"><link rel="prefetch" href="/blog/assets/js/81.5e950666.js"><link rel="prefetch" href="/blog/assets/js/82.1318afe3.js"><link rel="prefetch" href="/blog/assets/js/83.a84fa4bf.js"><link rel="prefetch" href="/blog/assets/js/84.94e707bd.js"><link rel="prefetch" href="/blog/assets/js/85.650c44b4.js"><link rel="prefetch" href="/blog/assets/js/86.6768c292.js"><link rel="prefetch" href="/blog/assets/js/87.f1e82e72.js"><link rel="prefetch" href="/blog/assets/js/88.17f551e7.js"><link rel="prefetch" href="/blog/assets/js/89.d12afbed.js"><link rel="prefetch" href="/blog/assets/js/90.92e44c0e.js"><link rel="prefetch" href="/blog/assets/js/91.e9597067.js"><link rel="prefetch" href="/blog/assets/js/92.1641d853.js"><link rel="prefetch" href="/blog/assets/js/93.bd05d341.js"><link rel="prefetch" href="/blog/assets/js/94.c6c1e860.js"><link rel="prefetch" href="/blog/assets/js/95.0388a977.js"><link rel="prefetch" href="/blog/assets/js/96.7041224d.js"><link rel="prefetch" href="/blog/assets/js/97.112b03da.js"><link rel="prefetch" href="/blog/assets/js/98.28186c50.js"><link rel="prefetch" href="/blog/assets/js/99.6796a4e4.js"><link rel="prefetch" href="/blog/assets/js/vendors~docsearch.cdf71c8e.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.76cb5f71.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/logo.png" alt="前端那些事儿" class="logo"> <span class="site-name can-hide">前端那些事儿</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/blog/base/" class="nav-link">
  前端基础
</a></div><div class="nav-item"><a href="/blog/vue/" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/blog/react/" class="nav-link router-link-active">
  React
</a></div><div class="nav-item"><a href="/blog/node/" class="nav-link">
  Node
</a></div><div class="nav-item"><a href="/blog/devops/" class="nav-link">
  前端工程化
</a></div><div class="nav-item"><a href="/blog/mobile/" class="nav-link">
  泛客户端
</a></div><div class="nav-item"><a href="/blog/architecture/" class="nav-link">
  架构&amp;方案
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="GitHub" class="dropdown-title"><span class="title">GitHub</span> <span class="arrow down"></span></button> <button type="button" aria-label="GitHub" class="mobile-dropdown-title"><span class="title">GitHub</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/jonny-wei" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/jonny-wei/sushi-js" target="_blank" rel="noopener noreferrer" class="nav-link external">
  JS 寿司
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/blog/base/" class="nav-link">
  前端基础
</a></div><div class="nav-item"><a href="/blog/vue/" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/blog/react/" class="nav-link router-link-active">
  React
</a></div><div class="nav-item"><a href="/blog/node/" class="nav-link">
  Node
</a></div><div class="nav-item"><a href="/blog/devops/" class="nav-link">
  前端工程化
</a></div><div class="nav-item"><a href="/blog/mobile/" class="nav-link">
  泛客户端
</a></div><div class="nav-item"><a href="/blog/architecture/" class="nav-link">
  架构&amp;方案
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="GitHub" class="dropdown-title"><span class="title">GitHub</span> <span class="arrow down"></span></button> <button type="button" aria-label="GitHub" class="mobile-dropdown-title"><span class="title">GitHub</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/jonny-wei" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/jonny-wei/sushi-js" target="_blank" rel="noopener noreferrer" class="nav-link external">
  JS 寿司
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>React</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/react/" aria-current="page" class="sidebar-link">React JSX</a></li><li><a href="/blog/react/warmup/react-component.html" class="sidebar-link">React 组件及通信</a></li><li><a href="/blog/react/warmup/react-state.html" class="sidebar-link">React State</a></li><li><a href="/blog/react/warmup/react-props.html" class="sidebar-link">React Props</a></li><li><a href="/blog/react/warmup/react-lifecycle.html" class="sidebar-link">React 生命周期</a></li><li><a href="/blog/react/warmup/react-ref.html" class="sidebar-link">React Ref</a></li><li><a href="/blog/react/warmup/react-context.html" class="sidebar-link">React Context</a></li><li><a href="/blog/react/warmup/react-css.html" class="sidebar-link">React 中 CSS 的模块化</a></li><li><a href="/blog/react/warmup/react-hoc.html" class="sidebar-link">React HOC</a></li><li><a href="/blog/react/warmup/react-render.html" class="sidebar-link">React 渲染优化</a></li><li><a href="/blog/react/warmup/react-router.html" class="sidebar-link">React Router</a></li><li><a href="/blog/react/warmup/react-redux.html" class="sidebar-link">React Rudex</a></li><li><a href="/blog/react/warmup/react-mobx.html" class="sidebar-link">React Mobx</a></li><li><a href="/blog/react/warmup/react-keepalive.html" class="sidebar-link">实现 KeepAlive</a></li><li><a href="/blog/react/warmup/react-state-v18.html" class="sidebar-link">V18 - Automatic Batching</a></li><li><a href="/blog/react/warmup/react-transition.html" class="sidebar-link">V18 - Transition</a></li><li><a href="/blog/react/warmup/react-suspense.html" class="sidebar-link">V18 - Suspense</a></li><li><a href="/blog/react/warmup/react-useSyncExternalStore.html" class="sidebar-link">V18 - useSyncExternalStore</a></li><li><a href="/blog/react/warmup/react-ssr.html" class="sidebar-link">V18 - Streaming SSR</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>React源码解析</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/react/react/react-reconciler.html" class="sidebar-link">Reconciler 调和器</a></li><li><a href="/blog/react/react/react-priority.html" class="sidebar-link">React 优先级管理</a></li><li><a href="/blog/react/react/react-scheduler.html" class="sidebar-link">Scheduler 调度器</a></li><li><a href="/blog/react/react/react-render.html" aria-current="page" class="active sidebar-link">Render 阶段</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/react/react/react-render.html#流程概述" class="sidebar-link">流程概述</a></li><li class="sidebar-sub-header"><a href="/blog/react/react/react-render.html#最小更新单元-state" class="sidebar-link">最小更新单元 State</a></li><li class="sidebar-sub-header"><a href="/blog/react/react/react-render.html#调度任务的初始化工作" class="sidebar-link">调度任务的初始化工作</a></li><li class="sidebar-sub-header"><a href="/blog/react/react/react-render.html#beginwork" class="sidebar-link">beginWork</a></li></ul></li><li><a href="/blog/react/react/react-commit.html" class="sidebar-link">Commit 阶段</a></li><li><a href="/blog/react/react/react-diff.html" class="sidebar-link">React Diff 算法</a></li><li><a href="/blog/react/react/react-hooks.html" class="sidebar-link">React Hooks 理解</a></li><li><a href="/blog/react/react/react-context.html" class="sidebar-link">React Context 原理</a></li><li><a href="/blog/react/react/react-event.html" class="sidebar-link">React 事件系统</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="render-阶段"><a href="#render-阶段" class="header-anchor">#</a> Render 阶段</h1> <h2 id="流程概述"><a href="#流程概述" class="header-anchor">#</a> 流程概述</h2> <p>当组件更新，本质上是从 fiberRoot 开始深度调和 fiber 树。render 阶段的核心就是如何<strong>创建 Fiber Node</strong> 以及 <strong>构建 Fiber Tree</strong>。render 阶段开始于 <code>performSyncWorkOnRoot</code> 或 <code>performConcurrentWorkOnRoot</code>方法的调用。这取决于本次更新是同步更新还是异步更新。这两个方法中会调用如下两个方法：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// performSyncWorkOnRoot会调用该方法</span>
<span class="token keyword">function</span> <span class="token function">workLoopSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>workInProgress <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">performUnitOfWork</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// performConcurrentWorkOnRoot会调用该方法</span>
<span class="token keyword">function</span> <span class="token function">workLoopConcurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>workInProgress <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">shouldYield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">performUnitOfWork</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>可以看到，他们唯一的区别是是否调用<code>shouldYield</code>。如果当前浏览器帧没有剩余时间，<code>shouldYield</code>会中止循环，直到浏览器有空闲时间后再继续遍历。</p> <ul><li><p><code>workInProgress</code>代表当前已创建的<code>workInProgress fiber</code>。</p></li> <li><p><code>performUnitOfWork</code>方法会创建下一个<code>Fiber节点</code>并赋值给<code>workInProgress</code>，并将<code>workInProgress</code>与已创建的<code>Fiber节点</code>连接起来构成<code>Fiber树</code>。</p></li></ul> <p><code>Fiber Reconciler</code>是从<code>Stack Reconciler</code>重构而来，通过遍历的方式实现可中断的递归，所以<code>performUnitOfWork</code>的工作可以分为两部分：“递”和“归”。</p> <h4 id="递-阶段"><a href="#递-阶段" class="header-anchor">#</a> “递”阶段</h4> <p>首先从<code>rootFiber</code>开始向下深度优先遍历。为遍历到的每个<code>Fiber节点</code>调用 <strong>beginWork方法</strong>。该方法会根据传入的<code>Fiber节点</code>创建<code>子Fiber节点</code>，并将这两个<code>Fiber节点</code>连接起来。</p> <p>当遍历到叶子节点（即没有子组件的组件）时就会进入“归”阶段。</p> <h4 id="归-阶段"><a href="#归-阶段" class="header-anchor">#</a> “归”阶段</h4> <p>在“归”阶段会调用 <strong>completeWork 方法</strong> 处理<code>Fiber节点</code>。当某个<code>Fiber节点</code>执行完<code>completeWork</code>，如果其存在<code>兄弟Fiber节点</code>（即<code>fiber.sibling !== null</code>），会进入其<code>兄弟Fiber</code>的“递”阶段。如果不存在<code>兄弟Fiber</code>，会进入<code>父级Fiber</code>的“归”阶段。</p> <p>“递”和“归”阶段会交错执行直到“归”到<code>rootFiber</code>。至此，<code>render阶段</code>的工作就结束了。</p> <ul><li>组件 A 触发 <code>setState</code> 或者 <code>useState</code> 更新视图，既然 <code>fiber</code> 是从 root 开始更新，那么如何找到对应的 A 并 rerender 的呢？</li> <li>组件类型 fiber 进行 <code>beginWork</code> 就一定会进行 <code>render</code> 吗？</li></ul> <h2 id="最小更新单元-state"><a href="#最小更新单元-state" class="header-anchor">#</a> 最小更新单元 State</h2> <p>虽然在 React V18 引入订阅外部数据源的 <code>useMutableSource</code>。但在当前版本的 React 中，视图的更新基本都来源于内部 state 的改变。如果有一个组件 A ，如果想要它更新，那么场景有如下情况：</p> <ul><li>组件本身改变 <code>state</code> 。函数 <code>useState</code> | <code>useReducer</code> ，类组件 <code>setState</code> | <code>forceUpdate</code>。</li> <li><code>props</code> 改变，由组件更新带来的子组件的更新。</li> <li><code>context</code>更新，并且该组件消费了当前 <code>context</code> 。</li></ul> <p>无论是上面哪种方式，本质上都是 state 的变化。</p> <ul><li>props 改变来源于父级组件的 state 变化。</li> <li>context 变化来源于 <code>Provider</code> 中 value 变化，而 value 一般情况下也是 state 或者是 state 衍生产物。</li></ul> <p><code>state</code> 改变是在组件对应的 fiber 单位上的，之前的 fiber 章节讲到了在 React 的世界里会存在多种多样的 fiber 类型， 而开发者平时使用的组件 <code>function Component</code> 或者 <code>Class Component</code> 也是两种不同的 fiber 类型。而且 React 底层对它们的处理逻辑也不相同。</p> <ul><li>比如更新类组件用的是 <code>updateClassComponent</code>，它做的事情是初始化时候实例化类组件，更新的话那么直接调用 render 得到新的 <code>children</code> ；</li> <li>更新函数组件用的是 <code>updateFunctionComponent</code>，里面调用 <code>renderWithHooks</code> 执行函数组件并依次调用 <code>hooks</code>。</li></ul> <p>那么在整个 <code>React</code> 系统中，能够更新 state 的基本都在组件层面上，换句话说只有组件才能出发更新，比如 <code>div</code> 元素 hostComponent 类型的 fiber，它是无法独立的自我更新的，只能依赖于父类的组件更新 state ，但是在调和阶段，它也会作为一个任务单元进入到 workLoop 中 ；综上所述，可以这么理解</p> <ul><li><strong>fiber是调和过程中的最小单元，每一个需要调和的 fiber 都会进入 workLoop 中。</strong></li> <li><strong>而组件是最小的更新单元，React 的更新源于数据层 state 的变化。</strong></li></ul> <h2 id="调度任务的初始化工作"><a href="#调度任务的初始化工作" class="header-anchor">#</a> 调度任务的初始化工作</h2> <p>以组件类型的 fiber 调和流程来理解组件更新流程。类组件在 render 阶段的一个重要作用就是产生新的 children ，也就是我们常说的 rerender。只有产生新的 children ，接下来才能深度遍历 children ，改变视图。每一个需要调和的 fiber 都要经历一个过程叫做 beginWork ，在 beginWork 流程中将执行上述各种 fiber 的更新函数。</p> <p>那么对于组件类型 fiber 说，进入到 workLoop 中，那么一定会 <code>rerender</code> 吗？ 答案是否定的，解析来看几种情况。</p> <p>主要看一下如下 demo ：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">/* 子组件2 */</span>
<span class="token keyword">function</span> <span class="token function">Child2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>子组件 <span class="token number">2</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token punctuation">}</span>
<span class="token comment">/* 子组件1 */</span>
<span class="token keyword">function</span> <span class="token function">Child1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">[</span> num <span class="token punctuation">,</span> setNumber <span class="token punctuation">]</span> <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
        子组件 <span class="token punctuation">{</span>num<span class="token punctuation">}</span>
        <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setNumber</span><span class="token punctuation">(</span>num<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token operator">&gt;</span>按钮<span class="token number">1</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
     <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token punctuation">}</span>
<span class="token comment">/* 父组件 */</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">Index</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">[</span> num <span class="token punctuation">,</span> setNumber <span class="token punctuation">]</span> <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>父组件 <span class="token punctuation">{</span>num<span class="token punctuation">}</span> <span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>Child1 <span class="token operator">/</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>Child2 <span class="token operator">/</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span> <span class="token function">setNumber</span><span class="token punctuation">(</span>num<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token operator">&gt;</span>按钮<span class="token number">2</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p><strong>场景一</strong>：如上 demo 中，当点击 <code>Child1</code> 的 <strong>按钮1</strong> 的时候，Child1 会渲染，那么 Child1 自然会进入到 <code>beginWork</code> 流程中，那么疑问来了：</p> <ul><li>问题一：父组件 <code>Index</code> 没有更新，会 rerender 吗？那么有会进入 <code>beginWork</code> 流程吗 ？</li> <li>问题二：<code>Child2</code> 会进入 <code>beginWork</code>流程吗 ？</li> <li>问题三：如果 <code>Index</code> 会 <code>beginWork</code>，那么 React 从 Root fiber 开始调和的时候，是如何找到更新的事发点 Index 的呢？</li></ul> <p><strong>场景二</strong>：在如上 demo 中，当点击 Index 中的 <strong>按钮2</strong> 的时候：</p> <ul><li>问题四：<code>Index</code> 因为本身的 <code>state</code> 改变会更新，那么 <code>Child1</code> 和 <code>Child2</code> 为什么会跟着更新。</li></ul> <p>接下来我们开始以一次更新开始，分析调和过程中 beginWork 流程。</p> <p>在正式流程分析之前，先来看一下 v17 引出的新的概念，在 v16 版本，任务的优先级用 expirationTime 表示，在 v17 版本被 lane 取缔。</p> <ul><li><strong>lane</strong> ： 更新优先级。（在一次更新任务中，将赋予给更新的 fiber 的一个更新优先级 lane。）</li> <li><strong>childLanes</strong>：<code>children</code> 中更新优先级。（如果当前 fiber 的 child 中有高优先级任务，那么当前 fiber 的 childLanes 等于当前优先级）。</li></ul> <h3 id="scheduleupdateonfiber"><a href="#scheduleupdateonfiber" class="header-anchor">#</a> scheduleUpdateOnFiber</h3> <p>React 更新任务的起点 - <code>scheduleUpdateOnFiber</code>。</p> <p><strong>类组件 setState 更新</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// react-reconciler/src/ReactFiberClassComponent.new.js -&gt; classComponentUpdater</span>
<span class="token function">enqueueSetState</span><span class="token punctuation">(</span><span class="token parameter">inst<span class="token punctuation">,</span> payload<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
     <span class="token keyword">const</span> fiber <span class="token operator">=</span> <span class="token function">getInstance</span><span class="token punctuation">(</span>inst<span class="token punctuation">)</span><span class="token punctuation">;</span>       
     <span class="token keyword">const</span> lane <span class="token operator">=</span> <span class="token function">requestUpdateLane</span><span class="token punctuation">(</span>fiber<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token function">scheduleUpdateOnFiber</span><span class="token punctuation">(</span>fiber<span class="token punctuation">,</span> lane<span class="token punctuation">,</span> eventTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><strong>函数组件 useState 更新</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// react-reconciler/src/ReactFiberHooks.new.js -&gt; dispatchReducerAction</span>
<span class="token keyword">function</span> <span class="token function">dispatchReducerAction</span><span class="token punctuation">(</span><span class="token parameter">fiber<span class="token punctuation">,</span>queue<span class="token punctuation">,</span>action</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">const</span> lane <span class="token operator">=</span> <span class="token function">requestUpdateLane</span><span class="token punctuation">(</span>fiber<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">scheduleUpdateOnFiber</span><span class="token punctuation">(</span>fiber<span class="token punctuation">,</span> lane<span class="token punctuation">,</span> eventTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>如上代码都是精简后，保留的最核心的流程。可以明确看到，无论是组件更新的本质就是：</p> <ul><li>创建一个任务优先级 lane。</li> <li>然后进行 <strong>scheduleUpdateOnFiber</strong>。 那么这个 scheduleUpdateOnFiber 应该就是整个 React 更新任务的开始。</li></ul> <h4 id="scheduleupdateonfiber-开始更新-fiber"><a href="#scheduleupdateonfiber-开始更新-fiber" class="header-anchor">#</a> scheduleUpdateOnFiber 开始更新 fiber</h4> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// react-reconciler/src/ReactFiberWorkLoop.new.js -&gt; scheduleUpdateOnFiber</span>
<span class="token keyword">function</span> <span class="token function">scheduleUpdateOnFiber</span><span class="token punctuation">(</span><span class="token parameter">fiber<span class="token punctuation">,</span>lane</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">/* 递归向上标记更新优先级 */</span>
    <span class="token keyword">const</span> root <span class="token operator">=</span> <span class="token function">markUpdateLaneFromFiberToRoot</span><span class="token punctuation">(</span>fiber<span class="token punctuation">,</span> lane<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span>
    <span class="token comment">/* 如果当前 root 确定更新，那么会执行 ensureRootIsScheduled */</span>
    <span class="token function">ensureRootIsScheduled</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> eventTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>scheduleUpdateOnFiber 主要做了两件事：</p> <ul><li>第一个就是通过当前的更新优先级 lane ，把当前 fiber 到 rootFiber 的父级链表上的所有优先级都给更新了。</li> <li>如果当前 fiber 确定更新，那么会调用 <code>ensureRootIsScheduled</code></li></ul> <h4 id="优先级标记"><a href="#优先级标记" class="header-anchor">#</a> 优先级标记</h4> <p><strong>那么 markUpdateLaneFromFiberToRoot 如何标记的优先级？</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// react-reconciler/src/ReactFiberWorkLoop.new.js -&gt; markUpdateLaneFromFiberToRoot</span>
<span class="token comment">/**
 * @param {*} sourceFiber 发生 state 变化的fiber ，比如组件 A 触发了 useState ，那么组件 A 对应的 fiber 就是 sourceFiber
 * @param {*} lane        产生的更新优先级
 */</span>
<span class="token keyword">function</span> <span class="token function">markUpdateLaneFromFiberToRoot</span><span class="token punctuation">(</span><span class="token parameter">sourceFiber<span class="token punctuation">,</span>lane</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">/* 更新当前 fiber 上 */</span>
    sourceFiber<span class="token punctuation">.</span>lanes <span class="token operator">=</span> <span class="token function">mergeLanes</span><span class="token punctuation">(</span>sourceFiber<span class="token punctuation">.</span>lanes<span class="token punctuation">,</span> lane<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* 更新缓存树上的 lanes */</span>
    <span class="token keyword">let</span> alternate <span class="token operator">=</span> sourceFiber<span class="token punctuation">.</span>alternate<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>alternate <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> alternate<span class="token punctuation">.</span>lanes <span class="token operator">=</span> <span class="token function">mergeLanes</span><span class="token punctuation">(</span>alternate<span class="token punctuation">.</span>lanes<span class="token punctuation">,</span> lane<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* 当前更新的 fiber */</span>
    <span class="token keyword">let</span> node <span class="token operator">=</span> sourceFiber<span class="token punctuation">;</span>
    <span class="token comment">/* 找到返回父级 */</span>
    <span class="token keyword">let</span> parent <span class="token operator">=</span> sourceFiber<span class="token punctuation">.</span>return<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>parent <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">/* TODO: 更新 childLanes 字段 */</span>
        parent<span class="token punctuation">.</span>childLanes <span class="token operator">=</span> <span class="token function">mergeLanes</span><span class="token punctuation">(</span>parent<span class="token punctuation">.</span>childLanes<span class="token punctuation">,</span> lane<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>alternate <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  alternate<span class="token punctuation">.</span>childLanes <span class="token operator">=</span> <span class="token function">mergeLanes</span><span class="token punctuation">(</span>alternate<span class="token punctuation">.</span>childLanes<span class="token punctuation">,</span> lane<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
        <span class="token comment">/* 递归遍历更新 */</span>
        node <span class="token operator">=</span> parent<span class="token punctuation">;</span>
        parent <span class="token operator">=</span> parent<span class="token punctuation">.</span>return<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>markUpdateLaneFromFiberToRoot 做的事很重要：</p> <ul><li>首先会更新当前 fiber 上的更新优先级。在 fiber 章节我们讲过，fiber 架构采用 ‘连体婴’形式的双缓冲树，所有还要更新当前 fiber 的缓冲树 <code>alternate</code> 上的优先级。</li> <li>然后会递归向上把父级连上的 childLanes 都更新，更新成当前的任务优先级。</li></ul> <p>为什么向上递归更新父级的 childLanes ？</p> <ul><li>所有的 fiber 是通过一颗 fiber 树关联到一起的，如果组件 A 发生一次更新，React 是从 root 开始深度遍历更新 fiber 树。</li> <li>那么更新过程中需要深度遍历整个 fiber 树吗？，当然也不是，那么只有一个组件更新，所有的 fiber 节点都调和无疑是性能上的浪费。</li> <li>既然要从头更新，又不想调和整个 fiber 树，那么如何找到更新的组件 A 呢？这个时候 <strong><code>childLanes</code></strong> 就派上用场了，如果 A 发生了更新，那么先向上递归更新父级链的 <code>childLanes</code>，接下来从 Root Fiber 向下调和的时候，发现 childLanes 等于当前更新优先级，那么说明它的 child 链上有新的更新任务，则会继续向下调和，反之退出调和流程。</li></ul> <p><strong>Root Fiber 是通过 childLanes 逐渐向下调和找到需要更新的组件的。</strong></p> <p><img src="/blog/images/react/render1.png" alt="render1"></p> <p>整个 fiber 树调和流程。</p> <ul><li>第一阶段是发生更新，那么产生一个更新优先级 <code>lane</code> 。</li> <li>第二阶段向上标记 childLanes 过程。</li> <li>第三阶段是向下调和过程，有的同学会问，为什么 A 会被调和，原因是 A 和 B 是同级，如果父级元素调和，并且向下调和，那么父级的第一级子链上的 fiber 都会进入调和流程。从 fiber 关系上看，Root 先调和的是 child 指针上的 A ，然后 A 会退出向下调和，接下来才是 sibling B，接下来 B 会向下调和，通过 childLanes 找到当事人 F，然后 F 会触发 render 更新。这也就解决问题2，Child2 的调和问题。</li></ul> <p>通过上述我们知道了如何找到 F 并执行 render 的，那么还有一个问题，就是 B，E 会向下调和，如果它们是组件，那么会 render 么，答案是否定的，要记住的是<strong>调和过程并非 render 过程</strong>，调和过程有可能会触发 render 函数，也有可能只是继续向下调和，而本身不会执行 render 。</p> <p>既然知道了如何去更新 childLanes ，以及更新 childLanes 的意义，我们接着向下分析流程。在 scheduleUpdateOnFiber 中，最后会调用 <code>ensureRootIsScheduled</code> ，那么它的作用又是什么呢？</p> <p>ensureRootIsScheduled 的作用就是根据任务的类型，发起异步调度任务，在调度章节已经讲了调度流程。接下来会走调度的流程。</p> <ul><li>对于 <code>legacy sync</code> 模式最后的更新任务是 <code>performSyncWorkOnRoot</code> 。</li> <li>对于 <code>Concurrent</code> 模式最后的更新任务是 <code>performConcurrentWorkOnRoot</code>。</li></ul> <h3 id="从-workloop-到-beginwork"><a href="#从-workloop-到-beginwork" class="header-anchor">#</a> 从 workLoop 到 beginWork</h3> <p>这里主要以 legacy 模式为主，performSyncWorkOnRoot ：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// react-reconciler/src/ReactFiberWorkLoop.new.js -&gt; performSyncWorkOnRoot</span>
<span class="token keyword">function</span> <span class="token function">performSyncWorkOnRoot</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* render 阶段 */</span>
    <span class="token keyword">let</span> exitStatus <span class="token operator">=</span> <span class="token function">renderRootSync</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> lanes<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* commit 阶段 */</span>
    <span class="token function">commitRoot</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* 如果有其他的等待中的任务，那么继续更新 */</span>
    <span class="token function">ensureRootIsScheduled</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>调和的两大阶段 <code>render</code> 和 <code>commit</code> 都在这个函数中执行。</p> <ul><li><code>renderRootSync</code> 代表 render 阶段。</li> <li><code>commitRoot</code> 代表 commit 阶段。</li> <li>当 render 和 commit 阶段执行之后，如果有其他的等待中的任务，那么继续执行调度任务。</li></ul> <p>到此为止，一次更新调度任务的初始化工作完成。开始正式进入调和阶段。对前戏阶段做一下总结，流程图如下：</p> <p><img src="/blog/images/react/render2.png" alt="render2"></p> <h4 id="workloop"><a href="#workloop" class="header-anchor">#</a> workLoop</h4> <p>renderRootSync 做了什么？</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// react-reconciler/src/ReactFiberWorkLoop.new.js -&gt; renderRootSync</span>
<span class="token keyword">function</span> <span class="token function">renderRootSync</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">,</span>lanes</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">workLoopSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* workLoop完毕后，证明所有节点都遍历完毕，那么重置状态，进入 commit 阶段 */</span>
    workInProgressRoot <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    workInProgressRootRenderLanes <span class="token operator">=</span> NoLanes<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>renderRootSync 核心功能：</p> <ul><li>执行 <code>workLoopSync</code>。</li> <li><code>workLoop</code> 完毕后，证明所有节点都遍历完毕，那么重置状态，进入 <code>commit</code> 阶段。</li></ul> <p><code>workLoopSync</code> 在整个 render 流程中充当的角色非常重要，可以把 <code>workLoopSync</code> 当作一个循环运作的加工器，每一个需要调和的 fiber 可以当作一个零件，每一个零件都需要进入加工器，如果没有待加工的零件，那么加工器才停止运转。下面就是加工器的具体实现。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// react-reconciler/src/ReactFiberWorkLoop.new.js -&gt; workLoopSync</span>
<span class="token keyword">function</span> <span class="token function">workLoopSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 循环执行 performUnitOfWork ，一直到 workInProgress 为空 */</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>workInProgress <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">performUnitOfWork</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ul><li>如上只要 <code>workInProgress</code> 不为 <code>null</code>（还有需要调和的 fiber），那么 workLoopSync 会循环调用 <code>performUnitOfWork</code>。</li></ul> <p>当 Concurrent 模式下会通过 <code>shouldYield</code> ，来判断有没有过期的任务，有过期任务，会中断 workLoop ，那么也就是说明了<strong>render阶段是可以被打断的。</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">while</span> <span class="token punctuation">(</span>workInProgress <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">shouldYield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">performUnitOfWork</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h4 id="performunitofwork"><a href="#performunitofwork" class="header-anchor">#</a> performUnitOfWork</h4> <p>回到 <code>workLoopSync</code> 流程上来，fiber 树是深度优先遍历得到的，在遍历完父节点，那么接下来就会遍历子节点。在这其中，每一个调和的 fiber 都将作为 <code>workInProgress</code> 进行调和更新。无论什么模式，workLoop 的执行单元都是 fiber 。而且更新单元的函数叫做 <code>performUnitOfWork</code> 。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// react-reconciler/src/ReactFiberWorkLoop.new.js -&gt; performUnitOfWork</span>
<span class="token keyword">function</span> <span class="token function">performUnitOfWork</span><span class="token punctuation">(</span><span class="token parameter">unitOfWork</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">const</span> current <span class="token operator">=</span> unitOfWork<span class="token punctuation">.</span>alternate<span class="token punctuation">;</span>
    <span class="token keyword">let</span>  next <span class="token operator">=</span> <span class="token function">beginWork</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> unitOfWork<span class="token punctuation">,</span> subtreeRenderLanes<span class="token punctuation">)</span><span class="token punctuation">;</span>
    unitOfWork<span class="token punctuation">.</span>memoizedProps <span class="token operator">=</span> unitOfWork<span class="token punctuation">.</span>pendingProps<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token function">completeUnitOfWork</span><span class="token punctuation">(</span>unitOfWork<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      workInProgress <span class="token operator">=</span> next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="beginwork"><a href="#beginwork" class="header-anchor">#</a> beginWork</h2> <h3 id="beginwork-发生场景"><a href="#beginwork-发生场景" class="header-anchor">#</a> beginWork 发生场景</h3> <p>假设有一个组件 fiber 链：<code>root Fiber --child--&gt; A组件 --child--&gt; B组件 --child--&gt; C组件</code>。</p> <p><img src="/blog/images/react/render3.png" alt="render3"></p> <p>以组件B 为参考，来看一下 React 如何调和的，那么一次更新就有可能有三种场景：</p> <ol><li>场景一：<strong>更新 A 组件</strong>，那么 A 触发更新，那么如果 B,C 没有做渲染控制处理（比如 memo PureComponent），那么更新会波动到 B ， C，那么 A，B，C 都会 rerender。</li></ol> <p><img src="/blog/images/react/render4.png" alt="render4"></p> <ol start="2"><li>场景二：<strong>当更新 B 组件</strong>，那么组件 A fiber 会被标记，然后 A 会调和，但是不会 rerender；组件 B 是当事人，既会进入调和，也会 rerender；组件 C 受到父组件 B 的影响，会 rerender。</li></ol> <p><img src="/blog/images/react/render5.png" alt="render5"></p> <ol start="3"><li>场景三：<strong>当更新 C 件</strong>，那么 A，B 会进入调和流程，但是不会 rerender，C 是当事人，会调和并 rerender。</li></ol> <p><img src="/blog/images/react/render6.png" alt="render6"></p> <p>如上的场景本质上都在 beginWork 中进行的，那么 beginWork 是如何处理这些逻辑的：</p> <h3 id="beginwork-的两个阶段"><a href="#beginwork-的两个阶段" class="header-anchor">#</a> beginWork 的两个阶段</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// react-reconciler/src/ReactFiberBeginWork.new.js -&gt; beginWork</span>
<span class="token comment">/**
 * @param {*} current         current 树 fiber 
 * @param {*} workInProgress  workInProgress 树 fiber 
 * @param {*} renderLanes     当前的 render 优先级
 * @returns 
 */</span>
<span class="token keyword">function</span> <span class="token function">beginWork</span><span class="token punctuation">(</span><span class="token parameter">current<span class="token punctuation">,</span>workInProgress<span class="token punctuation">,</span>renderLanes</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">/* -------------------第一部分-------------------- */</span>
    <span class="token comment">// update时：如果current存在可能存在优化路径，可以复用current（即上一次更新的Fiber节点）</span>
    <span class="token comment">// current!== null 来判断当前 fiber 是否创建过，如果第一次 mounted ， 那么 current 为 null</span>
    <span class="token comment">// 第一阶段主要针对更新的情况。如果初始化，那么直接跳过第一阶段，到第二阶段。</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>current <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
        <span class="token comment">/* 更新流程 */</span>
        <span class="token comment">/* current 树上上一次渲染后的 props */</span>
        <span class="token keyword">const</span> oldProps <span class="token operator">=</span> current<span class="token punctuation">.</span>memoizedProps<span class="token punctuation">;</span>
        <span class="token comment">/* workInProgress 树上这一次更新的 props  */</span>
        <span class="token keyword">const</span> newProps <span class="token operator">=</span> workInProgress<span class="token punctuation">.</span>pendingProps<span class="token punctuation">;</span>
        
        <span class="token keyword">if</span><span class="token punctuation">(</span>oldProps <span class="token operator">!==</span> newProps <span class="token operator">||</span>  <span class="token function">hasLegacyContextChanged</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
          didReceiveUpdate <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 当前更新是否来源于父级的更新 为 true 则来自父组件更新</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
          <span class="token comment">/* props 和 context 没有发生变化，检查是否更新来自自身或者 context 改变 */</span>
          <span class="token keyword">const</span> hasScheduledUpdateOrContext <span class="token operator">=</span> <span class="token function">checkScheduledUpdateOrContext</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span>renderLanes<span class="token punctuation">)</span>
          <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>hasScheduledUpdateOrContext<span class="token punctuation">)</span><span class="token punctuation">{</span>
              didReceiveUpdate <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
              <span class="token keyword">return</span>  <span class="token function">attemptEarlyBailoutIfNoScheduledUpdate</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span>workInProgress<span class="token punctuation">,</span>renderLanes<span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
          <span class="token comment">/* 这里省略了一些判断逻辑 */</span>
          didReceiveUpdate <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
      didReceiveUpdate <span class="token operator">=</span> <span class="token boolean">false</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/* -------------------第二部分-------------------- */</span>
    <span class="token comment">/* TODO: 走到这里流程会被调和 | 更新，比如函数执行会执行，类组件会执行 render 。 */</span>
    <span class="token comment">// mount时：根据tag不同，创建不同的子Fiber节点</span>
    <span class="token keyword">switch</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">.</span>tag<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">/* 函数组件的情况 */</span>
        <span class="token keyword">case</span> <span class="token literal-property property">FunctionComponent</span><span class="token operator">:</span> <span class="token punctuation">{</span>
           <span class="token keyword">return</span> <span class="token function">updateFunctionComponent</span><span class="token punctuation">(</span> current<span class="token punctuation">,</span> workInProgress<span class="token punctuation">,</span> Component<span class="token punctuation">,</span> resolvedProps<span class="token punctuation">,</span> renderLanes <span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token comment">/* 类组件的情况 */</span>
        <span class="token keyword">case</span> <span class="token literal-property property">ClassComponent</span><span class="token operator">:</span><span class="token punctuation">{</span>
          <span class="token keyword">return</span> <span class="token function">updateClassComponent</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span>workInProgress<span class="token punctuation">,</span>Component<span class="token punctuation">,</span>resolvedProps<span class="token punctuation">,</span>renderLanes<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token comment">/* 元素类型 fiber &lt;div&gt;, &lt;span&gt;  */</span>
        <span class="token keyword">case</span> <span class="token literal-property property">HostComponent</span><span class="token operator">:</span><span class="token punctuation">{</span>
          <span class="token keyword">return</span> <span class="token function">updateHostComponent</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> workInProgress<span class="token punctuation">,</span> renderLanes<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token comment">/* 其他 fiber 情况 */</span> 
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br></div></div><div class="custom-block tip"><p class="custom-block-title">注意</p> <p>除 rootFiber 以外， 组件 mount 时，由于是首次渲染，是不存在当前组件对应的 Fiber 节点在上一次更新时的 Fiber 节点，即 mount 时 <code>current === null</code>。组件 update时，由于之前已经 mount 过，所以 <code>current !== null</code>。所以我们可以通过<code>current === null ?</code>来区分组件是处于 mount 还是 update。</p></div> <div class="custom-block tip"><p class="custom-block-title">didReceiveUpdate</p> <p>didReceiveUpdate ：这个变量主要证明当前更新是否来源于父级的更新，那么自身并没有更新。比如更新 B 组件，那么 C 组件也会跟着更新，这个情况下 didReceiveUpdate = true。</p></div> <p>基于此原因，<code>beginWork</code>的工作可以分为两部分：</p> <ul><li><code>update</code>时：如果<code>current</code>存在，在满足一定条件时可以复用<code>current</code>节点，这样就能克隆<code>current.child</code>作为<code>workInProgress.child</code>，而不需要新建<code>workInProgress.child</code>。</li> <li><code>mount</code>时：除<code>fiberRootNode</code>以外，<code>current === null</code>。会根据<code>fiber.tag</code>不同，创建不同类型的<code>子Fiber节点</code></li></ul> <h3 id="第一阶段-update"><a href="#第一阶段-update" class="header-anchor">#</a> 第一阶段(update)</h3> <p>首先通过 <code>current!== null</code> 来判断当前 fiber 是否创建过，如果第一次 mounted ， 那么 current 为 null，而第一阶段主要针对更新的情况。如果初始化，那么直接跳过第一阶段，**到第二阶段。**如果是更新流程。那么判断 oldProps === newProps（源码中还判断了老版本 context 是否变化），那么两者相等。一般会有以下几种情况：</p> <p><strong>情况一</strong>：还是回到上面场景上来，如果 C 组件更新，那么 B 组件被标记 ChildLanes 会进入到 beginWork 调和阶段，但是 B 组件本身 props 不会发生变化。</p> <p><strong>情况二</strong>：通过 useMemo 等方式缓存了 React element 元素，在渲染控制章节讲到过。</p> <p><strong>情况三</strong>：就是更新发生在当前组件本身，比如 B 组件发生更新，但是 B 组件的 props 并没有发生变化，所以也会走到这个流程上来。</p> <p>反之如果两者不想等，证明父级 fiber 重新 rerender 导致了 props 改变，此时 didReceiveUpdate = true ，那么第一阶段完成，<strong>进入到第二阶段。</strong></p> <p><strong>新老 props 相等</strong>的处理逻辑如下：</p> <ol><li><strong>checkScheduledUpdateOrContext</strong></li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// react-reconciler/src/ReactFiberBeginWork.new.js -&gt; checkScheduledUpdateOrContext</span>
<span class="token keyword">function</span> <span class="token function">checkScheduledUpdateOrContext</span><span class="token punctuation">(</span><span class="token parameter">current<span class="token punctuation">,</span>renderLanes</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">const</span> updateLanes <span class="token operator">=</span> current<span class="token punctuation">.</span>lanes<span class="token punctuation">;</span>
    <span class="token comment">/* 这种情况说明当前更新 */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">includesSomeLane</span><span class="token punctuation">(</span>updateLanes<span class="token punctuation">,</span> renderLanes<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
     <span class="token comment">/* 如果该 fiber 消费了 context ，并且 context 发生了改变。 */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>enableLazyContextPropagation<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> dependencies <span class="token operator">=</span> current<span class="token punctuation">.</span>dependencies<span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>dependencies <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token function">checkIfContextChanged</span><span class="token punctuation">(</span>dependencies<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>当新老 props 相等情况，首先会检查当前 fiber 的 <code>lane</code> 是否等于当前的更新优先级，如果相等，那么证明更新来源当前 fiber，比如 B 组件发生更新，那么会走这里（情况三）。当然期间也会判断是否有消费 <code>context</code> 并发生了变化。最后返回状态 hasScheduledUpdateOrContext 。</p> <p>如果 <code>hasScheduledUpdateOrContext</code> 为 false，证明当前组件没有更新，也没有 context 上的变化，那么还有一种情况就是 child 可能有更新，但是当前 fiber 不需要更新（情况一）。那么会直接返回 <code>attemptEarlyBailoutIfNoScheduledUpdate</code> ，<strong>退出第二阶段</strong>。</p> <ol start="2"><li><strong>attemptEarlyBailoutIfNoScheduledUpdate</strong></li></ol> <p>attemptEarlyBailoutIfNoScheduledUpdate 这个函数会处理部分 Context 逻辑，但是最重要的是调用了 <strong><code>bailoutOnAlreadyFinishedWork</code></strong> 。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// react-reconciler/src/ReactFiberBeginWork.new.js -&gt; bailoutOnAlreadyFinishedWork</span>
<span class="token keyword">function</span> <span class="token function">bailoutOnAlreadyFinishedWork</span><span class="token punctuation">(</span><span class="token parameter">current<span class="token punctuation">,</span>workInProgress<span class="token punctuation">,</span>renderLanes</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
     <span class="token comment">/* 如果 children 没有高优先级的任务，说明所有的 child 都没有更新，那么直接 返回，child 也不会被调和  */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">includesSomeLane</span><span class="token punctuation">(</span>renderLanes<span class="token punctuation">,</span> workInProgress<span class="token punctuation">.</span>childLanes<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">/* 这里做了流程简化 */</span>
      <span class="token keyword">return</span> <span class="token keyword">null</span> 
    <span class="token punctuation">}</span>
    <span class="token comment">/* 当前fiber没有更新。但是它的children 需要更新。  */</span>
    <span class="token function">cloneChildFibers</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> workInProgress<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> workInProgress<span class="token punctuation">.</span>child<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>bailoutOnAlreadyFinishedWork 流程非常重要。它主要做了两件事：</p> <ul><li>首先通过 includesSomeLane 判断 childLanes 是否是高优先级任务，如果不是，那么所有子孙 fiber 都不需要调和 ，那么直接返回 null，child 也不会被调和。</li> <li>如果 childLanes 优先级高，那么证明 child 需要被调和，但是当前组件不需要，所以会克隆一下 children，返回 children ，那么本身不会 <code>rerender</code>。</li></ul> <h3 id="第二阶段-mount"><a href="#第二阶段-mount" class="header-anchor">#</a> 第二阶段(mount)</h3> <p>第二阶段就是更新 fiber，比如是函数组件，就会调用 <code>updateFunctionComponent</code>，类组件就调用 <code>updateClassComponent</code>，然后进行 rerender 了。</p> <p>对于我们常见的组件类型，如（<code>FunctionComponent</code>/<code>ClassComponent</code>/<code>HostComponent</code>），最终会进入<code>reconcileChildren</code>方法。</p> <ul><li>对于<code>mount</code>的组件，他会创建新的<code>子Fiber节点</code></li> <li>对于<code>update</code>的组件，他会将当前组件与该组件在上次更新时对应的<code>Fiber节点</code>比较（也就是俗称的<code>Diff</code>算法），将比较的结果生成新<code>Fiber节点</code></li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">reconcileChildren</span><span class="token punctuation">(</span>
  <span class="token parameter"><span class="token literal-property property">current</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token literal-property property">workInProgress</span><span class="token operator">:</span> Fiber<span class="token punctuation">,</span>
  <span class="token literal-property property">nextChildren</span><span class="token operator">:</span> any<span class="token punctuation">,</span>
  <span class="token literal-property property">renderLanes</span><span class="token operator">:</span> Lanes</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 对于mount的组件</span>
    workInProgress<span class="token punctuation">.</span>child <span class="token operator">=</span> <span class="token function">mountChildFibers</span><span class="token punctuation">(</span>
      workInProgress<span class="token punctuation">,</span>
      <span class="token keyword">null</span><span class="token punctuation">,</span>
      nextChildren<span class="token punctuation">,</span>
      renderLanes<span class="token punctuation">,</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 对于update的组件</span>
    workInProgress<span class="token punctuation">.</span>child <span class="token operator">=</span> <span class="token function">reconcileChildFibers</span><span class="token punctuation">(</span>
      workInProgress<span class="token punctuation">,</span>
      current<span class="token punctuation">.</span>child<span class="token punctuation">,</span>
      nextChildren<span class="token punctuation">,</span>
      renderLanes<span class="token punctuation">,</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>从代码可以看出，和<code>beginWork</code>一样，他也是通过<code>current === null ?</code>区分<code>mount</code>与<code>update</code>。不论走哪个逻辑，最终他会生成新的子<code>Fiber节点</code>并赋值给<code>workInProgress.child</code>，作为本次<code>beginWork</code> 返回值，并作为下次<code>performUnitOfWork</code>执行时<code>workInProgress</code>的传参。</p> <h3 id="流程总结"><a href="#流程总结" class="header-anchor">#</a> 流程总结</h3> <p>接下来以上述中的<strong>组件B</strong>为例子，在强化一下更新流程。</p> <p><strong>场景一</strong>：当更新 A 时候，那么 A 组件的 fiber 会进入调和流程，会执行 render 形成新的组件 B 对应的 element 元素，接下来调和 B ，因为 B 的 <code>newProps</code> 不等于 <code>oldProps</code>，所以会 <code>didReceiveUpdate = true</code> ，然后更新组件，也会触发 render。（这里都是默认没有渲染控制的场景，比如 <code>memo</code> <code>PureComponent</code> 等 ）。</p> <p><img src="/blog/images/react/render7.png" alt="render7"></p> <p><strong>场景二</strong>：当更新 B 时候，那么 A 组件会标记 childLanes，所以 A 会被调和，但是不会 render，然后到了主角 B ，B 由于新老 props 相等，所以会 <code>checkScheduledUpdateOrContext</code> 流程，判断 lane 等于 renderLanes ，检查到 lane 等于 renderLane，所以会执行更新，触发 render。 C 组件也就跟着更新。</p> <p><img src="/blog/images/react/render8.png" alt="render8"></p> <p><strong>场景三</strong>：当更新 C 时候，那么 A 和 B 组件会标记 childLanes，所以 A 和 B 会被调和，但是不会更新，然后到 C ，C 会走正常流程。</p> <p><img src="/blog/images/react/render9.png" alt="render9"></p> <p><strong>场景四</strong>：还有一种情况，什么时候 B 会跳出调和流程呢。</p> <p><img src="/blog/images/react/render10.png" alt="render10"></p> <h3 id="beginwork-流程图"><a href="#beginwork-流程图" class="header-anchor">#</a> beginWork 流程图</h3> <p><img src="/blog/images/react/render11.png" alt="render11"></p> <p>组件更新和调和过程。rerender 一定会调和，但是调和并不一定 rerender，也有可能找到待更新的子元素。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/react/react/react-scheduler.html" class="prev">
        Scheduler 调度器
      </a></span> <span class="next"><a href="/blog/react/react/react-commit.html">
        Commit 阶段
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----><!----><!----></div></div>
    <script src="/blog/assets/js/app.88ac7007.js" defer></script><script src="/blog/assets/js/2.dc7ae5f9.js" defer></script><script src="/blog/assets/js/1.70fc1187.js" defer></script><script src="/blog/assets/js/142.a29d4427.js" defer></script><script src="/blog/assets/js/20.36f36c92.js" defer></script>
  </body>
</html>
