<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Scheduler 调度器 | 前端那些事儿</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/blog/logo.png">
    <link rel="manifest" href="/blog/manifest.json">
    <link rel="apple-touch-icon" href="/blog/images/icons/apple-icon-152x152.png">
    <meta name="description" content="我命由我不由天，学习吧少年">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
    <meta name="msapplication-TileColor" content="#000000">
    
    <link rel="preload" href="/blog/assets/css/0.styles.f0017422.css" as="style"><link rel="preload" href="/blog/assets/js/app.5c0d645f.js" as="script"><link rel="preload" href="/blog/assets/js/2.dec2e75d.js" as="script"><link rel="preload" href="/blog/assets/js/1.5b9e135c.js" as="script"><link rel="preload" href="/blog/assets/js/161.9c8db632.js" as="script"><link rel="preload" href="/blog/assets/js/20.badbb211.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.cc7e09f3.js"><link rel="prefetch" href="/blog/assets/js/100.dabe221b.js"><link rel="prefetch" href="/blog/assets/js/101.1d5ba7da.js"><link rel="prefetch" href="/blog/assets/js/102.5b35a802.js"><link rel="prefetch" href="/blog/assets/js/103.f2e1cfb2.js"><link rel="prefetch" href="/blog/assets/js/104.717a1120.js"><link rel="prefetch" href="/blog/assets/js/105.ef8ecd83.js"><link rel="prefetch" href="/blog/assets/js/106.50c36972.js"><link rel="prefetch" href="/blog/assets/js/107.2497012e.js"><link rel="prefetch" href="/blog/assets/js/108.483bd993.js"><link rel="prefetch" href="/blog/assets/js/109.faf3aefa.js"><link rel="prefetch" href="/blog/assets/js/11.b60c9933.js"><link rel="prefetch" href="/blog/assets/js/110.afdc922e.js"><link rel="prefetch" href="/blog/assets/js/111.b3b30630.js"><link rel="prefetch" href="/blog/assets/js/112.177f2e74.js"><link rel="prefetch" href="/blog/assets/js/113.b934908a.js"><link rel="prefetch" href="/blog/assets/js/114.6cff1ef3.js"><link rel="prefetch" href="/blog/assets/js/115.615df4ef.js"><link rel="prefetch" href="/blog/assets/js/116.acc1996c.js"><link rel="prefetch" href="/blog/assets/js/117.cbe35c59.js"><link rel="prefetch" href="/blog/assets/js/118.2e646bd5.js"><link rel="prefetch" href="/blog/assets/js/119.79ff9ce3.js"><link rel="prefetch" href="/blog/assets/js/12.c53283e7.js"><link rel="prefetch" href="/blog/assets/js/120.97f3f4e6.js"><link rel="prefetch" href="/blog/assets/js/121.d1c9cee4.js"><link rel="prefetch" href="/blog/assets/js/122.813f1055.js"><link rel="prefetch" href="/blog/assets/js/123.83cce4d2.js"><link rel="prefetch" href="/blog/assets/js/124.d2e31263.js"><link rel="prefetch" href="/blog/assets/js/125.e4d752ad.js"><link rel="prefetch" href="/blog/assets/js/126.4e317378.js"><link rel="prefetch" href="/blog/assets/js/127.7aa5abcb.js"><link rel="prefetch" href="/blog/assets/js/128.0d0449cb.js"><link rel="prefetch" href="/blog/assets/js/129.541876d1.js"><link rel="prefetch" href="/blog/assets/js/13.6bdc6b5d.js"><link rel="prefetch" href="/blog/assets/js/130.b50c1756.js"><link rel="prefetch" href="/blog/assets/js/131.14890a2b.js"><link rel="prefetch" href="/blog/assets/js/132.dd38cfb4.js"><link rel="prefetch" href="/blog/assets/js/133.c236699b.js"><link rel="prefetch" href="/blog/assets/js/134.ab2058c9.js"><link rel="prefetch" href="/blog/assets/js/135.20626c27.js"><link rel="prefetch" href="/blog/assets/js/136.66c83721.js"><link rel="prefetch" href="/blog/assets/js/137.7dd15ccf.js"><link rel="prefetch" href="/blog/assets/js/138.6464ecf9.js"><link rel="prefetch" href="/blog/assets/js/139.7fa8e1f4.js"><link rel="prefetch" href="/blog/assets/js/14.c3201a23.js"><link rel="prefetch" href="/blog/assets/js/140.149ebe7f.js"><link rel="prefetch" href="/blog/assets/js/141.b9067bc8.js"><link rel="prefetch" href="/blog/assets/js/142.34e129c4.js"><link rel="prefetch" href="/blog/assets/js/143.9dbd485f.js"><link rel="prefetch" href="/blog/assets/js/144.7f90ff6d.js"><link rel="prefetch" href="/blog/assets/js/145.4b761da4.js"><link rel="prefetch" href="/blog/assets/js/146.213c5d0e.js"><link rel="prefetch" href="/blog/assets/js/147.be23ddb3.js"><link rel="prefetch" href="/blog/assets/js/148.c161cdfc.js"><link rel="prefetch" href="/blog/assets/js/149.ce1a47f4.js"><link rel="prefetch" href="/blog/assets/js/15.a0b9e44e.js"><link rel="prefetch" href="/blog/assets/js/150.c8304db0.js"><link rel="prefetch" href="/blog/assets/js/151.4694bde0.js"><link rel="prefetch" href="/blog/assets/js/152.fb05e213.js"><link rel="prefetch" href="/blog/assets/js/153.70a6fd63.js"><link rel="prefetch" href="/blog/assets/js/154.6a1f9d84.js"><link rel="prefetch" href="/blog/assets/js/155.779fbb83.js"><link rel="prefetch" href="/blog/assets/js/156.eb193c60.js"><link rel="prefetch" href="/blog/assets/js/157.e052eb9d.js"><link rel="prefetch" href="/blog/assets/js/158.87c66efe.js"><link rel="prefetch" href="/blog/assets/js/159.bfac6e97.js"><link rel="prefetch" href="/blog/assets/js/16.491191e4.js"><link rel="prefetch" href="/blog/assets/js/160.1c265a50.js"><link rel="prefetch" href="/blog/assets/js/162.08656fce.js"><link rel="prefetch" href="/blog/assets/js/163.7ba9ed88.js"><link rel="prefetch" href="/blog/assets/js/164.dc9436f9.js"><link rel="prefetch" href="/blog/assets/js/165.5a379c90.js"><link rel="prefetch" href="/blog/assets/js/166.e508130a.js"><link rel="prefetch" href="/blog/assets/js/167.3463c2ed.js"><link rel="prefetch" href="/blog/assets/js/168.196a44b6.js"><link rel="prefetch" href="/blog/assets/js/169.bf573f56.js"><link rel="prefetch" href="/blog/assets/js/17.89ec8c57.js"><link rel="prefetch" href="/blog/assets/js/170.8825cf2f.js"><link rel="prefetch" href="/blog/assets/js/171.e37cef45.js"><link rel="prefetch" href="/blog/assets/js/172.101ab258.js"><link rel="prefetch" href="/blog/assets/js/173.52f54b75.js"><link rel="prefetch" href="/blog/assets/js/174.d9e8f9f7.js"><link rel="prefetch" href="/blog/assets/js/175.58bd1d44.js"><link rel="prefetch" href="/blog/assets/js/176.01658475.js"><link rel="prefetch" href="/blog/assets/js/177.d84d06e6.js"><link rel="prefetch" href="/blog/assets/js/178.c187efc7.js"><link rel="prefetch" href="/blog/assets/js/179.0e617fe3.js"><link rel="prefetch" href="/blog/assets/js/18.b91f1411.js"><link rel="prefetch" href="/blog/assets/js/180.461b359e.js"><link rel="prefetch" href="/blog/assets/js/181.f6a32104.js"><link rel="prefetch" href="/blog/assets/js/182.16dc1844.js"><link rel="prefetch" href="/blog/assets/js/183.f336285a.js"><link rel="prefetch" href="/blog/assets/js/184.0c197702.js"><link rel="prefetch" href="/blog/assets/js/185.a08d3259.js"><link rel="prefetch" href="/blog/assets/js/186.9256478c.js"><link rel="prefetch" href="/blog/assets/js/187.8e78996f.js"><link rel="prefetch" href="/blog/assets/js/188.86d55068.js"><link rel="prefetch" href="/blog/assets/js/189.243f4482.js"><link rel="prefetch" href="/blog/assets/js/19.cb1f17c8.js"><link rel="prefetch" href="/blog/assets/js/190.0515855c.js"><link rel="prefetch" href="/blog/assets/js/191.5a45d0dd.js"><link rel="prefetch" href="/blog/assets/js/192.b73519d3.js"><link rel="prefetch" href="/blog/assets/js/193.ab975c7d.js"><link rel="prefetch" href="/blog/assets/js/194.d17a7216.js"><link rel="prefetch" href="/blog/assets/js/195.4ef22e15.js"><link rel="prefetch" href="/blog/assets/js/196.d02c94c7.js"><link rel="prefetch" href="/blog/assets/js/197.1c8c2216.js"><link rel="prefetch" href="/blog/assets/js/198.3ad3a1c9.js"><link rel="prefetch" href="/blog/assets/js/199.7078abc5.js"><link rel="prefetch" href="/blog/assets/js/200.5c86734c.js"><link rel="prefetch" href="/blog/assets/js/201.cc24eacb.js"><link rel="prefetch" href="/blog/assets/js/202.95ea7e05.js"><link rel="prefetch" href="/blog/assets/js/203.dc92157f.js"><link rel="prefetch" href="/blog/assets/js/204.8d2381f4.js"><link rel="prefetch" href="/blog/assets/js/205.062fc0fa.js"><link rel="prefetch" href="/blog/assets/js/206.f08174cd.js"><link rel="prefetch" href="/blog/assets/js/207.500b316a.js"><link rel="prefetch" href="/blog/assets/js/208.8a3a45ed.js"><link rel="prefetch" href="/blog/assets/js/209.099f2e3e.js"><link rel="prefetch" href="/blog/assets/js/21.bf0041b7.js"><link rel="prefetch" href="/blog/assets/js/210.f1c95bdf.js"><link rel="prefetch" href="/blog/assets/js/211.0ce80fe5.js"><link rel="prefetch" href="/blog/assets/js/212.9bf0e4e5.js"><link rel="prefetch" href="/blog/assets/js/213.a296a4b4.js"><link rel="prefetch" href="/blog/assets/js/214.47d7b502.js"><link rel="prefetch" href="/blog/assets/js/215.2d17a758.js"><link rel="prefetch" href="/blog/assets/js/216.28a77bde.js"><link rel="prefetch" href="/blog/assets/js/217.bce2a65f.js"><link rel="prefetch" href="/blog/assets/js/218.09fcb7a5.js"><link rel="prefetch" href="/blog/assets/js/219.afad10dd.js"><link rel="prefetch" href="/blog/assets/js/22.48390d4f.js"><link rel="prefetch" href="/blog/assets/js/220.ebc569c6.js"><link rel="prefetch" href="/blog/assets/js/221.6a2478b4.js"><link rel="prefetch" href="/blog/assets/js/222.0c7fe13e.js"><link rel="prefetch" href="/blog/assets/js/223.5afa3b79.js"><link rel="prefetch" href="/blog/assets/js/224.51e80330.js"><link rel="prefetch" href="/blog/assets/js/225.09d0c412.js"><link rel="prefetch" href="/blog/assets/js/226.3043cac7.js"><link rel="prefetch" href="/blog/assets/js/227.4e115357.js"><link rel="prefetch" href="/blog/assets/js/23.35c4ba93.js"><link rel="prefetch" href="/blog/assets/js/24.cc3b12df.js"><link rel="prefetch" href="/blog/assets/js/25.94c095ac.js"><link rel="prefetch" href="/blog/assets/js/26.dc0735bf.js"><link rel="prefetch" href="/blog/assets/js/27.bf58c149.js"><link rel="prefetch" href="/blog/assets/js/28.3cdce864.js"><link rel="prefetch" href="/blog/assets/js/29.6c1aebe8.js"><link rel="prefetch" href="/blog/assets/js/3.cb0627fa.js"><link rel="prefetch" href="/blog/assets/js/30.c5bb1b3d.js"><link rel="prefetch" href="/blog/assets/js/31.d9754d97.js"><link rel="prefetch" href="/blog/assets/js/32.bbc6bc42.js"><link rel="prefetch" href="/blog/assets/js/33.d4bb78a0.js"><link rel="prefetch" href="/blog/assets/js/34.66a4b69e.js"><link rel="prefetch" href="/blog/assets/js/35.c25c83f1.js"><link rel="prefetch" href="/blog/assets/js/36.9eaca2ee.js"><link rel="prefetch" href="/blog/assets/js/37.ff149f3c.js"><link rel="prefetch" href="/blog/assets/js/38.a3fb5426.js"><link rel="prefetch" href="/blog/assets/js/39.d5748ea8.js"><link rel="prefetch" href="/blog/assets/js/4.cbb57fa7.js"><link rel="prefetch" href="/blog/assets/js/40.c821fa3c.js"><link rel="prefetch" href="/blog/assets/js/41.72d168e7.js"><link rel="prefetch" href="/blog/assets/js/42.2c94b2fa.js"><link rel="prefetch" href="/blog/assets/js/43.8cfa3228.js"><link rel="prefetch" href="/blog/assets/js/44.f09abcfc.js"><link rel="prefetch" href="/blog/assets/js/45.f87383bf.js"><link rel="prefetch" href="/blog/assets/js/46.3522c1e1.js"><link rel="prefetch" href="/blog/assets/js/47.a2a63e22.js"><link rel="prefetch" href="/blog/assets/js/48.1a27d0ca.js"><link rel="prefetch" href="/blog/assets/js/49.da2e1be3.js"><link rel="prefetch" href="/blog/assets/js/5.fe065607.js"><link rel="prefetch" href="/blog/assets/js/50.64b6e6f6.js"><link rel="prefetch" href="/blog/assets/js/51.44d3299d.js"><link rel="prefetch" href="/blog/assets/js/52.f44c992f.js"><link rel="prefetch" href="/blog/assets/js/53.50675a1d.js"><link rel="prefetch" href="/blog/assets/js/54.f719facc.js"><link rel="prefetch" href="/blog/assets/js/55.b2101926.js"><link rel="prefetch" href="/blog/assets/js/56.e7ca6c14.js"><link rel="prefetch" href="/blog/assets/js/57.5a322bd3.js"><link rel="prefetch" href="/blog/assets/js/58.4492060e.js"><link rel="prefetch" href="/blog/assets/js/59.9239674f.js"><link rel="prefetch" href="/blog/assets/js/6.68cda050.js"><link rel="prefetch" href="/blog/assets/js/60.508d6f1d.js"><link rel="prefetch" href="/blog/assets/js/61.30eca23b.js"><link rel="prefetch" href="/blog/assets/js/62.c8cd84fa.js"><link rel="prefetch" href="/blog/assets/js/63.fc63838e.js"><link rel="prefetch" href="/blog/assets/js/64.77da6ad5.js"><link rel="prefetch" href="/blog/assets/js/65.8e353ed2.js"><link rel="prefetch" href="/blog/assets/js/66.281a5ac4.js"><link rel="prefetch" href="/blog/assets/js/67.6eeb5ab6.js"><link rel="prefetch" href="/blog/assets/js/68.34d9ae87.js"><link rel="prefetch" href="/blog/assets/js/69.aa119714.js"><link rel="prefetch" href="/blog/assets/js/7.3b8d63a0.js"><link rel="prefetch" href="/blog/assets/js/70.550cd861.js"><link rel="prefetch" href="/blog/assets/js/71.6dbd81eb.js"><link rel="prefetch" href="/blog/assets/js/72.6396e72f.js"><link rel="prefetch" href="/blog/assets/js/73.49e2280e.js"><link rel="prefetch" href="/blog/assets/js/74.2aeff695.js"><link rel="prefetch" href="/blog/assets/js/75.f6cf2df8.js"><link rel="prefetch" href="/blog/assets/js/76.4e2a8355.js"><link rel="prefetch" href="/blog/assets/js/77.daaae178.js"><link rel="prefetch" href="/blog/assets/js/78.cfe556c5.js"><link rel="prefetch" href="/blog/assets/js/79.ddf7c94e.js"><link rel="prefetch" href="/blog/assets/js/80.09f7a474.js"><link rel="prefetch" href="/blog/assets/js/81.712bd61b.js"><link rel="prefetch" href="/blog/assets/js/82.7abf5bc4.js"><link rel="prefetch" href="/blog/assets/js/83.81e8cf55.js"><link rel="prefetch" href="/blog/assets/js/84.2577ee3b.js"><link rel="prefetch" href="/blog/assets/js/85.669410bb.js"><link rel="prefetch" href="/blog/assets/js/86.1194b077.js"><link rel="prefetch" href="/blog/assets/js/87.3b6e5595.js"><link rel="prefetch" href="/blog/assets/js/88.8b840ce1.js"><link rel="prefetch" href="/blog/assets/js/89.fb1f77e4.js"><link rel="prefetch" href="/blog/assets/js/90.e0feae73.js"><link rel="prefetch" href="/blog/assets/js/91.1aa48754.js"><link rel="prefetch" href="/blog/assets/js/92.fede14d8.js"><link rel="prefetch" href="/blog/assets/js/93.3f378b31.js"><link rel="prefetch" href="/blog/assets/js/94.d9208461.js"><link rel="prefetch" href="/blog/assets/js/95.0f530084.js"><link rel="prefetch" href="/blog/assets/js/96.2a1bbb0f.js"><link rel="prefetch" href="/blog/assets/js/97.2301b9cf.js"><link rel="prefetch" href="/blog/assets/js/98.9d5643ce.js"><link rel="prefetch" href="/blog/assets/js/99.4445c278.js"><link rel="prefetch" href="/blog/assets/js/vendors~docsearch.bd3cdb54.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.f0017422.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/logo.png" alt="前端那些事儿" class="logo"> <span class="site-name can-hide">前端那些事儿</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/blog/base/" class="nav-link">
  前端基础
</a></div><div class="nav-item"><a href="/blog/vue/" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/blog/react/" class="nav-link router-link-active">
  React
</a></div><div class="nav-item"><a href="/blog/devops/" class="nav-link">
  前端工程化
</a></div><div class="nav-item"><a href="/blog/mobile/" class="nav-link">
  泛客户端
</a></div><div class="nav-item"><a href="/blog/architecture/" class="nav-link">
  架构与方案
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="GitHub" class="dropdown-title"><span class="title">GitHub</span> <span class="arrow down"></span></button> <button type="button" aria-label="GitHub" class="mobile-dropdown-title"><span class="title">GitHub</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/jonny-wei" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/jonny-wei/sushi-js" target="_blank" rel="noopener noreferrer" class="nav-link external">
  JS 寿司
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/blog/base/" class="nav-link">
  前端基础
</a></div><div class="nav-item"><a href="/blog/vue/" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/blog/react/" class="nav-link router-link-active">
  React
</a></div><div class="nav-item"><a href="/blog/devops/" class="nav-link">
  前端工程化
</a></div><div class="nav-item"><a href="/blog/mobile/" class="nav-link">
  泛客户端
</a></div><div class="nav-item"><a href="/blog/architecture/" class="nav-link">
  架构与方案
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="GitHub" class="dropdown-title"><span class="title">GitHub</span> <span class="arrow down"></span></button> <button type="button" aria-label="GitHub" class="mobile-dropdown-title"><span class="title">GitHub</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/jonny-wei" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/jonny-wei/sushi-js" target="_blank" rel="noopener noreferrer" class="nav-link external">
  JS 寿司
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>React</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/react/" aria-current="page" class="sidebar-link">React JSX</a></li><li><a href="/blog/react/warmup/react-component.html" class="sidebar-link">React 组件及通信</a></li><li><a href="/blog/react/warmup/react-state.html" class="sidebar-link">React State</a></li><li><a href="/blog/react/warmup/react-props.html" class="sidebar-link">React Props</a></li><li><a href="/blog/react/warmup/react-lifecycle.html" class="sidebar-link">React 生命周期</a></li><li><a href="/blog/react/warmup/react-ref.html" class="sidebar-link">React Ref</a></li><li><a href="/blog/react/warmup/react-context.html" class="sidebar-link">React Context</a></li><li><a href="/blog/react/warmup/react-css.html" class="sidebar-link">React 中 CSS 的模块化</a></li><li><a href="/blog/react/warmup/react-hoc.html" class="sidebar-link">React HOC</a></li><li><a href="/blog/react/warmup/react-render.html" class="sidebar-link">React 渲染优化</a></li><li><a href="/blog/react/warmup/react-router.html" class="sidebar-link">React Router</a></li><li><a href="/blog/react/warmup/react-redux.html" class="sidebar-link">React Rudex</a></li><li><a href="/blog/react/warmup/react-mobx.html" class="sidebar-link">React Mobx</a></li><li><a href="/blog/react/warmup/react-keepalive.html" class="sidebar-link">实现 KeepAlive</a></li><li><a href="/blog/react/warmup/react-state-v18.html" class="sidebar-link">V18 - Automatic Batching</a></li><li><a href="/blog/react/warmup/react-transition.html" class="sidebar-link">V18 - Transition</a></li><li><a href="/blog/react/warmup/react-suspense.html" class="sidebar-link">V18 - Suspense</a></li><li><a href="/blog/react/warmup/react-useSyncExternalStore.html" class="sidebar-link">V18 - useSyncExternalStore</a></li><li><a href="/blog/react/warmup/react-ssr.html" class="sidebar-link">V18 - Streaming SSR</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>React源码解析</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/react/react/react-reconciler.html" class="sidebar-link">Reconciler 调和器</a></li><li><a href="/blog/react/react/react-priority.html" class="sidebar-link">React 优先级管理</a></li><li><a href="/blog/react/react/react-scheduler.html" aria-current="page" class="active sidebar-link">Scheduler 调度器</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/react/react/react-scheduler.html#异步调度" class="sidebar-link">异步调度</a></li><li class="sidebar-sub-header"><a href="/blog/react/react/react-scheduler.html#异步调度原理" class="sidebar-link">异步调度原理</a></li><li class="sidebar-sub-header"><a href="/blog/react/react/react-scheduler.html#调度整体流程" class="sidebar-link">调度整体流程</a></li><li class="sidebar-sub-header"><a href="/blog/react/react/react-scheduler.html#异步调度流程" class="sidebar-link">异步调度流程</a></li></ul></li><li><a href="/blog/react/react/react-render.html" class="sidebar-link">Render 阶段</a></li><li><a href="/blog/react/react/react-commit.html" class="sidebar-link">Commit 阶段</a></li><li><a href="/blog/react/react/react-diff.html" class="sidebar-link">React Diff 算法</a></li><li><a href="/blog/react/react/react-hooks.html" class="sidebar-link">React Hooks 理解</a></li><li><a href="/blog/react/react/react-context.html" class="sidebar-link">React Context 原理</a></li><li><a href="/blog/react/react/react-event.html" class="sidebar-link">React 事件系统</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="scheduler-调度器"><a href="#scheduler-调度器" class="header-anchor">#</a> Scheduler 调度器</h1> <ul><li>异步调度原理？</li> <li>React 为什么不用 setTimeout ？</li> <li>说一说React 的时间分片？</li> <li>React 如何模拟 requestIdleCallback？</li> <li>简述一下调度流程？</li></ul> <h2 id="异步调度"><a href="#异步调度" class="header-anchor">#</a> 异步调度</h2> <h3 id="为什么采用异步调度"><a href="#为什么采用异步调度" class="header-anchor">#</a> 为什么采用异步调度</h3> <p>v15 版本的 React 同样面临着如上的问题，由于对于大型的 React 应用，会存在一次更新，递归遍历大量的虚拟 DOM ，造成占用 js 线程，使得浏览器没有时间去做一些动画效果，伴随项目越来越大，项目会越来越卡。</p> <p>如何解决以上的问题呢，首先对比一下 vue 框架，vue 有这 template 模版收集依赖的过程，轻松构建响应式，使得在一次更新中，vue 能够迅速响应，找到需要更新的范围，然后以组件粒度更新组件，渲染视图。但是在 React 中，一次更新 React 无法知道此次更新的波及范围，所以 React 选择从根节点开始 diff ，查找不同，更新这些不同。</p> <p>React 似乎无法打破从 root 开始‘找不同’的命运，但是还是要解决浏览器卡顿问题，那怎么办，解铃还须系铃人，既然更新过程阻塞了浏览器的绘制，那么把 React 的更新，交给浏览器自己控制不就可以了吗，如果浏览器有绘制任务那么执行绘制任务，在空闲时间执行更新任务，就能解决卡顿问题了。与 vue 更快的响应，更精确的更新范围，React 选择更好的用户体验。</p> <h3 id="时间分片"><a href="#时间分片" class="header-anchor">#</a> 时间分片</h3> <p>React 如何让浏览器控制 React 更新呢，首先浏览器每次执行一次事件循环（一帧）都会做如下事情：处理事件，执行 js ，调用 requestAnimationFrame ，布局 Layout ，绘制 Paint ，在一帧执行后，如果没有其他事件，那么浏览器会进入休息时间，那么有的一些不是特别紧急 React 更新，就可以执行了。</p> <p>那么首先就是<strong>如何知道浏览器有空闲时间？</strong></p> <p>requestIdleCallback 是谷歌浏览器提供的一个 API， 在浏览器有空余的时间，浏览器就会调用 requestIdleCallback 的回调。首先看一下 requestIdleCallback的基本用法：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token function">requestIdleCallback</span><span class="token punctuation">(</span>callback<span class="token punctuation">,</span><span class="token punctuation">{</span> timeout <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li>callback 回调，浏览器空余时间执行回调函数。</li> <li>timeout 超时时间。如果浏览器长时间没有空闲，那么回调就不会执行，为了解决这个问题，可以通过 requestIdleCallback 的第二个参数指定一个超时时间。</li></ul> <p>React 为了防止 requestIdleCallback 中的任务由于浏览器没有空闲时间而卡死，所以设置了 5 个优先级。</p> <ul><li><code>Immediate</code> -1 需要立刻执行。</li> <li><code>UserBlocking</code> 250ms 超时时间250ms，一般指的是用户交互。</li> <li><code>Normal</code> 5000ms 超时时间5s，不需要直观立即变化的任务，比如网络请求。</li> <li><code>Low</code> 10000ms 超时时间10s，肯定要执行的任务，但是可以放在最后处理。</li> <li><code>Idle</code> 一些没有必要的任务，可能不会执行。</li></ul> <p>React 的异步更新任务就是通过类似 requestIdleCallback 去向浏览器做一帧一帧请求，等到浏览器有空余时间，去执行 React 的异步更新任务，这样保证页面的流畅。</p> <div class="custom-block tip"><p class="custom-block-title">注意</p> <p>Scheduler 是独立于 React 的包，所以他的优先级也是独立于 React 的优先级。<code>Scheduler</code>对外暴露了一个方法　<code>unstable_runWithPriority</code> 。这个方法接受一个<code>优先级</code>与一个<code>回调函数</code>，在<code>回调函数</code>内部调用获取<code>优先级</code>的方法都会取得第一个参数对应的<code>优先级</code>。</p> <p>在<code>React</code>内部凡是涉及到<code>优先级</code>调度的地方，都会使用<code>unstable_runWithPriority</code>。比如，我们知道<code>commit</code>阶段是同步执行的。可以看到，<code>commit</code>阶段的起点<code>commitRoot</code>方法的优先级为<code>ImmediateSchedulerPriority</code>。<code>ImmediateSchedulerPriority</code>即<code>ImmediatePriority</code>的别名，为最高优先级，会立即执行。</p></div> <h3 id="模拟-requestidlecallback"><a href="#模拟-requestidlecallback" class="header-anchor">#</a> 模拟 requestIdleCallback</h3> <p>但是 requestIdleCallback 目前只有谷歌浏览器支持 ，为了兼容每个浏览器，React需要自己实现一个 requestIdleCallback ，那么就要具备两个条件：</p> <ul><li>实现的这个 requestIdleCallback ，可以主动让出主线程，让浏览器去渲染视图。</li> <li>一次事件循环只执行一次，因为执行一个以后，还会请求下一次的时间片。</li></ul> <p>能够满足上述条件的，就只有 <strong>宏任务</strong>，宏任务是在下次事件循环中执行，不会阻塞浏览器更新。而且浏览器一次只会执行一个宏任务。首先看一下两种满足情况的宏任务。</p> <h4 id="settimeout-fn-0"><a href="#settimeout-fn-0" class="header-anchor">#</a> setTimeout(fn, 0)</h4> <p><code>setTimeout(fn, 0)</code> 可以满足创建宏任务，让出主线程，为什么 React 没选择用它实现 Scheduler 呢？原因是递归执行 setTimeout(fn, 0) 时，最后间隔时间会变成 4 毫秒左右，而不是最初的 1 毫秒。所以 React 优先选择的并不是 setTimeout 实现方案。</p> <p>接下来模拟一下 setTimeout 4毫秒延时的真实场景：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> time <span class="token operator">=</span> <span class="token number">0</span> 
<span class="token keyword">let</span> nowTime <span class="token operator">=</span> <span class="token operator">+</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> timer
<span class="token keyword">const</span> <span class="token function-variable function">poll</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
        <span class="token keyword">const</span> lastTime <span class="token operator">=</span> nowTime
        nowTime <span class="token operator">=</span> <span class="token operator">+</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token string">'递归setTimeout(fn,0)产生时间差：'</span> <span class="token punctuation">,</span> nowTime <span class="token operator">-</span>lastTime <span class="token punctuation">)</span>
        <span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>
    time<span class="token operator">++</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>time <span class="token operator">===</span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h4 id="messagechannel"><a href="#messagechannel" class="header-anchor">#</a> MessageChannel</h4> <p>为了让视图流畅地运行，可以按照人类能感知到最低限度每秒 60 帧的频率划分时间片，这样每个时间片就是 16ms 。也就是这 16 毫秒要完成如上 js 执行，浏览器绘制等操作，而上述 setTimeout 带来的浪费就足足有 4ms，react 团队应该是注意到这 4ms 有点过于铺张浪费，所以才采用了一个新的方式去实现，那就是 <code>MessageChannel</code> 。</p> <p>MessageChannel 接口允许开发者创建一个新的消息通道，并通过它的两个 MessagePort 属性发送数据。</p> <ul><li>MessageChannel.port1 只读返回 channel 的 port1 。</li> <li>MessageChannel.port2 只读返回 channel 的 port2 。 下面来模拟一下 MessageChannel 如何触发异步宏任务的。</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code>  <span class="token keyword">let</span> scheduledHostCallback <span class="token operator">=</span> <span class="token keyword">null</span> 
  <span class="token comment">/* 建立一个消息通道 */</span>
  <span class="token keyword">var</span> channel <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MessageChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* 建立一个port发送消息 */</span>
  <span class="token keyword">var</span> port <span class="token operator">=</span> channel<span class="token punctuation">.</span>port2<span class="token punctuation">;</span>

  channel<span class="token punctuation">.</span>port1<span class="token punctuation">.</span><span class="token function-variable function">onmessage</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token comment">/* 执行任务 */</span>
      <span class="token function">scheduledHostCallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
      <span class="token comment">/* 执行完毕，清空任务 */</span>
      scheduledHostCallback <span class="token operator">=</span> <span class="token keyword">null</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment">/* 向浏览器请求执行更新任务 */</span>
  <span class="token function-variable function">requestHostCallback</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    scheduledHostCallback <span class="token operator">=</span> callback<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isMessageLoopRunning<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      isMessageLoopRunning <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
      port<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><ul><li>在一次更新中，React 会调用 requestHostCallback ，把更新任务赋值给 scheduledHostCallback ，然后 port2 向 port1 发起 postMessage 消息通知。</li> <li>port1 会通过 onmessage ，接受来自 port2 消息，然后执行更新任务 scheduledHostCallback ，然后置空 scheduledHostCallback ，借此达到异步执行目的。</li></ul> <h2 id="异步调度原理"><a href="#异步调度原理" class="header-anchor">#</a> 异步调度原理</h2> <p>React 发生一次更新，会统一走 ensureRootIsScheduled（调度应用）。</p> <ul><li>对于正常更新会走 performSyncWorkOnRoot 逻辑，最后会走 <code>workLoopSync</code> 。</li> <li>对于低优先级的异步更新会走 performConcurrentWorkOnRoot 逻辑，最后会走 <code>workLoopConcurrent</code> 。</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">workLoopSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>workInProgress <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    workInProgress <span class="token operator">=</span> <span class="token function">performUnitOfWork</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">workLoopConcurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>workInProgress <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">shouldYield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    workInProgress <span class="token operator">=</span> <span class="token function">performUnitOfWork</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>在一次更新调度过程中，workLoop 会更新执行每一个待更新的 fiber 。他们的区别就是异步模式会调用一个 shouldYield() ，如果当前浏览器没有空余时间， shouldYield 会中止循环，直到浏览器有空闲时间后再继续遍历，从而达到终止渲染的目的。这样就解决了一次性遍历大量的 fiber ，导致浏览器没有时间执行一些渲染任务，导致了页面卡顿。</p> <h3 id="schedulecallback"><a href="#schedulecallback" class="header-anchor">#</a> scheduleCallback</h3> <p>无论是上述正常更新任务 <code>workLoopSync</code> 还是低优先级的任务 <code>workLoopConcurrent</code> ，都是由调度器 <code>scheduleCallback</code> 统一调度的，那么两者在进入调度器时候有什么区别呢？</p> <p>对于正常更新任务，最后会变成类似如下结构：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token function">scheduleCallback</span><span class="token punctuation">(</span>Immediate<span class="token punctuation">,</span>workLoopSync<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>对于异步任务：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">/* 计算超时等级，就是如上那五个等级 */</span>
<span class="token keyword">var</span> priorityLevel <span class="token operator">=</span> <span class="token function">inferPriorityFromExpirationTime</span><span class="token punctuation">(</span>currentTime<span class="token punctuation">,</span> expirationTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">scheduleCallback</span><span class="token punctuation">(</span>priorityLevel<span class="token punctuation">,</span>workLoopConcurrent<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>低优先级异步任务的处理，比同步多了一个超时等级的概念。会计算上述那五种超时等级。</p> <p><strong>scheduleCallback 到底做了些什么呢？</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">scheduleCallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token comment">/* 计算过期时间：超时时间  = 开始时间（现在时间） + 任务超时的时间（上述设置那五个等级）     */</span>
   <span class="token keyword">const</span> expirationTime <span class="token operator">=</span> startTime <span class="token operator">+</span> timeout<span class="token punctuation">;</span>
   <span class="token comment">/* 创建一个新任务 */</span>
   <span class="token keyword">const</span> newTask <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>startTime <span class="token operator">&gt;</span> currentTime<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">/* 通过开始时间排序 */</span>
      newTask<span class="token punctuation">.</span>sortIndex <span class="token operator">=</span> startTime<span class="token punctuation">;</span>
      <span class="token comment">/* 把任务放在timerQueue中 */</span>
      <span class="token function">push</span><span class="token punctuation">(</span>timerQueue<span class="token punctuation">,</span> newTask<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">/*  执行setTimeout ， */</span>
      <span class="token function">requestHostTimeout</span><span class="token punctuation">(</span>handleTimeout<span class="token punctuation">,</span> startTime <span class="token operator">-</span> currentTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
    <span class="token comment">/* 通过 expirationTime 排序  */</span>
    newTask<span class="token punctuation">.</span>sortIndex <span class="token operator">=</span> expirationTime<span class="token punctuation">;</span>  
    <span class="token comment">/* 把任务放入taskQueue */</span>
    <span class="token function">push</span><span class="token punctuation">(</span>taskQueue<span class="token punctuation">,</span> newTask<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/*没有处于调度中的任务， 然后向浏览器请求一帧，浏览器空闲执行 flushWork */</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isHostCallbackScheduled <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>isPerformingWork<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        isHostCallbackScheduled <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
         <span class="token function">requestHostCallback</span><span class="token punctuation">(</span>flushWork<span class="token punctuation">)</span>
     <span class="token punctuation">}</span>
    
  <span class="token punctuation">}</span>
  
<span class="token punctuation">}</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>对于调度本身，有几个概念必须掌握。</p> <ul><li><code>taskQueue</code>，里面存的都是过期的任务，依据任务的过期时间( <code>expirationTime</code> ) 排序，需要在调度的 <code>workLoop</code> 中循环执行完这些任务。</li> <li><code>timerQueue</code> 里面存的都是没有过期的任务，依据任务的开始时间( <code>startTime</code> )排序，在调度 workLoop 中 会用<code>advanceTimers</code>检查任务是否过期，如果过期了，放入 <code>taskQueue</code> 队列。</li></ul> <p>scheduleCallback 流程如下。</p> <ul><li>创建一个新的任务 newTask。</li> <li>通过任务的开始时间( startTime ) 和 当前时间( currentTime ) 比较:当 startTime &gt; currentTime, 说明未过期, 存到 timerQueue，当 startTime &lt;= currentTime, 说明已过期, 存到 taskQueue。</li> <li>如果任务过期，并且没有调度中的任务，那么调度 requestHostCallback。本质上调度的是 flushWork。</li> <li>如果任务没有过期，用 requestHostTimeout 延时执行 handleTimeout。</li></ul> <h3 id="requesthosttimeout"><a href="#requesthosttimeout" class="header-anchor">#</a> requestHostTimeout</h3> <p>上述当一个任务，没有超时，那么 React 把它放入 timerQueue中了，但是它什么时候执行呢 ？这个时候 Schedule 用 requestHostTimeout 让一个未过期的任务能够到达恰好过期的状态， 那么需要延迟 startTime - currentTime 毫秒就可以了。requestHostTimeout 就是通过 setTimeout 来进行延时指定时间的。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token function-variable function">requestHostTimeout</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">cb<span class="token punctuation">,</span> ms</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
_timeoutID <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>cb<span class="token punctuation">,</span> ms<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function-variable function">cancelHostTimeout</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token function">clearTimeout</span><span class="token punctuation">(</span>_timeoutID<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ul><li>requestHostTimeout 延时执行 handleTimeout，cancelHostTimeout 用于清除当前的延时器。</li></ul> <h3 id="handletimeout"><a href="#handletimeout" class="header-anchor">#</a> handleTimeout</h3> <p>延时指定时间后，调用的 handleTimeout 函数， handleTimeout 会把任务重新放在 requestHostCallback 调度。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">handleTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  isHostTimeoutScheduled <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token comment">/* 将 timeQueue 中过期的任务，放在 taskQueue 中 。 */</span>
  <span class="token function">advanceTimers</span><span class="token punctuation">(</span>currentTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* 如果没有处于调度中 */</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>isHostCallbackScheduled<span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token comment">/* 判断有没有过期的任务， */</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">peek</span><span class="token punctuation">(</span>taskQueue<span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   
      isHostCallbackScheduled <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
      <span class="token comment">/* 开启调度任务 */</span>
      <span class="token function">requestHostCallback</span><span class="token punctuation">(</span>flushWork<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><ul><li>通过 advanceTimers 将 timeQueue 中过期的任务转移到 taskQueue 中。</li> <li>然后调用 requestHostCallback 调度过期的任务。</li></ul> <h3 id="advancetimers"><a href="#advancetimers" class="header-anchor">#</a> advanceTimers</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">advanceTimers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token keyword">var</span> timer <span class="token operator">=</span> <span class="token function">peek</span><span class="token punctuation">(</span>timerQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">while</span> <span class="token punctuation">(</span>timer <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>timer<span class="token punctuation">.</span>callback <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">pop</span><span class="token punctuation">(</span>timerQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>timer<span class="token punctuation">.</span>startTime <span class="token operator">&lt;=</span> currentTime<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">/* 如果任务已经过期，那么将 timerQueue 中的过期任务，放入taskQueue */</span>
         <span class="token function">pop</span><span class="token punctuation">(</span>timerQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>
         timer<span class="token punctuation">.</span>sortIndex <span class="token operator">=</span> timer<span class="token punctuation">.</span>expirationTime<span class="token punctuation">;</span>
         <span class="token function">push</span><span class="token punctuation">(</span>taskQueue<span class="token punctuation">,</span> timer<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><ul><li>如果任务已经过期，那么将 timerQueue 中的过期任务，放入 taskQueue。</li></ul> <h3 id="flushwork和workloop"><a href="#flushwork和workloop" class="header-anchor">#</a> flushWork和workloop</h3> <p>综上所述要明白两件事：</p> <ul><li>第一件是 React 的更新任务最后都是放在 taskQueue 中的。</li> <li>第二件是 requestHostCallback ，放入 MessageChannel 中的回调函数是flushWork。</li></ul> <p><strong>flushWork</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">flushWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>isHostTimeoutScheduled<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* 如果有延时任务，那么先暂定延时任务*/</span>
    isHostTimeoutScheduled <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token function">cancelHostTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">try</span><span class="token punctuation">{</span>
     <span class="token comment">/* 执行 workLoop 里面会真正调度我们的事件  */</span>
     <span class="token function">workLoop</span><span class="token punctuation">(</span>hasTimeRemaining<span class="token punctuation">,</span> initialTime<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><ul><li>flushWork 如果有延时任务执行的话，那么会先暂停延时任务，然后调用 workLoop ，去真正执行超时的更新任务。</li></ul> <p><strong>workLoop</strong></p> <p>这个 workLoop 是调度中的 workLoop，不要把它和调和中的 workLoop 弄混淆了。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">workLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">var</span> currentTime <span class="token operator">=</span> initialTime<span class="token punctuation">;</span>
  <span class="token function">advanceTimers</span><span class="token punctuation">(</span>currentTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* 获取任务列表中的第一个 */</span>
  currentTask <span class="token operator">=</span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>currentTask <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token comment">/* 真正的更新函数 callback */</span>
      <span class="token keyword">var</span> callback <span class="token operator">=</span> currentTask<span class="token punctuation">.</span>callback<span class="token punctuation">;</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>callback <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>
         <span class="token comment">/* 执行更新 */</span>
         <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token comment">/* 先看一下 timeQueue 中有没有 过期任务。 */</span>
        <span class="token function">advanceTimers</span><span class="token punctuation">(</span>currentTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token comment">/* 再一次获取任务，循环执行 */</span> 
      currentTask <span class="token operator">=</span> <span class="token function">peek</span><span class="token punctuation">(</span>taskQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><ul><li>workLoop 会依次更新过期任务队列中的任务。<strong>到此为止，完成整个调度过程。</strong></li></ul> <h3 id="shouldyield-中止-workloop"><a href="#shouldyield-中止-workloop" class="header-anchor">#</a> shouldYield 中止 workloop</h3> <p>在 fiber 的异步更新任务 workLoopConcurrent 中，每一个 fiber 的 workloop 都会调用 shouldYield 判断是否有超时更新的任务，如果有，那么停止 workLoop。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">unstable_shouldYield</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> currentTime <span class="token operator">=</span> exports<span class="token punctuation">.</span><span class="token function">unstable_now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">advanceTimers</span><span class="token punctuation">(</span>currentTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* 获取第一个任务 */</span>
  <span class="token keyword">var</span> firstTask <span class="token operator">=</span> <span class="token function">peek</span><span class="token punctuation">(</span>taskQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> firstTask <span class="token operator">!==</span> currentTask <span class="token operator">&amp;&amp;</span> currentTask <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> firstTask <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> firstTask<span class="token punctuation">.</span>callback <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> firstTask<span class="token punctuation">.</span>startTime <span class="token operator">&lt;=</span> currentTime <span class="token operator">&amp;&amp;</span> firstTask<span class="token punctuation">.</span>expirationTime <span class="token operator">&lt;</span> currentTask<span class="token punctuation">.</span>expirationTime <span class="token operator">||</span> <span class="token function">shouldYieldToHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ul><li>如果存在第一个任务，并且已经超时了，那么 shouldYield 会返回 true，那么会中止 fiber 的 workloop。</li></ul> <h2 id="调度整体流程"><a href="#调度整体流程" class="header-anchor">#</a> 调度整体流程</h2> <p><img src="/blog/images/react/scheduler1.png" alt="scheduler1"></p> <p><code>优先级</code>意味着任务的过期时间。设想一个大型<code>React</code>项目，在某一刻，存在很多不同<code>优先级</code>的<code>任务</code>，对应不同的过期时间。</p> <p>同时，又因为任务可以被延迟，所以我们可以将这些任务按是否被延迟分为：</p> <ul><li>已就绪任务</li> <li>未就绪任务</li></ul> <p><code>Scheduler</code>存在两个队列：</p> <ul><li>timerQueue：保存未就绪任务</li> <li>taskQueue：保存已就绪任务</li></ul> <p>每当有新的未就绪的任务被注册，我们将其插入<code>timerQueue</code>并根据开始时间重新排列<code>timerQueue</code>中任务的顺序。</p> <p>当<code>timerQueue</code>中有任务就绪，即<code>startTime &lt;= currentTime</code>，我们将其取出并加入<code>taskQueue</code>。</p> <p>取出<code>taskQueue</code>中最早过期的任务并执行他。</p> <p>为了能在O(1)复杂度找到两个队列中时间最早的那个任务，<code>Scheduler</code>使用小顶堆实现了<code>优先级队列</code>。</p> <h2 id="异步调度流程"><a href="#异步调度流程" class="header-anchor">#</a> 异步调度流程</h2> <p><img src="/blog/images/react/scheduler2.png" alt="scheduler2"></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/react/react/react-priority.html" class="prev">
        React 优先级管理
      </a></span> <span class="next"><a href="/blog/react/react/react-render.html">
        Render 阶段
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----><!----><!----></div></div>
    <script src="/blog/assets/js/app.5c0d645f.js" defer></script><script src="/blog/assets/js/2.dec2e75d.js" defer></script><script src="/blog/assets/js/1.5b9e135c.js" defer></script><script src="/blog/assets/js/161.9c8db632.js" defer></script><script src="/blog/assets/js/20.badbb211.js" defer></script>
  </body>
</html>
