(window.webpackJsonp=window.webpackJsonp||[]).push([[104],{550:function(t,e,a){"use strict";a.r(e);var s=a(14),r=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#生命周期"}},[t._v("#")]),t._v(" 生命周期")]),t._v(" "),a("p",[t._v("每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。生命周期并非指 Vue 中的生命周期钩子，而是指 Vue 内部从初始化到挂载 DOM 的完整流程。从"),a("code",[t._v("开始创建、初始化数据、编译模版、挂载 Dom -> 渲染、更新 -> 渲染、卸载")]),t._v("等一系列过程，我们称这是 Vue 的生命周期。")]),t._v(" "),a("h2",{attrs:{id:"生命周期过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#生命周期过程"}},[t._v("#")]),t._v(" 生命周期过程")]),t._v(" "),a("p",[a("img",{attrs:{src:"/blog/images/vue/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%BF%87%E7%A8%8B.png",alt:"生命周期过程"}})]),t._v(" "),a("h3",{attrs:{id:"初始化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#初始化"}},[t._v("#")]),t._v(" 初始化")]),t._v(" "),a("p",[t._v("new Vue() --- init ---\x3e $mount")]),t._v(" "),a("p",[t._v("在 new Vue() 之后。Vue 会调用挂载在其原型上的 _init 函数进行初始化，也就是这里的 init 过程，它会初始化生命周期、事件、props、methods、data、computed 与 watch 等。其中最重要的是通过 Object.defineProperty 设置 setter 与 getter 函数，用来实现响应式以及依赖收集。")]),t._v(" "),a("p",[t._v("初始化后会调用 $mount 进行挂载组件，如果是运行时编译（Runtime with Compiler），即不存在 render function 但是存在 template 的情况，则需要进行模板编译步骤。")]),t._v(" "),a("h3",{attrs:{id:"模板编译"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模板编译"}},[t._v("#")]),t._v(" 模板编译")]),t._v(" "),a("p",[t._v("template --- compiler(parse,optimize,generate) ---\x3e render 函数(VNode)")]),t._v(" "),a("p",[t._v("模板编译通过 Compiler 完成，compiler 可以分成 parse、optimize 与 generate 三个阶段，最终得到 render function。")]),t._v(" "),a("h4",{attrs:{id:"parse-解析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parse-解析"}},[t._v("#")]),t._v(" Parse 解析")]),t._v(" "),a("p",[t._v("Parse 会用正则等方式解析 template 模版中的指令、class、style 等数据，形成 AST。")]),t._v(" "),a("h4",{attrs:{id:"optimize-优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#optimize-优化"}},[t._v("#")]),t._v(" Optimize 优化")]),t._v(" "),a("p",[t._v("Optimize 的主要作用是标记 static 静态节点，这时 Vue 在编译过程中的优化，后面当 update 更新界面时，会有一个 patch 的过程，diff 算法会直接跳过静态节点，从而减少了比较的过程，优化了 patch 的性能。")]),t._v(" "),a("h4",{attrs:{id:"generate-生成"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#generate-生成"}},[t._v("#")]),t._v(" Generate 生成")]),t._v(" "),a("p",[t._v("Generate 是将 AST 转化成 render function 字符串的过程，得到结果是 render 的字符串以及 staticRenderFns 字符串。")]),t._v(" "),a("p",[t._v("在经历过 Parse、Optimize 与 Generate 这三个阶段之后，组件中就会得到用于渲染 VNode 所需的 render 函数了。")]),t._v(" "),a("h3",{attrs:{id:"响应式系统"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#响应式系统"}},[t._v("#")]),t._v(" 响应式系统")]),t._v(" "),a("p",[t._v("在 init 过程中通过 "),a("code",[t._v("Object.defineProperty")]),t._v(" 对响应式数据的 getter 和 setter 进行绑定，它使得当被设置的对象被读取的时候会执行 getter 函数，而在当被赋值的时候会执行 setter 函数。")]),t._v(" "),a("p",[t._v("当 render 函数被渲染的时候，因为会读取所需对象的值，所以会触发 getter 函数进行依赖收集，依赖收集的目的是将观察者 Watcher 对象存放到当前闭包中的订阅者 Dep 的 subs 中。")]),t._v(" "),a("p",[t._v("在修改对象的值时候，会触发 setter，setter 通知之前依赖收集得到的 Dep 中的每个 Watcher，告诉它们自己的值改变了，需要重新渲染视图。这时候这些 Watcher 就会开始调用 update 来更新视图，当然这中间还有一个 patch 过程以及使用队列来异步更新的策略。")]),t._v(" "),a("h3",{attrs:{id:"更新视图"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#更新视图"}},[t._v("#")]),t._v(" 更新视图")]),t._v(" "),a("p",[t._v("render ---\x3e VNode ---\x3e createElm/removeElm/patch(diff) ----\x3e UI")]),t._v(" "),a("p",[t._v("在修改对象值时，会通过 setter => Watcher => update 的流程来修改对应的视图，那么最终是如何更新视图呢？")]),t._v(" "),a("p",[t._v("当数据变化后，执行 render function 就可以得到一个新的 VNode 节点，我们如果想要得到新的视图，最简单粗暴的方法就是直接解析这个新的 VNode，然后用 innerHTML 直接全部渲染到真实 DOM 中。但是其实我们只对其中的一小块内容进行了修改，这样做似乎会消耗大量成本。通过新的 VNode 与旧的 VNode 传入 patch 进行比较，经过 diff 算法得出它们的差异。最后我们只需要将这些差异的对应 DOM 进行修改即可。")]),t._v(" "),a("h3",{attrs:{id:"生命周期过程总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#生命周期过程总结"}},[t._v("#")]),t._v(" 生命周期过程总结")]),t._v(" "),a("ul",[a("li",[t._v("首先，在实例化的过程中，把普通的 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defaineProperty 把这些属性全部转为 getter 和 setter。")]),t._v(" "),a("li",[t._v("Dep 是依赖收集器。data 下的每个属性都有一个唯一的 Dep 对象，在 get 中收集仅针对该属性的依赖，然后在 set 方法中触发所有收集的依赖。")]),t._v(" "),a("li",[t._v("在 Watcher 中对表达式求值，从而触发数据的 get。在求值之前将当前 Watch 实例设置到全局，使用 pushTarget(this) 方法。")]),t._v(" "),a("li",[t._v("在 get 中收集依赖，this.subs.push(sub) 和 set 的时候触发回调 Dep.notify。")]),t._v(" "),a("li",[t._v("Compile 中首先将 template 或 el 编译成 render 函数，render 函数返回一个虚拟 DOM 对象（将模版转为 render 函数的时候，实际是先生成的抽象语法树 AST，再将抽象语法树转成的 render 函数）")]),t._v(" "),a("li",[t._v("当 vm._render 执行的时候，所依赖的变量就会被求值，并被收集为依赖。按照 Vue 中 watch.js 的逻辑，当依赖的变量有变化时不仅仅回调函数被执行，实际上还要重新求值，即还要执行一遍。")]),t._v(" "),a("li",[t._v("如果还没有 preVnode 说明是首次渲染，直接创建真实 DOM。如果已经有了 prevVnode 说明不是首次渲染，那么就采用 patch 算法进行必要的 DOM 操作。这就是 Vue 更新 DOM 的逻辑。")])]),t._v(" "),a("h2",{attrs:{id:"生命周期钩子"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#生命周期钩子"}},[t._v("#")]),t._v(" 生命周期钩子")]),t._v(" "),a("p",[a("img",{attrs:{src:"/blog/images/vue/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90.png",alt:"生命周期钩子"}})]),t._v(" "),a("p",[t._v("Vue实例的生命周期大致可分为4个阶段：")]),t._v(" "),a("ul",[a("li",[t._v("初始化阶段：为 Vue 实例上初始化一些属性，事件以及响应式数据；")]),t._v(" "),a("li",[t._v("模板编译阶段：将模板编译成渲染函数；")]),t._v(" "),a("li",[t._v("挂载阶段：将实例挂载到指定的 DOM 上，即将模板渲染到真实 DOM 中；")]),t._v(" "),a("li",[t._v("销毁阶段：将实例自身从父组件中删除，并取消依赖追踪及事件监听器；")])]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"left"}},[t._v("生命周期")]),t._v(" "),a("th",{staticStyle:{"text-align":"left"}},[t._v("描述")]),t._v(" "),a("th",{staticStyle:{"text-align":"left"}},[t._v("最佳实践")])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("beforeCreate")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("组件实例被创建之初，组件的属性生效之前。在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("常用于初始化非响应式变量")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("created")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("组件实例已经完全创建，实例已完成以下的配置：数据观测 (data observer)，属性绑定和方法的运算，watch/event 事件回调，但真实 dom 还没有生成，$el 还不可用")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("常用于简单的 AJAX 请求，页面的初始化")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("beforeMount")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("在挂载开始之前被调用，相关的 render 函数首次被调用")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}})]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("mounted")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("el 被新创建的 "),a("code",[t._v("vm.$el")]),t._v(" 替换，并挂载到实例上去之后调用该钩子。注意 mounted 不会保证所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以在 mounted 内部使用 "),a("code",[t._v("vm.$nextTick")]),t._v(", 该钩子在服务器端渲染期间不被调用。")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("常用于获取 VNode 信息和操作，AJAX 请求")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("beforeUpdate")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务端进行。")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("update")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("组件数据更新之后。由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用计算属性或 watcher 取而代之。注意 updated 不会保证所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以在 updated 里使用 "),a("code",[t._v("vm.$nextTick")]),t._v("。该钩子在服务器端渲染期间不被调用。")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("当 updated 钩子调用时，组件 DOM 的 data 已经更新，所以你现在可以执行依赖于 DOM 的操作。但是不要在此时修改 data，否则会再次触发 beforeUpdate、updated 这个两个钩子，导致进入死循环。")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("activited")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("keep-alive 专属，组件被激活时调用。该钩子在服务器端渲染期间不被调用。")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}})]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("deactivated")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("keep-alive 专属，组件被销毁时调用。该钩子在服务器端渲染期间不被调用。")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}})]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("beforeDestory")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("实例销毁之前调用。在这一步，"),a("strong",[t._v("实例仍然完全可用")]),t._v("。该钩子在服务器端渲染期间不被调用。")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("常用于销毁定时器、解绑全局事件、销毁插件对象等操作")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("destoryed")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("实例销毁后调用。该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。该钩子在服务器端渲染期间不被调用。")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}})])])]),t._v(" "),a("h3",{attrs:{id:"errorcaptured"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#errorcaptured"}},[t._v("#")]),t._v(" errorCaptured")]),t._v(" "),a("p",[t._v("errorCaptured (err: Error, vm: Component, info: string) => ?boolean")]),t._v(" "),a("p",[t._v("当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。你可以在此钩子中修改组件的状态。因此在捕获错误时，在模板或渲染函数中有一个条件判断来绕过其它内容就很重要；不然该组件可能会进入一个无限的渲染循环。")]),t._v(" "),a("p",[t._v("错误传播规则:")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("默认情况下，如果全局的 config.errorHandler 被定义，所有的错误仍会发送它，因此这些错误仍然会向单一的分析服务的地方进行汇报。")])]),t._v(" "),a("li",[a("p",[t._v("如果一个组件的继承或父级从属链路中存在多个 errorCaptured 钩子，则它们将会被相同的错误逐个唤起。")])]),t._v(" "),a("li",[a("p",[t._v("如果此 errorCaptured 钩子自身抛出了一个错误，则这个新错误和原本被捕获的错误都会发送给全局的 config.errorHandler。")])]),t._v(" "),a("li",[a("p",[t._v("一个 errorCaptured 钩子能够返回 false 以阻止错误继续向上传播。本质上是说“这个错误已经被搞定了且应该被忽略”。它会阻止其它任何会被这个错误唤起的 errorCaptured 钩子和全局的 config.errorHandler。")])])]),t._v(" "),a("h2",{attrs:{id:"问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#问题"}},[t._v("#")]),t._v(" 问题")]),t._v(" "),a("h3",{attrs:{id:"q1-为什么生命周期函数不能使用箭头函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#q1-为什么生命周期函数不能使用箭头函数"}},[t._v("#")]),t._v(" Q1. 为什么生命周期函数不能使用箭头函数")]),t._v(" "),a("p",[t._v("所有的生命周期钩子自动绑定 this 上下文到实例中，因此你可以访问数据，对 property 和方法进行运算。这意味着你不能使用箭头函数来定义一个生命周期方法 (例如 created: () => this.fetchTodos())。这是"),a("strong",[t._v("因为箭头函数绑定了父上下文，因此 this 与你期待的 Vue 实例不同")]),t._v("，this.fetchTodos 的行为未定义。")]),t._v(" "),a("h3",{attrs:{id:"q2-vue-的父组件和子组件生命周期钩子函数执行顺序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#q2-vue-的父组件和子组件生命周期钩子函数执行顺序"}},[t._v("#")]),t._v(" Q2. Vue 的父组件和子组件生命周期钩子函数执行顺序？")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("加载渲染过程")]),t._v(" "),a("p",[t._v("父 beforeCreate -> 父 created -> 父 beforeMount -> 子 beforeCreate -> 子 created -> 子 beforeMount -> 子 mounted -> 父 mounted")])]),t._v(" "),a("li",[a("p",[t._v("子组件更新过程")]),t._v(" "),a("p",[t._v("父 beforeUpdate -> 子 beforeUpdate -> 子 updated -> 父 updated")])]),t._v(" "),a("li",[a("p",[t._v("父组件更新过程")]),t._v(" "),a("p",[t._v("父 beforeUpdate -> 父 updated")])]),t._v(" "),a("li",[a("p",[t._v("销毁过程")]),t._v(" "),a("p",[t._v("父 beforeDestroy -> 子 beforeDestroy -> 子 destroyed -> 父 destroyed")])])]),t._v(" "),a("h3",{attrs:{id:"q3-在哪个生命周期内调用异步请求"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#q3-在哪个生命周期内调用异步请求"}},[t._v("#")]),t._v(" Q3. 在哪个生命周期内调用异步请求？")]),t._v(" "),a("p",[t._v("如果组件在加载的时候需要和后端有交互，放在 beforeCreate、created、beforeMount、mounted 都可以，如果是需要访问 props、data 等数据的话，可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，props、data 已经创建，可以将服务端端返回的数据进行赋值。但是本人推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：")]),t._v(" "),a("ul",[a("li",[t._v("能更快获取到服务端数据，减少页面 loading 时间")]),t._v(" "),a("li",[t._v("ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性")])]),t._v(" "),a("p",[t._v("created 阶段的网络请求与 mounted 请求的区别：前者页面视图未出现，如果请求信息过多，页面会长时间处于白屏状态。")]),t._v(" "),a("h3",{attrs:{id:"q4-在什么阶段才能访问操作dom"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#q4-在什么阶段才能访问操作dom"}},[t._v("#")]),t._v(" Q4. 在什么阶段才能访问操作DOM？")]),t._v(" "),a("p",[t._v("在钩子函数 mounted 被调用前，Vue 已经将编译好的模板挂载到页面上，所以在 mounted 中可以访问操作 DOM。vue 具体的生命周期示意图可以参见如下:")]),t._v(" "),a("p",[a("img",{attrs:{src:"/blog/images/vue/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B3%A8%E9%87%8A.png",alt:"vue生命周期注释"}})]),t._v(" "),a("h3",{attrs:{id:"q5-父组件可以监听到子组件的生命周期吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#q5-父组件可以监听到子组件的生命周期吗"}},[t._v("#")]),t._v(" Q5. 父组件可以监听到子组件的生命周期吗？")]),t._v(" "),a("p",[t._v("比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理，可以通过以下写法实现：")]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Parent.vue")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Child @mounted"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"doSomething"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n    \n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Child.vue")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("mounted")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("$emit")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"mounted"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br")])]),a("p",[t._v("以上需要手动通过 $emit 触发父组件的事件，更简单的方式可以在父组件引用子组件时通过 @hook 来监听即可，如下所示：")]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//  Parent.vue")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Child @hook"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("mounted"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"doSomething"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("Child"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("doSomething")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n   console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'父组件监听到 mounted 钩子函数 ...'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    \n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//  Child.vue")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("mounted")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n   console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'子组件触发 mounted 钩子函数 ...'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("    \n    \n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 以上输出顺序为：")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 子组件触发 mounted 钩子函数 ...")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 父组件监听到 mounted 钩子函数 ...     ")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br"),a("span",{staticClass:"line-number"},[t._v("11")]),a("br"),a("span",{staticClass:"line-number"},[t._v("12")]),a("br"),a("span",{staticClass:"line-number"},[t._v("13")]),a("br"),a("span",{staticClass:"line-number"},[t._v("14")]),a("br"),a("span",{staticClass:"line-number"},[t._v("15")]),a("br")])]),a("p",[t._v("当然 @hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。")]),t._v(" "),a("h3",{attrs:{id:"q6-v-model-的原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#q6-v-model-的原理"}},[t._v("#")]),t._v(" Q6. v-model 的原理")]),t._v(" "),a("p",[t._v("我们在 vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：")]),t._v(" "),a("ul",[a("li",[t._v("text 和 textarea 元素使用 value 属性和 input 事件；")]),t._v(" "),a("li",[t._v("checkbox 和 radio 使用 checked 属性和 change 事件；")]),t._v(" "),a("li",[t._v("select 字段将 value 作为 prop 并将 change 作为事件。")])]),t._v(" "),a("p",[t._v("以 input  表单元素为例：")]),t._v(" "),a("div",{staticClass:"language-html line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-html"}},[a("code",[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("input")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("v-model")]),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")]),t._v("something"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n    \n相当于\n\n"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("input")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[a("span",{pre:!0,attrs:{class:"token namespace"}},[t._v("v-bind:")]),t._v("value")]),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("something"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[a("span",{pre:!0,attrs:{class:"token namespace"}},[t._v("v-on:")]),t._v("input")]),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("something = $event.target.value"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br")])]),a("div",{staticClass:"custom-block warning"},[a("p",{staticClass:"custom-block-title"},[t._v("参考文献")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://tsejx.github.io/vue-guidebook/reactivity/lifecycle.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Vue Guidebook"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=r.exports}}]);