(window.webpackJsonp=window.webpackJsonp||[]).push([[98],{545:function(v,e,t){"use strict";t.r(e);var _=t(14),a=Object(_.a)({},(function(){var v=this,e=v.$createElement,t=v._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"模板编译与渲染"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#模板编译与渲染"}},[v._v("#")]),v._v(" 模板编译与渲染")]),v._v(" "),t("h2",{attrs:{id:"模板转换成视图的过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#模板转换成视图的过程"}},[v._v("#")]),v._v(" 模板转换成视图的过程")]),v._v(" "),t("ul",[t("li",[v._v("Vue.js 通过编译将 template 模板转换成渲染函数 render，执行渲染函数就可以得到一个虚拟节点树。")]),v._v(" "),t("li",[v._v("在对 Model 进行操作的时候，会触发对应 Dep 中的 Watcher 对象。Watcher 对象会调用对应的 update 来修改视图。这个过程主要是将新旧虚拟节点进行差异对比，然后根据对比结果进行 DOM 操作来更新视图。")])]),v._v(" "),t("p",[v._v("简单点讲，在 Vue 的底层实现上，Vue 将模板编译成虚拟 DOM 渲染函数。结合 Vue 自带的响应系统，在状态改变时，Vue 能够智能地计算出重新渲染组件的最小代价并应到 DOM 操作上。")]),v._v(" "),t("p",[t("img",{attrs:{src:"/blog/images/vue/%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%E4%B8%8E%E6%B8%B2%E6%9F%931.png",alt:"模板编译与渲染1"}})]),v._v(" "),t("ul",[t("li",[v._v("渲染函数：渲染函数是用来生成Virtual DOM的。Vue推荐使用模板来构建我们的应用界面，在底层实现中Vue会将模板编译成渲染函数，当然我们也可以不写模板，直接写渲染函数，以获得更好的控制。")]),v._v(" "),t("li",[v._v("VNode 虚拟节点：它可以代表一个真实的 dom 节点。通过 createElement 方法能将 VNode 渲染成 dom 节点。简单地说，vnode可以理解成节点描述对象，它描述了应该怎样去创建真实的DOM节点。")]),v._v(" "),t("li",[v._v("patch(也叫做patching算法)：虚拟DOM最核心的部分，它可以将vnode渲染成真实的DOM，这个过程是对比新旧虚拟节点之间有哪些不同，然后根据对比结果找出需要更新的的节点进行更新。这点我们从单词含义就可以看出， patch本身就有补丁、修补的意思，其实际作用是在现有DOM上进行修改来实现更新视图的目的。Vue的Virtual DOM Patching算法是基于Snabbdom的实现，并在些基础上作了很多的调整和改进。")])]),v._v(" "),t("p",[t("img",{attrs:{src:"/blog/images/vue/%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%E4%B8%8E%E6%B8%B2%E6%9F%932.png",alt:"模板编译与渲染2"}})]),v._v(" "),t("p",[v._v("事件机制")]),v._v(" "),t("p",[v._v("模板编译")]),v._v(" "),t("p",[v._v("异步更新")]),v._v(" "),t("p",[v._v("从template到DOM")]),v._v(" "),t("p",[v._v("全局API")]),v._v(" "),t("p",[v._v("生命周期")]),v._v(" "),t("p",[v._v("vue2 vs vue3")]),v._v(" "),t("p",[v._v("vue-router原理")]),v._v(" "),t("p",[v._v("vuex状态管理原理")]),v._v(" "),t("p",[v._v("单向数据流原理")]),v._v(" "),t("p",[v._v("computed(计算属性缓存)实现原理")]),v._v(" "),t("p",[v._v("computed 与 watch 区别")]),v._v(" "),t("p",[v._v("父子组件生命周期执行顺序")]),v._v(" "),t("p",[v._v("mixin 混入合并策略")]),v._v(" "),t("p",[v._v("keep-alive 原理")]),v._v(" "),t("p",[v._v("组件中 data 为什么是一个函数")]),v._v(" "),t("p",[v._v("v-model 的原理")])])}),[],!1,null,null,null);e.default=a.exports}}]);