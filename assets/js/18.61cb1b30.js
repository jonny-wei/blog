(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{469:function(v,_,e){"use strict";e.r(_);var l=e(14),i=Object(l.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"css布局与定位"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#css布局与定位"}},[v._v("#")]),v._v(" CSS布局与定位")]),v._v(" "),e("h2",{attrs:{id:"块级元素"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#块级元素"}},[v._v("#")]),v._v(" 块级元素")]),v._v(" "),e("p",[e("strong",[v._v("块级元素的特点")]),v._v("：")]),v._v(" "),e("ul",[e("li",[v._v("默认情况下，块级元素会独占一行")]),v._v(" "),e("li",[v._v("宽度自动填满其父元素宽度 100%")]),v._v(" "),e("li",[v._v("可以设置 "),e("code",[v._v("width, height, line-height")]),v._v(" 属性")]),v._v(" "),e("li",[v._v("可以设置 "),e("code",[v._v("margin")]),v._v(" 和 "),e("code",[v._v("padding")]),v._v(" 属性")]),v._v(" "),e("li",[v._v("可以包含行内元素和其他块级元素")]),v._v(" "),e("li",[v._v("一个 "),e("code",[v._v("block")]),v._v(" 元素通常被叫做块级元素 "),e("code",[v._v("display: block;")])]),v._v(" "),e("li",[v._v("当元素的 display 为 block、list-item 或 table 时，它就是块级元素")])]),v._v(" "),e("p",[e("strong",[v._v("常见的块级元素如下")]),v._v("：")]),v._v(" "),e("ul",[e("li",[v._v("文档分区 "),e("code",[v._v("<div>")])]),v._v(" "),e("li",[v._v("行 "),e("code",[v._v("<p>")])]),v._v(" "),e("li",[v._v("标题标签 "),e("code",[v._v("<h1>")]),v._v(", "),e("code",[v._v("<h2>")]),v._v(", "),e("code",[v._v("<h3>")]),v._v(", "),e("code",[v._v("<h4>")]),v._v(", "),e("code",[v._v("<h5>")]),v._v(", "),e("code",[v._v("<h6>")])]),v._v(" "),e("li",[v._v("表格 "),e("code",[v._v("<table>")])]),v._v(" "),e("li",[v._v("有序列表 "),e("code",[v._v("<ol>")])]),v._v(" "),e("li",[v._v("无序列表 "),e("code",[v._v("<ul>")])]),v._v(" "),e("li",[v._v("定义列表中定义条目描述 "),e("code",[v._v("<dd>")])]),v._v(" "),e("li",[v._v("定义列表 "),e("code",[v._v("<dl>")])]),v._v(" "),e("li",[v._v("表单 "),e("code",[v._v("<form>")])]),v._v(" "),e("li",[v._v("水平分割线 "),e("code",[v._v("<hr>")])]),v._v(" "),e("li",[v._v("区段头或页头 "),e("code",[v._v("<header>")]),v._v(" HTML5")]),v._v(" "),e("li",[v._v("文章内容 "),e("code",[v._v("<article>")]),v._v(" HTML5")]),v._v(" "),e("li",[v._v("伴随内容 "),e("code",[v._v("<aside>")]),v._v(" HTML5")]),v._v(" "),e("li",[v._v("一个页面区段 "),e("code",[v._v("<section>")]),v._v(" HTML5")]),v._v(" "),e("li",[v._v("区段尾或页尾 "),e("code",[v._v("<footer>")]),v._v(" HTML5")]),v._v(" "),e("li",[v._v("音频播放 "),e("code",[v._v("<audio>")]),v._v(" HTML5")]),v._v(" "),e("li",[v._v("视频 "),e("code",[v._v("<video>")]),v._v(" HTML5")]),v._v(" "),e("li",[v._v("绘制图形 "),e("code",[v._v("<canvas>")]),v._v(" HTML5")]),v._v(" "),e("li",[v._v("图文信息组 "),e("code",[v._v("<figure>")]),v._v(" HTML5")])]),v._v(" "),e("p",[v._v("详细块级元素可参考 "),e("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Block-level_elements",target:"_blank",rel:"noopener noreferrer"}},[v._v("https://developer.mozilla.org/zh-CN/docs/Web/HTML/Block-level_elements"),e("OutboundLink")],1)]),v._v(" "),e("h2",{attrs:{id:"行内元素"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#行内元素"}},[v._v("#")]),v._v(" 行内元素")]),v._v(" "),e("p",[e("strong",[v._v("行内元素的特点")]),v._v("：")]),v._v(" "),e("ul",[e("li",[v._v("一般情况下，行内元素只能包含数据和其他行内元素，相邻的行内元素在一行上，但是中间会有空白的间隙，一般用 "),e("code",[v._v("font-size：0")]),v._v(" 解决空白间隙。")]),v._v(" "),e("li",[v._v("行内元素设置 "),e("code",[v._v("width，height")]),v._v(" 属性无效，默认的宽度就是本身内容的宽度")]),v._v(" "),e("li",[v._v("水平方向上的 "),e("code",[v._v("padding")]),v._v(" 和 "),e("code",[v._v("margin")]),v._v(" 可以设置，垂直方向上的无效")]),v._v(" "),e("li",[v._v("行内元素只能容纳纯文本或者是其他的行内元素（"),e("code",[v._v("<a>")]),v._v("除外）")]),v._v(" "),e("li",[v._v("一个 "),e("code",[v._v("inline")]),v._v(" 元素通常被叫做行内元素 "),e("code",[v._v("display: inline;")])]),v._v(" "),e("li",[v._v("当元素的 display 为 inline、inline-block 或 inline-table 时，它就是行内级元素")])]),v._v(" "),e("p",[e("strong",[v._v("常见的行内元素如下")]),v._v("：")]),v._v(" "),e("ul",[e("li",[v._v("锚元素 "),e("code",[v._v("<a>")])]),v._v(" "),e("li",[v._v("缩写元素 "),e("code",[v._v("<abbr>")])]),v._v(" "),e("li",[v._v("粗体元素 "),e("code",[v._v("<b>")])]),v._v(" "),e("li",[v._v("粗体显示 "),e("code",[v._v("<strong>")])]),v._v(" "),e("li",[e("code",[v._v("<span>")])]),v._v(" "),e("li",[v._v("标签，表示用户界面中某个元素的说明 "),e("code",[v._v("<label>")])]),v._v(" "),e("li",[v._v("输入控件 "),e("code",[v._v("<input>")])]),v._v(" "),e("li",[v._v("一个多行纯文本编辑控件 "),e("code",[v._v("<textarea>")])]),v._v(" "),e("li",[v._v("选项菜单控件 "),e("code",[v._v("<select>")])]),v._v(" "),e("li",[v._v("可点击的按钮 "),e("code",[v._v("<button>")])]),v._v(" "),e("li",[v._v("图片 "),e("code",[v._v("<img>")])])]),v._v(" "),e("p",[v._v("详细行内元素可参考 "),e("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Inline_elements",target:"_blank",rel:"noopener noreferrer"}},[v._v("https://developer.mozilla.org/zh-CN/docs/Web/HTML/Inline_elements"),e("OutboundLink")],1)]),v._v(" "),e("div",{staticClass:"custom-block danger"},[e("p",{staticClass:"custom-block-title"},[v._v("注意")]),v._v(" "),e("p",[v._v("在行内元素中有几个特殊的标签，"),e("code",[v._v("<img>")]),v._v(","),e("code",[v._v("<input>")]),v._v(" 可以设置它们的宽高度以及对齐属性。")]),v._v(" "),e("p",[v._v("文字块级标签 "),e("code",[v._v("<h1>~<h6>")]),v._v(","),e("code",[v._v("<p>")]),v._v(","),e("code",[v._v("<dt>")]),v._v("等里面不能放块级元素。")]),v._v(" "),e("p",[v._v("链接里面不能再存放链接")])]),v._v(" "),e("h2",{attrs:{id:"display-属性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#display-属性"}},[v._v("#")]),v._v(" display 属性")]),v._v(" "),e("p",[v._v("display 属性指定了元素的显示类型，它包含两类基础特征，用于指定元素怎样生成盒模型，即，盒子的类型取决于 CSS display 属性：")]),v._v(" "),e("ul",[e("li",[v._v("外部显示类型定义了元素怎样参与流式布局的处理，影响一个元素的外部表现，但不影响子元素的表现。")]),v._v(" "),e("li",[v._v("内部显示类型定义了元素内子元素的布局方式")])]),v._v(" "),e("p",[e("strong",[v._v("外部显示类型")])]),v._v(" "),e("ul",[e("li",[v._v("display: block; 指定对象为块元素。(常用)")]),v._v(" "),e("li",[v._v("display: inline; 指定对象为内联元素。(常用)")]),v._v(" "),e("li",[v._v("display: run-in; 根据上下文决定对象是内联对象还是块级对象。只有 IE 和 Opera 支持。(基本不用)")])]),v._v(" "),e("p",[e("strong",[v._v("内部显示类型")])]),v._v(" "),e("ul",[e("li",[v._v("display: flow; 实验室概念，chrome 不支持。(基本不用)")]),v._v(" "),e("li",[v._v("display: flow-root; 它可以撑起被 "),e("code",[v._v("float")]),v._v(" 掉的块级元素的高度。(基本不用)")]),v._v(" "),e("li",[v._v("display: table; 指定对象作为块元素级的表格。在"),e("code",[v._v("<div>")]),v._v("上使用等价于"),e("code",[v._v("<table>")]),v._v("的实现")]),v._v(" "),e("li",[v._v("display: flex; 将对象作为弹性伸缩盒显示。(常用)")]),v._v(" "),e("li",[v._v("display: grid; 网格布局。(常用)")]),v._v(" "),e("li",[v._v("display: ruby; 旁注标记，类似拼音汉字显示。 (不常用)")])]),v._v(" "),e("p",[e("strong",[v._v("列表值")])]),v._v(" "),e("ul",[e("li",[v._v("display: list-item; 指定对象为列表项目。在"),e("code",[v._v("<div>")]),v._v("上使用等价于"),e("code",[v._v("<ul><li>")]),v._v("的实现。")])]),v._v(" "),e("p",[e("strong",[v._v("属性值")])]),v._v(" "),e("ul",[e("li",[v._v("display: table-row-group; 指定对象作为表格行组。类同于html标签"),e("code",[v._v("<tbody>")]),v._v("（CSS2）")]),v._v(" "),e("li",[v._v("display: table-header-group; 指定对象作为表格标题组。类同于html标签"),e("code",[v._v("<thead>")]),v._v("（CSS2）")]),v._v(" "),e("li",[v._v("display: table-footer-group; 指定对象作为表格脚注组。类同于html标签"),e("code",[v._v("<tfoot>")]),v._v("（CSS2）")]),v._v(" "),e("li",[v._v("display: table-row; 指定对象作为表格行。类同于html标签"),e("code",[v._v("<tr>")]),v._v("（CSS2）")]),v._v(" "),e("li",[v._v("display: table-cell; 指定对象作为表格单元格。类同于html标签"),e("code",[v._v("<td>")]),v._v("（CSS2）")]),v._v(" "),e("li",[v._v("display: table-column-group; 指定对象作为表格列组显示。类同于html标签"),e("code",[v._v("<colgroup>")]),v._v("（CSS2）")]),v._v(" "),e("li",[v._v("display: table-column; 指定对象作为表格列。类同于html标签"),e("code",[v._v("<col>")]),v._v("（CSS2）")]),v._v(" "),e("li",[v._v("display: table-caption; 指定对象作为表格标题。类同于html标签"),e("code",[v._v("<caption>")]),v._v("（CSS2）")]),v._v(" "),e("li",[v._v("display: ruby-base;")]),v._v(" "),e("li",[v._v("display: ruby-text;")]),v._v(" "),e("li",[v._v("display: ruby-base-container;")]),v._v(" "),e("li",[v._v("display: ruby-text-container;")])]),v._v(" "),e("p",[e("strong",[v._v("显示值")])]),v._v(" "),e("ul",[e("li",[v._v("display: contents; 让子元素拥有和父元素一样的布局方式")]),v._v(" "),e("li",[v._v("display: none; 隐藏对象。与 "),e("code",[v._v("visibility")]),v._v(" 属性的 "),e("code",[v._v("hidden")]),v._v(" 值不同，其不为被隐藏的对象保留其物理空间(常用)")])]),v._v(" "),e("p",[e("strong",[v._v("混合值")])]),v._v(" "),e("ul",[e("li",[v._v("display: inline-block; 指定对象为内联块元素。")]),v._v(" "),e("li",[v._v("display: inline-table; 指定对象作为内联元素级的表格。类同于html标签"),e("code",[v._v("<table>")])]),v._v(" "),e("li",[v._v("display: inline-flex; 将对象作为内联块级弹性伸缩盒显示。")]),v._v(" "),e("li",[v._v("display: inline-grid; 在行内进行网格布局。")])]),v._v(" "),e("p",[e("strong",[v._v("全局值")])]),v._v(" "),e("ul",[e("li",[v._v("display: inherit; 继承"),e("code",[v._v("父 display")]),v._v(" 属性")]),v._v(" "),e("li",[v._v("display: initial; 不管父元素如何设定，恢复到浏览器最初的 "),e("code",[v._v("display")]),v._v(" 属性")]),v._v(" "),e("li",[v._v("display: unset; 混合 "),e("code",[v._v("inherit")]),v._v(" 和 "),e("code",[v._v("initial")]),v._v(" 如果父元素设值了就用父元素，如果父元素没设置值，就用浏览器的缺省值。")])]),v._v(" "),e("p",[v._v("每个元素都有一个默认的 display 类型。不过你可以随时随地的重写它！比如你可以把有特定语义的元素改成行内元素，\n常见的例子是：把 li 元素修改成 inline，制作成水平菜单。")]),v._v(" "),e("h2",{attrs:{id:"定位"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#定位"}},[v._v("#")]),v._v(" 定位")]),v._v(" "),e("p",[v._v("定位一般有"),e("strong",[v._v("相对定位(relative)")]),v._v("、"),e("strong",[v._v("绝对定位(absolute)")]),v._v("、"),e("strong",[v._v("固定定位(fixed)")]),v._v("，relative和absolute在移动端用的最多，\nfixed 在移动端有兼容性问题，因此不推荐使用，在移动端替代 fixed 的方案是 absolute+内部滚动。")]),v._v(" "),e("h2",{attrs:{id:"正常布局流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#正常布局流"}},[v._v("#")]),v._v(" 正常布局流")]),v._v(" "),e("p",[v._v("正常布局流是指在不对页面进行任何布局控制时，浏览器默认的 HTML 布局方式。")]),v._v(" "),e("p",[v._v("默认的，一个块级元素的内容宽度是其父元素的"),e("code",[v._v("100%")]),v._v("，其高度与其内容高度一致。\n行内元素的 "),e("code",[v._v("height")]),v._v(" "),e("code",[v._v("width")]),v._v(" 与内容一致。你无法设置行内元素的 "),e("code",[v._v("height")]),v._v(" "),e("code",[v._v("width")]),v._v(",\n它们就那样置于块级元素的内容里。如果你想控制行内元素的尺寸，\n你需要为元素设置 "),e("code",[v._v("display: block;")]),v._v("\n（或者，"),e("code",[v._v("display: inline-block;")]),v._v(" "),e("code",[v._v("inline-block")]),v._v(" 混合了 "),e("code",[v._v("inline")]),v._v(" 和 "),e("code",[v._v("block")]),v._v(" 的特性。)")]),v._v(" "),e("p",[v._v("默认的，块级元素按照在文档中书写出现的顺序放置，即每个块级元素会在上一个元素下面另起一行，\n它们会被设置好的 "),e("code",[v._v("margin")]),v._v(" 分隔。在英语，或者其他水平书写、自上而下模式里，块级元素是垂直组织的。")]),v._v(" "),e("p",[v._v("行内元素的表现有所不同，它们不会另起一行；只要在其父级块级元素的宽度内有足够的空间，\n它们与其他行内元素、相邻的文本内容（或者被包裹的）被安排在同一行。如果空间不够，\n溢出的文本或元素将移到新的一行。")]),v._v(" "),e("p",[v._v("如果两个相邻的元素都设置了 "),e("code",[v._v("margin")]),v._v(" 并且两个 "),e("code",[v._v("margin")]),v._v(" 有重叠，\n那么更大的设置会被保留，小的则会消失，这被称为外边距叠加。")]),v._v(" "),e("p",[v._v("在 CSS 的世界中，会把内容按照从左到右、从上到下的顺序进行排列显示。正常情况下会把页面分割成一行一行的显示，而每行又可能由多列组成，所以从视觉上看起来就是从上到下从左到右，而这就是 CSS 中的流式布局，又叫文档流。文档流就像水一样，能够自适应所在的容器，一般它有如下几个特性：")]),v._v(" "),e("ul",[e("li",[v._v("块级元素默认会占满整行，所以多个块级盒子之间是从上到下排列的；")]),v._v(" "),e("li",[v._v("内联元素默认会在一行里一列一列的排布，当一行放不下的时候，会自动切换到下一行继续按照列排布；")])]),v._v(" "),e("h4",{attrs:{id:"如何脱离文档流呢"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何脱离文档流呢"}},[v._v("#")]),v._v(" 如何脱离文档流呢？")]),v._v(" "),e("p",[v._v("脱流文档流指节点脱流正常文档流后，在正常文档流中的其他节点将忽略该节点并填补其原先空间。文档一旦脱流，计算其父节点高度时不会将其高度纳入，脱流节点不占据空间。有两种方式可以让元素脱离文档流：浮动和定位。")]),v._v(" "),e("ul",[e("li",[v._v("使用浮动（float）会将元素脱离文档流，移动到容器左/右侧边界或者是另一个浮动元素旁边，该浮动元素之前占用的空间将被别的元素填补，另外浮动之后所占用的区域不会和别的元素之间发生重叠；")]),v._v(" "),e("li",[v._v("使用绝对定位（position: absolute;）或者固定定位（position: fixed;）也会使得元素脱离文档流，且空出来的位置将自动被后续节点填补。")])]),v._v(" "),e("h2",{attrs:{id:"浮动"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浮动"}},[v._v("#")]),v._v(" 浮动")]),v._v(" "),e("p",[v._v("浮动被用来将元素盒子向左或向右移动，同时让内容环绕其展示。要让一个元素进行浮动，需要给该元素的 flaot 属性设置为 left 或 right。float 的默认值为 none。\n值得注意的是，当你使某个元素浮动并让文字环绕它时，内容的行框（Line Box）被缩短。如果你让一个元素浮动，\n同时为紧跟着的包含文本的元素设置一个背景颜色，你会发现背景色会出在浮动元素下方。如果想要在浮动元素和环绕的文本之间有一定的间距，\n需要给浮动元素设置 margin。在文本元素上设置 margin 只会让其相对于容器缩进。一旦对一个元素进行了浮动，所有接下来的元素都会环绕它，\n直到内容处理它下方且开始应用正常文档流。如果想要避免这种情形，可以手动清除浮动。\n如果不想要在某个元素受到其之前的浮动元素影响时，可以为其添加 clear 属性。left 值表示清除左边的浮动，right 值表示清除右浮动，\nboth 值表示清除左右两边的浮动。")]),v._v(" "),e("p",[v._v("设置 float 为 left 或 right，就能使该元素脱离文档流，向左或向右浮动。一般在做宫格模式布局时会用到，如果子元素全部设置为浮动，则父元素是塌陷的，\n这时就需要清除浮动，清除浮动的方法也很多，常用的方法是在元素末尾加空元素设置 clear:both, 更高级一点的就给父容器设置 before/after\n来模拟一个空元素，还可以直接设置 overflow:auto/hidden。除过浮动可以实现宫格模式，行内盒子 (inline-block) 和 table 也可以。")]),v._v(" "),e("h2",{attrs:{id:"flex-布局"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#flex-布局"}},[v._v("#")]),v._v(" Flex 布局")]),v._v(" "),e("p",[v._v("Flex 布局是一种一维的布局，一个 flexbox 一次只能处理一个维度上的元素布局，一行或者一列。\n作为对比的是另外一个二维布局 CSS Grid Layout（CSS栅格布局），可以同时处理行和列上的布局。")]),v._v(" "),e("p",[v._v("Flexbox布局是最合适的一个应用程序的组件，以及小规模的布局，而网格布局是用于较大规模的布局。")]),v._v(" "),e("p",[v._v("最重要的是弹性盒子布局与方向无关，相对于常规的布局（块是垂直和内联水平为基础）较灵活。")]),v._v(" "),e("p",[v._v("我们把一个容器的 display 属性值改为 flex 或者 inline-flex。容器中的直系子元素就会变为 flex 元素。")]),v._v(" "),e("ul",[e("li",[v._v("flex 容器（flex container）：采用 flex 布局的元素")]),v._v(" "),e("li",[v._v("flex 元素（flex item）：flex 容器中的所有子元素，即 flex 容器成员")]),v._v(" "),e("li",[v._v("主轴：水平方向，flex 元素 默认沿主轴排列。")]),v._v(" "),e("li",[v._v("交叉轴：垂直于主轴。")])]),v._v(" "),e("div",{staticClass:"custom-block danger"},[e("p",{staticClass:"custom-block-title"},[v._v("注意")]),v._v(" "),e("p",[v._v("设为 Flex 布局以后，子元素的 float 、 clear 和 vertical-align 属性将失效。")])]),v._v(" "),e("h3",{attrs:{id:"flex-container-属性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#flex-container-属性"}},[v._v("#")]),v._v(" Flex Container 属性")]),v._v(" "),e("p",[v._v("容器属性有以下几个：")]),v._v(" "),e("ul",[e("li",[v._v("flex-direction")]),v._v(" "),e("li",[v._v("flex-wrap")]),v._v(" "),e("li",[v._v("flex-flow")]),v._v(" "),e("li",[v._v("justify-content")]),v._v(" "),e("li",[v._v("align-items")]),v._v(" "),e("li",[v._v("align-content")])]),v._v(" "),e("h4",{attrs:{id:"flex-direction"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#flex-direction"}},[v._v("#")]),v._v(" flex-direction")]),v._v(" "),e("p",[v._v("flex-direction属性决定主轴的方向（即项目的排列方向）")]),v._v(" "),e("ul",[e("li",[v._v("row（默认值）：主轴为水平方向，起点在左端")]),v._v(" "),e("li",[v._v("row-reverse：主轴为水平方向，起点在右端")]),v._v(" "),e("li",[v._v("column：主轴为垂直方向，起点在上沿")]),v._v(" "),e("li",[v._v("column-reverse：主轴为垂直方向，起点在下沿")])]),v._v(" "),e("h4",{attrs:{id:"flex-wrap"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#flex-wrap"}},[v._v("#")]),v._v(" flex-wrap")]),v._v(" "),e("p",[v._v("默认子元素都排在一行，一行排不下，可设置此属性换行")]),v._v(" "),e("ul",[e("li",[v._v("nowrap（默认值）：不换行")]),v._v(" "),e("li",[v._v("warp：换行且第一行在上方")]),v._v(" "),e("li",[v._v("warp-reverse：换行但第一行在下方")])]),v._v(" "),e("h4",{attrs:{id:"flex-flow"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#flex-flow"}},[v._v("#")]),v._v(" flex-flow")]),v._v(" "),e("p",[v._v("flex-flow 属性是 flex-direction 属性和 flex-wrap 属性的简写形式，默认：")]),v._v(" "),e("p",[v._v("flex-flow：row nowrap。即取上面两个属性的默认值")]),v._v(" "),e("h4",{attrs:{id:"justify-content"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#justify-content"}},[v._v("#")]),v._v(" justify-content")]),v._v(" "),e("p",[v._v("justify-content 属性定义了子元素在主轴上的对齐方式")]),v._v(" "),e("ul",[e("li",[v._v("flex-start（默认值）：左对齐")]),v._v(" "),e("li",[v._v("flex-end：右对齐")]),v._v(" "),e("li",[v._v("center：居中")]),v._v(" "),e("li",[v._v("space-between：两端对齐，子元素之间的间隔都相等")]),v._v(" "),e("li",[v._v("space-around：每个子元素两侧的间隔相等。所以，子元素与子元素的间隔 比 子元素与边框的间隔 大一倍")]),v._v(" "),e("li",[v._v("space-evenly：弹性容器子项均匀分布，所有项目之间及项目与边框之间的距离相等。")])]),v._v(" "),e("h4",{attrs:{id:"align-items"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#align-items"}},[v._v("#")]),v._v(" align-items")]),v._v(" "),e("p",[v._v("align-items 属性定义子元素在交叉轴上对齐方式")]),v._v(" "),e("ul",[e("li",[v._v("flex-start：交叉轴的起点对齐")]),v._v(" "),e("li",[v._v("flex-end：交叉轴的终点对齐")]),v._v(" "),e("li",[v._v("center：交叉轴的中点对齐")]),v._v(" "),e("li",[v._v("baseline：项目的第一行文字的基线对齐。")]),v._v(" "),e("li",[v._v("stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。")])]),v._v(" "),e("h4",{attrs:{id:"align-content"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#align-content"}},[v._v("#")]),v._v(" align-content")]),v._v(" "),e("p",[v._v("align-content 属性定义了多根轴线的对齐方式。如果子元素只有一根轴线，该属性不起作用")]),v._v(" "),e("ul",[e("li",[v._v("flex-start：与交叉轴的起点对齐。")]),v._v(" "),e("li",[v._v("flex-end：与交叉轴的终点对齐。")]),v._v(" "),e("li",[v._v("center：与交叉轴的中点对齐。")]),v._v(" "),e("li",[v._v("space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。")]),v._v(" "),e("li",[v._v("space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。")]),v._v(" "),e("li",[v._v("stretch（默认值）：轴线占满整个交叉轴。")])]),v._v(" "),e("h3",{attrs:{id:"flex-item-属性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#flex-item-属性"}},[v._v("#")]),v._v(" Flex Item 属性")]),v._v(" "),e("ul",[e("li",[v._v("order")]),v._v(" "),e("li",[v._v("flex-grow")]),v._v(" "),e("li",[v._v("flex-shrink")]),v._v(" "),e("li",[v._v("flex-basis")]),v._v(" "),e("li",[v._v("flex")]),v._v(" "),e("li",[v._v("align-self")])]),v._v(" "),e("h4",{attrs:{id:"order"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#order"}},[v._v("#")]),v._v(" order")]),v._v(" "),e("p",[v._v("order 属性定义子元素的排列顺序。数值越小，排列越靠前，默认为0。")]),v._v(" "),e("h4",{attrs:{id:"flex-grow"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#flex-grow"}},[v._v("#")]),v._v(" flex-grow")]),v._v(" "),e("p",[v._v("flex-grow 属性定义子元素的放大比例，默认值为0，即如果存在剩余空间，也不放大。")]),v._v(" "),e("p",[v._v("如果所有子元素的 flex-grow 属性都为 1，如果存在剩余空间，则它们将等分剩余空间。\n如果一个子元素的 flex-grow 属性为 2，其他子元素为1，则它占据的剩余空间将比其他项多一倍")]),v._v(" "),e("h4",{attrs:{id:"flex-shrink"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#flex-shrink"}},[v._v("#")]),v._v(" flex-shrink")]),v._v(" "),e("p",[v._v("flex-shrink 属性定义了子元素的缩小比例，默认为1，即如果空间不足，子元素将缩小。")]),v._v(" "),e("p",[v._v("如果所有子元素的 flex-shrink 属性都为1，当空间不足时，都将等比例缩小。\n如果一个子元素的 flex-shrink 属性为0，其他项目都为1，则空间不足时，前者不缩小。\n负值对该属性无效。")]),v._v(" "),e("h4",{attrs:{id:"flex-basis"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#flex-basis"}},[v._v("#")]),v._v(" flex-basis")]),v._v(" "),e("p",[v._v("flex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。\n浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为 auto，即子元素的本来大小。\n如果设置成像 width 或 height 属性一样的值，则子元素将占据固定空间。")]),v._v(" "),e("h4",{attrs:{id:"flex"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#flex"}},[v._v("#")]),v._v(" flex")]),v._v(" "),e("p",[v._v("flex 属性是 flex-grow，flex-shrink 和 flex-basis 的缩写")]),v._v(" "),e("p",[v._v("flex: 0 1 auto 默认值取上面三个属性的默认值")]),v._v(" "),e("div",{staticClass:"custom-block danger"},[e("p",{staticClass:"custom-block-title"},[v._v("注意")]),v._v(" "),e("p",[v._v("该属性有以下快捷设置:")]),v._v(" "),e("ul",[e("li",[v._v("flex: 0 1 auto (默认值)")]),v._v(" "),e("li",[v._v("flex: auto (1 1 auto)")]),v._v(" "),e("li",[v._v("flex: none (0 0 auto)")]),v._v(" "),e("li",[v._v("flex: 1 (1 1 0%)[取非负数字]")]),v._v(" "),e("li",[v._v("flex: 0% (1 1 0%)[取百分比]")]),v._v(" "),e("li",[v._v("flex: 24px (1 1 24px)[取长度]")])]),v._v(" "),e("p",[v._v("建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值")])]),v._v(" "),e("h4",{attrs:{id:"align-self"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#align-self"}},[v._v("#")]),v._v(" align-self")]),v._v(" "),e("p",[v._v("align-self 属性允许单个子元素有与其他子元素不一样的对齐方式，可覆盖 align-items 属性。\n默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，等同于 stretch。")]),v._v(" "),e("p",[v._v("该属性可能取6个值，除了auto，其他都与align-items属性完全一致:")]),v._v(" "),e("p",[v._v("align-self: auto | flex-start | flex-end | center | baseline | stretch;")]),v._v(" "),e("h2",{attrs:{id:"grid-网格布局"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#grid-网格布局"}},[v._v("#")]),v._v(" Grid 网格布局")]),v._v(" "),e("p",[v._v("Grid 布局与 Flex 布局有一定的相似性，都可以指定容器内部多个项目的位置。但是，它们也存在重大区别。")]),v._v(" "),e("p",[v._v('Flex 布局是轴线布局，只能指定"项目"针对轴线的位置，可以看作是一维布局。\nGrid 布局则是将容器划分成"行"和"列"，产生单元格，然后指定"项目所在"的单元格，可以看作是二维布局。Grid 布局远比 Flex 布局强大。')]),v._v(" "),e("p",[v._v("网格通常具有列（column），行（row），以及在每行和列之间的间隙——通常称为沟槽（gutter）。display: grid 指定一个容器采用网格布局。\ndisplay: inline-grid; 指定行内元素使用网格布局。")]),v._v(" "),e("div",{staticClass:"custom-block danger"},[e("p",{staticClass:"custom-block-title"},[v._v("注意")]),v._v(" "),e("p",[v._v("设为网格布局以后，容器子元素（项目）的 float、display: inline-block、display: table-cell、vertical-align 和 column-* 等设置都将失效。")])]),v._v(" "),e("ul",[e("li",[e("code",[v._v("grid-template-columns")]),v._v(" 属性： 定义每一列的列宽")]),v._v(" "),e("li",[e("code",[v._v("grid-template-rows")]),v._v(" 属性： 定义每一行的行高\n"),e("ul",[e("li",[e("code",[v._v("repeat()")]),v._v(" 函数： 有时候，重复写同样的值非常麻烦，尤其网格很多时。这时，可以使用，简化重复的值。"),e("code",[v._v("repeat()")]),v._v(" 接受两个参数，第一个参数是重复的次数；\n第二个参数是所要重复的值。")]),v._v(" "),e("li",[e("code",[v._v("auto-fill")]),v._v(" 关键字： 表示自动填充。有时，单元格的大小是固定的，但是容器的大小不确定。如果希望每一行（或每一列）容纳尽可能多的单元格，这时可以使用。")]),v._v(" "),e("li",[e("code",[v._v("fr关键字")]),v._v('（fraction 的缩写，意为"片段"）： 表示比例关系。')]),v._v(" "),e("li",[e("code",[v._v("minmax()")]),v._v(" 函数： 产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值。")]),v._v(" "),e("li",[e("code",[v._v("auto 关键字")]),v._v("： 表示由浏览器自己决定长度。")]),v._v(" "),e("li",[e("code",[v._v("网格线的名称")]),v._v("： "),e("code",[v._v("grid-template-columns")]),v._v(" 属性和 "),e("code",[v._v("grid-template-rows")]),v._v(" 属性里面，还可以使用方括号，指定每一根网格线的名字，方便以后的引用。")])])]),v._v(" "),e("li",[e("code",[v._v("grid-row-gap")]),v._v(" 属性： 设置行与行的间隔（行间距）")]),v._v(" "),e("li",[e("code",[v._v("grid-column-gap")]),v._v(" 属性：设置列与列的间隔（列间距）")]),v._v(" "),e("li",[e("code",[v._v("grid-gap")]),v._v(" 属性： "),e("code",[v._v("grid-column-gap")]),v._v(" 和 "),e("code",[v._v("grid-row-gap")]),v._v(" 的合并简写形式；"),e("code",[v._v("grid-gap: <grid-row-gap> <grid-column-gap>;")]),v._v("。\n如果 "),e("code",[v._v("grid-gap")]),v._v("省略了第二个值，浏览器认为第二个值等于第一个值。")])]),v._v(" "),e("div",{staticClass:"custom-block danger"},[e("p",{staticClass:"custom-block-title"},[v._v("注意")]),v._v(" "),e("p",[v._v("根据最新标准，下面三个属性名的grid-前缀已经删除，grid-column-gap和grid-row-gap写成column-gap和row-gap，grid-gap写成gap。")])]),v._v(" "),e("ul",[e("li",[e("code",[v._v("grid-template-areas")]),v._v(' 属性： 用于定义区域。网格布局允许指定"区域"（area），一个区域由单个或多个单元格组成。如果某些区域不需要利用，则使用"点"（.）表示。')])]),v._v(" "),e("div",{staticClass:"custom-block danger"},[e("p",{staticClass:"custom-block-title"},[v._v("注意")]),v._v(" "),e("p",[v._v("区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为 "),e("code",[v._v("区域名-start")]),v._v("，终止网格线自动命名为 "),e("code",[v._v("区域名-end")]),v._v("。\n比如，区域名为header，则起始位置的水平网格线和垂直网格线叫做 header-start，终止位置的水平网格线和垂直网格线叫做 header-end。")])]),v._v(" "),e("ul",[e("li",[e("p",[e("code",[v._v("grid-auto-flow")]),v._v(' 属性： 划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。默认的放置顺序是"先行后列"，即先填满第一行，再开始放入第二行。\n'),e("code",[v._v("grid-auto-flow")]),v._v(" 属性默认值是 "),e("code",[v._v("row")]),v._v('，即"先行后列"。也可以将它设成 '),e("code",[v._v("column")]),v._v('，变成"先列后行"。\n还可以设成 '),e("code",[v._v("row dense")]),v._v(" 和 "),e("code",[v._v("column dense")]),v._v("。这两个值主要用于，某些项目指定位置以后，剩下的项目怎么自动放置。")])]),v._v(" "),e("li",[e("p",[e("code",[v._v("justify-items")]),v._v(" 属性： 设置单元格内容的水平位置（左中右）")])]),v._v(" "),e("li",[e("p",[e("code",[v._v("align-items")]),v._v(" 属性： 设置单元格内容的垂直位置（上中下）。")]),v._v(" "),e("ul",[e("li",[e("code",[v._v("start")]),v._v("：对齐单元格的起始边缘。")]),v._v(" "),e("li",[e("code",[v._v("end")]),v._v("：对齐单元格的结束边缘。")]),v._v(" "),e("li",[e("code",[v._v("center")]),v._v("：单元格内部居中。")]),v._v(" "),e("li",[e("code",[v._v("stretch")]),v._v("：拉伸，占满单元格的整个宽度（默认值）。")])])]),v._v(" "),e("li",[e("p",[e("code",[v._v("place-items")]),v._v(" 属性：是 "),e("code",[v._v("align-items")]),v._v(" 属性和 "),e("code",[v._v("justify-items")]),v._v(" 属性的合并简写形式。"),e("code",[v._v("place-items: <align-items> <justify-items>;")]),v._v("。\n如果省略第二个值，则浏览器认为与第一个值相等。")])]),v._v(" "),e("li",[e("p",[e("code",[v._v("justify-content")]),v._v(" 属性： 是整个内容区域在容器里面的水平位置（左中右）")])]),v._v(" "),e("li",[e("p",[e("code",[v._v("align-content")]),v._v(" 属性： 是整个内容区域的垂直位置（上中下）。")]),v._v(" "),e("ul",[e("li",[e("code",[v._v("start")]),v._v("：对齐容器的起始边框。")]),v._v(" "),e("li",[e("code",[v._v("end")]),v._v("：对齐容器的结束边框。")]),v._v(" "),e("li",[e("code",[v._v("center")]),v._v("：容器内部居中。")]),v._v(" "),e("li",[e("code",[v._v("stretch")]),v._v("：项目大小没有指定时，拉伸占据整个网格容器。")]),v._v(" "),e("li",[e("code",[v._v("space-around")]),v._v("：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍。")]),v._v(" "),e("li",[e("code",[v._v("space-between")]),v._v("：项目与项目的间隔相等，项目与容器边框之间没有间隔。")]),v._v(" "),e("li",[e("code",[v._v("pace-evenly")]),v._v("：项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。")])])]),v._v(" "),e("li",[e("p",[e("code",[v._v("place-content")]),v._v(" 属性：是 "),e("code",[v._v("align-content")]),v._v(" 属性和 "),e("code",[v._v("justify-content")]),v._v(" 属性的合并简写形式。"),e("code",[v._v("place-content: <align-content> <justify-content>")]),v._v("。\n如果省略第二个值，浏览器就会假定第二个值等于第一个值。")])]),v._v(" "),e("li",[e("p",[e("code",[v._v("grid-auto-columns")]),v._v(" 属性： 自动创建的多余网格的列宽")])]),v._v(" "),e("li",[e("p",[e("code",[v._v("grid-auto-rows")]),v._v(" 属性： 自动创建的多余网格的行高")])])]),v._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[v._v("提示")]),v._v(" "),e("p",[v._v("上面俩属性与 "),e("code",[v._v("grid-template-columns和grid-template-rows")]),v._v(" 完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。")])]),v._v(" "),e("ul",[e("li",[e("code",[v._v("grid-template")]),v._v(" 属性：简写模式，"),e("code",[v._v("grid-template: <grid-template-columns> <grid-template-rows> <grid-template-areas>;")])]),v._v(" "),e("li",[e("code",[v._v("grid")]),v._v(" 属性：简写模式，"),e("code",[v._v("grid: <grid-template-rows> <grid-template-columns> <grid-template-areas> <grid-auto-rows> <grid-auto-columns> <grid-auto-flow>")]),v._v(" 这六个属性的合并简写形式。")]),v._v(" "),e("li",[e("code",[v._v("grid-column-start")]),v._v(" 属性：左边框所在的垂直网格线")]),v._v(" "),e("li",[e("code",[v._v("grid-column-end")]),v._v(" 属性：右边框所在的垂直网格线")]),v._v(" "),e("li",[e("code",[v._v("grid-row-start")]),v._v(" 属性：上边框所在的水平网格线")]),v._v(" "),e("li",[e("code",[v._v("grid-row-end")]),v._v(" 属性：下边框所在的水平网格线")])]),v._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[v._v("提示")]),v._v(" "),e("p",[v._v("上面4个属性可以设置 "),e("strong",[v._v("span关键字")]),v._v('，表示"跨越"，即左右边框（上下边框）之间跨越多少个网格。\n这四个属性，如果产生了项目的重叠，则使用z-index属性指定项目的重叠顺序')])]),v._v(" "),e("ul",[e("li",[e("code",[v._v("grid-column")]),v._v(" 属性：合并简写形式 "),e("code",[v._v("grid-column: <grid-column-start> <grid-column-end>")])]),v._v(" "),e("li",[e("code",[v._v("grid-row")]),v._v(" 属性： 合并简写形式 "),e("code",[v._v("grid-row: <grid-row-start> <grid-row-end>")])]),v._v(" "),e("li",[e("code",[v._v("grid-area")]),v._v(" 属性：指定项目放在哪一个区域。也可以是合并形式，"),e("code",[v._v("grid-area: <row-start> <column-start> <row-end> <column-end>;")])]),v._v(" "),e("li",[e("code",[v._v("justify-self")]),v._v(" 属性：设置单元格内容的水平位置（左中右）")]),v._v(" "),e("li",[e("code",[v._v("justify-items")]),v._v(" 属性：的用法完全一致，但只作用于单个项目。")]),v._v(" "),e("li",[e("code",[v._v("align-self")]),v._v(" 属性：设置单元格内容的垂直位置（上中下）\n"),e("ul",[e("li",[v._v("start：对齐单元格的起始边缘。")]),v._v(" "),e("li",[v._v("end：对齐单元格的结束边缘。")]),v._v(" "),e("li",[v._v("center：单元格内部居中。")]),v._v(" "),e("li",[v._v("stretch：拉伸，占满单元格的整个宽度（默认值）。")])])]),v._v(" "),e("li",[e("code",[v._v("place-self")]),v._v(" 属性：是合并简写形式。"),e("code",[v._v("place-self: <align-self> <justify-self>;")])])]),v._v(" "),e("h2",{attrs:{id:"参考资料"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[v._v("#")]),v._v(" 参考资料")]),v._v(" "),e("p",[e("a",{attrs:{href:"https://juejin.cn/post/6854573220306255880",target:"_blank",rel:"noopener noreferrer"}},[v._v("最强大的 CSS 布局 —— Grid 布局"),e("OutboundLink")],1)]),v._v(" "),e("p",[e("a",{attrs:{href:"https://juejin.cn/post/6844903574929932301#heading-82",target:"_blank",rel:"noopener noreferrer"}},[v._v("干货!各种常见布局实现+知名网站实例分析"),e("OutboundLink")],1)]),v._v(" "),e("p",[e("a",{attrs:{href:"https://juejin.cn/post/6859685615269576718#heading-3",target:"_blank",rel:"noopener noreferrer"}},[v._v("从零开始の CSS 学习笔记——定位"),e("OutboundLink")],1)])])}),[],!1,null,null,null);_.default=i.exports}}]);