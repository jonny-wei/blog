(window.webpackJsonp=window.webpackJsonp||[]).push([[202],{490:function(t,e,a){"use strict";a.r(e);var s=a(6),r=Object(s.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"生命周期"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#生命周期"}},[t._v("#")]),t._v(" 生命周期")]),t._v(" "),e("p",[t._v("每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。生命周期并非指 Vue 中的生命周期钩子，而是指 Vue 内部从初始化到挂载 DOM 的完整流程。从"),e("code",[t._v("开始创建、初始化数据、编译模版、挂载 Dom -> 渲染、更新 -> 渲染、卸载")]),t._v("等一系列过程，我们称这是 Vue 的生命周期。")]),t._v(" "),e("h2",{attrs:{id:"生命周期过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#生命周期过程"}},[t._v("#")]),t._v(" 生命周期过程")]),t._v(" "),e("p",[e("img",{attrs:{src:"/blog/images/vue/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%BF%87%E7%A8%8B.png",alt:"生命周期过程"}})]),t._v(" "),e("h3",{attrs:{id:"初始化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#初始化"}},[t._v("#")]),t._v(" 初始化")]),t._v(" "),e("p",[t._v("new Vue() --- init ---\x3e $mount")]),t._v(" "),e("p",[t._v("在 new Vue() 之后。Vue 会调用挂载在其原型上的 _init 函数进行初始化，也就是这里的 init 过程，它会初始化生命周期、事件、props、methods、data、computed 与 watch 等。其中最重要的是通过 Object.defineProperty 设置 setter 与 getter 函数，用来实现响应式以及依赖收集。")]),t._v(" "),e("p",[t._v("初始化后会调用 $mount 进行挂载组件，如果是运行时编译（Runtime with Compiler），即不存在 render function 但是存在 template 的情况，则需要进行模板编译步骤。")]),t._v(" "),e("h3",{attrs:{id:"模板编译"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#模板编译"}},[t._v("#")]),t._v(" 模板编译")]),t._v(" "),e("p",[t._v("template --- compiler(parse,optimize,generate) ---\x3e render 函数(VNode)")]),t._v(" "),e("p",[t._v("模板编译通过 Compiler 完成，compiler 可以分成 parse、optimize 与 generate 三个阶段，最终得到 render function。")]),t._v(" "),e("h4",{attrs:{id:"parse-解析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#parse-解析"}},[t._v("#")]),t._v(" Parse 解析")]),t._v(" "),e("p",[t._v("Parse 会用正则等方式解析 template 模版中的指令、class、style 等数据，形成 AST。")]),t._v(" "),e("h4",{attrs:{id:"optimize-优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#optimize-优化"}},[t._v("#")]),t._v(" Optimize 优化")]),t._v(" "),e("p",[t._v("Optimize 的主要作用是标记 static 静态节点，这时 Vue 在编译过程中的优化，后面当 update 更新界面时，会有一个 patch 的过程，diff 算法会直接跳过静态节点，从而减少了比较的过程，优化了 patch 的性能。")]),t._v(" "),e("h4",{attrs:{id:"generate-生成"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#generate-生成"}},[t._v("#")]),t._v(" Generate 生成")]),t._v(" "),e("p",[t._v("Generate 是将 AST 转化成 render function 字符串的过程，得到结果是 render 的字符串以及 staticRenderFns 字符串。")]),t._v(" "),e("p",[t._v("在经历过 Parse、Optimize 与 Generate 这三个阶段之后，组件中就会得到用于渲染 VNode 所需的 render 函数了。")]),t._v(" "),e("h3",{attrs:{id:"响应式系统"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#响应式系统"}},[t._v("#")]),t._v(" 响应式系统")]),t._v(" "),e("p",[t._v("在 init 过程中通过 "),e("code",[t._v("Object.defineProperty")]),t._v(" 对响应式数据的 getter 和 setter 进行绑定，它使得当被设置的对象被读取的时候会执行 getter 函数，而在当被赋值的时候会执行 setter 函数。")]),t._v(" "),e("p",[t._v("当 render 函数被渲染的时候，因为会读取所需对象的值，所以会触发 getter 函数进行依赖收集，依赖收集的目的是将观察者 Watcher 对象存放到当前闭包中的订阅者 Dep 的 subs 中。")]),t._v(" "),e("p",[t._v("在修改对象的值时候，会触发 setter，setter 通知之前依赖收集得到的 Dep 中的每个 Watcher，告诉它们自己的值改变了，需要重新渲染视图。这时候这些 Watcher 就会开始调用 update 来更新视图，当然这中间还有一个 patch 过程以及使用队列来异步更新的策略。")]),t._v(" "),e("h3",{attrs:{id:"更新视图"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#更新视图"}},[t._v("#")]),t._v(" 更新视图")]),t._v(" "),e("p",[t._v("render ---\x3e VNode ---\x3e createElm/removeElm/patch(diff) ----\x3e UI")]),t._v(" "),e("p",[t._v("在修改对象值时，会通过 setter => Watcher => update 的流程来修改对应的视图，那么最终是如何更新视图呢？")]),t._v(" "),e("p",[t._v("当数据变化后，执行 render function 就可以得到一个新的 VNode 节点，我们如果想要得到新的视图，最简单粗暴的方法就是直接解析这个新的 VNode，然后用 innerHTML 直接全部渲染到真实 DOM 中。但是其实我们只对其中的一小块内容进行了修改，这样做似乎会消耗大量成本。通过新的 VNode 与旧的 VNode 传入 patch 进行比较，经过 diff 算法得出它们的差异。最后我们只需要将这些差异的对应 DOM 进行修改即可。")]),t._v(" "),e("h3",{attrs:{id:"生命周期过程总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#生命周期过程总结"}},[t._v("#")]),t._v(" 生命周期过程总结")]),t._v(" "),e("ul",[e("li",[t._v("首先，在实例化的过程中，把普通的 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defaineProperty 把这些属性全部转为 getter 和 setter。")]),t._v(" "),e("li",[t._v("Dep 是依赖收集器。data 下的每个属性都有一个唯一的 Dep 对象，在 get 中收集仅针对该属性的依赖，然后在 set 方法中触发所有收集的依赖。")]),t._v(" "),e("li",[t._v("在 Watcher 中对表达式求值，从而触发数据的 get。在求值之前将当前 Watch 实例设置到全局，使用 pushTarget(this) 方法。")]),t._v(" "),e("li",[t._v("在 get 中收集依赖，this.subs.push(sub) 和 set 的时候触发回调 Dep.notify。")]),t._v(" "),e("li",[t._v("Compile 中首先将 template 或 el 编译成 render 函数，render 函数返回一个虚拟 DOM 对象（将模版转为 render 函数的时候，实际是先生成的抽象语法树 AST，再将抽象语法树转成的 render 函数）")]),t._v(" "),e("li",[t._v("当 vm._render 执行的时候，所依赖的变量就会被求值，并被收集为依赖。按照 Vue 中 watch.js 的逻辑，当依赖的变量有变化时不仅仅回调函数被执行，实际上还要重新求值，即还要执行一遍。")]),t._v(" "),e("li",[t._v("如果还没有 preVnode 说明是首次渲染，直接创建真实 DOM。如果已经有了 prevVnode 说明不是首次渲染，那么就采用 patch 算法进行必要的 DOM 操作。这就是 Vue 更新 DOM 的逻辑。")])]),t._v(" "),e("h2",{attrs:{id:"生命周期钩子"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#生命周期钩子"}},[t._v("#")]),t._v(" 生命周期钩子")]),t._v(" "),e("p",[e("img",{attrs:{src:"/blog/images/vue/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90.png",alt:"生命周期钩子"}})]),t._v(" "),e("h3",{attrs:{id:"vue3-生命周期"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue3-生命周期"}},[t._v("#")]),t._v(" Vue3 生命周期")]),t._v(" "),e("p",[e("img",{attrs:{src:"/blog/images/vue/vue3%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png",alt:"vue3生命周期"}})]),t._v(" "),e("p",[t._v("Vue实例的生命周期大致可分为4个阶段：")]),t._v(" "),e("ul",[e("li",[t._v("初始化阶段：为 Vue 实例上初始化一些属性，事件以及响应式数据；")]),t._v(" "),e("li",[t._v("模板编译阶段：将模板编译成渲染函数；")]),t._v(" "),e("li",[t._v("挂载阶段：将实例挂载到指定的 DOM 上，即将模板渲染到真实 DOM 中；")]),t._v(" "),e("li",[t._v("销毁阶段：将实例自身从父组件中删除，并取消依赖追踪及事件监听器；")])]),t._v(" "),e("h3",{attrs:{id:"create"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#create"}},[t._v("#")]),t._v(" create")]),t._v(" "),e("p",[t._v("实例化 Vue 阶段。")]),t._v(" "),e("p",[t._v("在谈到 Vue 的生命周期的时候，我们首先需要创建一个实例，也就是在 new Vue() 对象过程中，首先执行了 init 函数（init 是 Vue 构造函数内部默认执行的），为当前实例完成 基础配置，包括定义 Vue 构造函数上的 静态方法 以及相关的 生命周期钩子函数。")]),t._v(" "),e("p",[t._v("在 beforeCreate 和 created 的钩子调用是在 initState 前后，该函数作用是初始化 props、data、methods、computed、watch 等属性，因此 beforeCreated 的钩子函数也就无法获取到 props 和 data 等定义的值，也不能调用 methods 中定义的函数。")]),t._v(" "),e("p",[t._v("在这俩个钩子函数执行的时候，并没有渲染 DOM，所以我们也不能够访问 DOM，一般来说，如果组件在加载的时候需要和后端有交互，放在这俩个钩子函数执行都可以，如果是需要访问 props、data 等数据的话，就需要使用 created 钩子函数。")]),t._v(" "),e("p",[t._v("完成配置对象的初始化后，会调用 created 生命周期钩子函数，这个时候 Vue 对象实例化完毕，DOM 树依旧未生成，页面还是一片空白，但是，实例已完成以下配置：数据观察（data observer）、属性和方法运算 以及 watch / event 事件回调。此时，该钩子函数适合 处理网络请求 等逻辑操作。")]),t._v(" "),e("p",[t._v("如果在实例化配置中存在 el 选项，实例将立即进入 编译阶段，否则，则停止编译，也就意味着停止了生命周期，知道在该 Vue 实例上调用 vm.$mount(el)。")]),t._v(" "),e("p",[t._v("编译阶段，如果存在 render 选项，则 template 将被忽略，因为 render 渲染函数是字符串模版的代替方案。如果存在 template 选项，则会通过 compiler 编译成 render function（渲染函数），预编译是在 Webpack 等构建工具中完成的，而运行时编译则是在运行时编译的。如果既无 render 选项也无 template 选项，则查找 el 选项的 outerHTML 作为 template 并编译成 render function。")]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[t._v("优先级")]),t._v(" "),e("p",[t._v("Render 选项 > template 选项 > outerHTML")])]),t._v(" "),e("h3",{attrs:{id:"mount"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mount"}},[t._v("#")]),t._v(" mount")]),t._v(" "),e("p",[t._v("开始挂载前，会先执行钩子函数 beforeMount，编译 template 里的内容并在虚拟 DOM 中执行，页面上依旧没有任何展示。")]),t._v(" "),e("p",[t._v("接着，Vue 内部将给 vm 实例对象添加 $el 属性，并使用编译好的 HTML 内容替换 el 选项指向的 DOM 对象或者选择对应的 HTML 标签里面的内容。当真实 DOM 挂载完毕后，执行 mounted 钩子函数。此时，该钩子函数适合用于 访问真实 DOM 数据坐标信息。")]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[t._v("注意")]),t._v(" "),e("p",[t._v("created 阶段的网络请求与 mounted 请求的区别：前者页面视图未出现，如果请求信息过多，页面会长时间处于白屏状态。")])]),t._v(" "),e("h3",{attrs:{id:"update"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#update"}},[t._v("#")]),t._v(" update")]),t._v(" "),e("p",[t._v("当数据产生变化，会进入更新周期函数并先调用 beforeUpdate，这个钩子中可进一步修改 $vm.data，但是不会触发附加的重渲染过程。然后经过新旧对比产生新的 VirtualDOM 并进行重渲染，更新完成后将调用 updated 钩子函数。")]),t._v(" "),e("p",[t._v("当 updated 钩子调用时，组件 DOM 的 data 已经更新，所以你现在可以执行依赖于 DOM 的操作。但是不要在此时修改 data，否则会再次触发 beforeUpdate、updated 这个两个钩子，导致进入死循环。")]),t._v(" "),e("h3",{attrs:{id:"destroy"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#destroy"}},[t._v("#")]),t._v(" destroy")]),t._v(" "),e("p",[t._v("beforeDestroy 钩子函数在实例销毁钱调用，在这步，实例仍然可用。")]),t._v(" "),e("p",[t._v("beforeDestroyed 钩子函数在 Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://cn.vuejs.org/api/composition-api-lifecycle.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Vue3 生命周期钩子 API"),e("OutboundLink")],1)]),t._v(" "),e("h3",{attrs:{id:"小结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[t._v("#")]),t._v(" 小结")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",{staticStyle:{"text-align":"left"}},[t._v("生命周期")]),t._v(" "),e("th",{staticStyle:{"text-align":"left"}},[t._v("描述")]),t._v(" "),e("th",{staticStyle:{"text-align":"left"}},[t._v("最佳实践")])])]),t._v(" "),e("tbody",[e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("beforeCreate")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("组件实例被创建之初，组件的属性生效之前。在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。数据初始化并未完成，无法访问 props、data")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("常用于初始化非响应式变量，插件开发中执行一些初始化任务")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("created")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("组件初始化完毕，实例已完成以下的配置：数据观测 (data observer)，属性绑定和方法的运算，watch/event 事件回调，但真实 dom 还没有生成，"),e("code",[t._v("$el")]),t._v(" 还不可用")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("常用于简单的 AJAX 请求，页面的初始化")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("beforeMount")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("在挂载开始之前被调用，相关的 render 函数首次被调用，在此阶段可获取到 "),e("code",[t._v("vm.el")]),t._v("，此阶段 "),e("code",[t._v("vm.el")]),t._v(" 虽已完成"),e("code",[t._v("DOM")]),t._v(" 初始化，但并未挂载在 "),e("code",[t._v("el")]),t._v(" 选项上")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}})]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("mounted")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("el 被新创建的 "),e("code",[t._v("vm.$el")]),t._v(" 替换，并挂载到实例上去之后调用该钩子。注意 mounted 不会保证所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以在 mounted 内部使用 "),e("code",[t._v("vm.$nextTick")]),t._v(", 该钩子在服务器端渲染期间不被调用。")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("常用于获取 VNode 信息和操作，AJAX 请求")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("beforeUpdate")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务端进行。")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("update")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("组件数据更新之后。由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用计算属性或 watcher 取而代之。注意 updated 不会保证所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以在 updated 里使用 "),e("code",[t._v("vm.$nextTick")]),t._v("。该钩子在服务器端渲染期间不被调用。")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("当 updated 钩子调用时，组件 DOM 的 data 已经更新，所以你现在可以执行依赖于 DOM 的操作。但是不要在此时修改 data，否则会再次触发 beforeUpdate、updated 这个两个钩子，导致进入死循环。")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("activited")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("keep-alive 专属，组件被激活时调用。该钩子在服务器端渲染期间不被调用。")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}})]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("deactivated")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("keep-alive 专属，组件被销毁时调用。该钩子在服务器端渲染期间不被调用。")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}})]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("beforeDestory")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("实例销毁之前调用。在这一步，"),e("strong",[t._v("实例仍然完全可用")]),t._v("。该钩子在服务器端渲染期间不被调用。")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("常用于销毁定时器、解绑全局事件、销毁插件对象等操作")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("destoryed")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("实例销毁后调用。该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。该钩子在服务器端渲染期间不被调用。")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}})]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("errorCaptured")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("捕获一个来自子孙组件的错误时被调用")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}})])])]),t._v(" "),e("h3",{attrs:{id:"errorcaptured"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#errorcaptured"}},[t._v("#")]),t._v(" errorCaptured")]),t._v(" "),e("p",[t._v("errorCaptured (err: Error, vm: Component, info: string) => ?boolean")]),t._v(" "),e("p",[t._v("当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。你可以在此钩子中修改组件的状态。因此在捕获错误时，在模板或渲染函数中有一个条件判断来绕过其它内容就很重要；不然该组件可能会进入一个无限的渲染循环。")]),t._v(" "),e("p",[t._v("错误传播规则:")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("默认情况下，如果全局的 config.errorHandler 被定义，所有的错误仍会发送它，因此这些错误仍然会向单一的分析服务的地方进行汇报。")])]),t._v(" "),e("li",[e("p",[t._v("如果一个组件的继承或父级从属链路中存在多个 errorCaptured 钩子，则它们将会被相同的错误逐个唤起。")])]),t._v(" "),e("li",[e("p",[t._v("如果此 errorCaptured 钩子自身抛出了一个错误，则这个新错误和原本被捕获的错误都会发送给全局的 config.errorHandler。")])]),t._v(" "),e("li",[e("p",[t._v("一个 errorCaptured 钩子能够返回 false 以阻止错误继续向上传播。本质上是说“这个错误已经被搞定了且应该被忽略”。它会阻止其它任何会被这个错误唤起的 errorCaptured 钩子和全局的 config.errorHandler。")])])]),t._v(" "),e("h2",{attrs:{id:"问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#问题"}},[t._v("#")]),t._v(" 问题")]),t._v(" "),e("h3",{attrs:{id:"q1-为什么生命周期函数不能使用箭头函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#q1-为什么生命周期函数不能使用箭头函数"}},[t._v("#")]),t._v(" Q1. 为什么生命周期函数不能使用箭头函数")]),t._v(" "),e("p",[t._v("所有的生命周期钩子自动绑定 this 上下文到实例中，因此你可以访问数据，对 property 和方法进行运算。这意味着你不能使用箭头函数来定义一个生命周期方法 (例如 created: () => this.fetchTodos())。这是"),e("strong",[t._v("因为箭头函数绑定了父上下文，因此 this 与你期待的 Vue 实例不同")]),t._v("，this.fetchTodos 的行为未定义。")]),t._v(" "),e("h3",{attrs:{id:"q2-vue-的父组件和子组件生命周期钩子函数执行顺序"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#q2-vue-的父组件和子组件生命周期钩子函数执行顺序"}},[t._v("#")]),t._v(" Q2. Vue 的父组件和子组件生命周期钩子函数执行顺序？")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("加载渲染过程")]),t._v(" "),e("p",[t._v("父 beforeCreate -> 父 created -> 父 beforeMount -> 子 beforeCreate -> 子 created -> 子 beforeMount -> 子 mounted -> 父 mounted")])]),t._v(" "),e("li",[e("p",[t._v("子组件更新过程")]),t._v(" "),e("p",[t._v("父 beforeUpdate -> 子 beforeUpdate -> 子 updated -> 父 updated")])]),t._v(" "),e("li",[e("p",[t._v("父组件更新过程")]),t._v(" "),e("p",[t._v("父 beforeUpdate -> 父 updated")])]),t._v(" "),e("li",[e("p",[t._v("销毁过程")]),t._v(" "),e("p",[t._v("父 beforeDestroy -> 子 beforeDestroy -> 子 destroyed -> 父 destroyed、")])])]),t._v(" "),e("p",[t._v("综上：")]),t._v(" "),e("ul",[e("li",[t._v("父组件的生命周期钩子在子组件之前执行，确保父组件的状态在子组件被创建时是可用的。")]),t._v(" "),e("li",[t._v("在更新和卸载阶段，父组件的钩子在子组件之前执行，保持了父子组件的顺序。")])]),t._v(" "),e("h3",{attrs:{id:"q3-在哪个生命周期内调用异步请求"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#q3-在哪个生命周期内调用异步请求"}},[t._v("#")]),t._v(" Q3. 在哪个生命周期内调用异步请求？")]),t._v(" "),e("p",[t._v("如果组件在加载的时候需要和后端有交互，放在 beforeCreate、created、beforeMount、mounted 都可以，如果是需要访问 props、data 等数据的话，可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，props、data 已经创建，可以将服务端端返回的数据进行赋值。但是本人推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：")]),t._v(" "),e("ul",[e("li",[t._v("能更快获取到服务端数据，减少页面 loading 时间")]),t._v(" "),e("li",[t._v("ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性")])]),t._v(" "),e("p",[t._v("created 阶段的网络请求与 mounted 请求的区别：前者页面视图未出现，如果请求信息过多，页面会长时间处于白屏状态。")]),t._v(" "),e("h3",{attrs:{id:"q4-在什么阶段才能访问操作dom"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#q4-在什么阶段才能访问操作dom"}},[t._v("#")]),t._v(" Q4. 在什么阶段才能访问操作DOM？")]),t._v(" "),e("p",[t._v("在钩子函数 mounted 被调用前，Vue 已经将编译好的模板挂载到页面上，所以在 mounted 中可以访问操作 DOM。vue 具体的生命周期示意图可以参见如下:")]),t._v(" "),e("p",[e("img",{attrs:{src:"/blog/images/vue/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B3%A8%E9%87%8A.png",alt:"vue生命周期注释"}})]),t._v(" "),e("h3",{attrs:{id:"q5-父组件可以监听到子组件的生命周期吗"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#q5-父组件可以监听到子组件的生命周期吗"}},[t._v("#")]),t._v(" Q5. 父组件可以监听到子组件的生命周期吗？")]),t._v(" "),e("p",[t._v("比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理，可以通过以下写法实现：")]),t._v(" "),e("div",{staticClass:"language-js line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Parent.vue")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Child @mounted"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"doSomething"')]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n    \n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Child.vue")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("mounted")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("$emit")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"mounted"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br")])]),e("p",[t._v("以上需要手动通过 $emit 触发父组件的事件，更简单的方式可以在父组件引用子组件时通过 @hook 来监听即可，如下所示：")]),t._v(" "),e("div",{staticClass:"language-js line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//  Parent.vue")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Child @hook"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("mounted"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"doSomething"')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("Child"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("doSomething")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n   console"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'父组件监听到 mounted 钩子函数 ...'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    \n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//  Child.vue")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("mounted")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n   console"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'子组件触发 mounted 钩子函数 ...'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("    \n    \n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 以上输出顺序为：")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 子组件触发 mounted 钩子函数 ...")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 父组件监听到 mounted 钩子函数 ...     ")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br"),e("span",{staticClass:"line-number"},[t._v("10")]),e("br"),e("span",{staticClass:"line-number"},[t._v("11")]),e("br"),e("span",{staticClass:"line-number"},[t._v("12")]),e("br"),e("span",{staticClass:"line-number"},[t._v("13")]),e("br"),e("span",{staticClass:"line-number"},[t._v("14")]),e("br"),e("span",{staticClass:"line-number"},[t._v("15")]),e("br")])]),e("p",[t._v("当然 @hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。")])])}),[],!1,null,null,null);e.default=r.exports}}]);