(window.webpackJsonp=window.webpackJsonp||[]).push([[139],{441:function(t,a,s){"use strict";s.r(a);var e=s(6),r=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"数据通信与渲染"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据通信与渲染"}},[t._v("#")]),t._v(" 数据通信与渲染")]),t._v(" "),a("h2",{attrs:{id:"setdata"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#setdata"}},[t._v("#")]),t._v(" setData")]),t._v(" "),a("h3",{attrs:{id:"setdata-的流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#setdata-的流程"}},[t._v("#")]),t._v(" setData 的流程")]),t._v(" "),a("p",[a("code",[t._v("setData")]),t._v(" 的过程，大致可以分成几个阶段：")]),t._v(" "),a("ul",[a("li",[t._v("逻辑层虚拟 DOM 树的遍历和更新，触发组件生命周期和 observer 等；")]),t._v(" "),a("li",[t._v("将 data 从逻辑层传输到视图层；")]),t._v(" "),a("li",[t._v("视图层虚拟 DOM 树的更新、真实 DOM 元素的更新并触发页面渲染更新，完成后触发"),a("code",[t._v("setData")]),t._v("回调。")])]),t._v(" "),a("h3",{attrs:{id:"数据通信"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据通信"}},[t._v("#")]),t._v(" 数据通信")]),t._v(" "),a("p",[t._v("setData 将 data 从逻辑层传输到视图层。由于小程序的逻辑层和视图层是两个独立的运行环境、分属不同的线程或进程，不能直接进行数据共享，需要进行数据的序列化、跨线程/进程的数据传输、数据的反序列化，因此数据传输过程是"),a("strong",[t._v("异步的、非实时的")]),t._v("。iOS/iPadOS/MacOS 上，数据传输是通过 "),a("code",[t._v("evaluateJavascript")]),t._v(" 实现的，还会有额外 JS 脚本解析和执行的耗时。数据传输的耗时与"),a("strong",[t._v("数据量的大小")]),t._v("正相关，如果对端线程处于繁忙状态，数据会在"),a("strong",[t._v("消息队列中等待")]),t._v("。")]),t._v(" "),a("h3",{attrs:{id:"使用建议"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用建议"}},[t._v("#")]),t._v(" 使用建议")]),t._v(" "),a("ol",[a("li",[a("p",[a("strong",[t._v("data 应只包括渲染相关的数据，避免每次 setData 都传递大量新数据。"),a("strong",[t._v("setData 应只用来进行渲染相关的数据更新。用 setData 的方式更新渲染无关的字段，会触发额外的渲染流程，或者增加传输的数据量，影响渲染耗时。页面或组件渲染无关的数据，应挂在非 data 的字段下；页面或组件渲染间接相关的数据可以设置为「"),a("a",{attrs:{href:"https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/pure-data.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("纯数据字段"),a("OutboundLink")],1),t._v("」，可以使用 setData 设置并使用 observers 监听变化；避免使用 data 在页面或组件方法间进行")]),t._v("数据共享")]),t._v("。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("控制 setData 的频率，避免频繁的去 setData。"),a("strong",[t._v("仅在需要进行页面内容更新时调用 setData；对连续的 setData 调用尽可能的进行")]),t._v("合并")]),t._v("。每次 setData 都会触发逻辑层虚拟 DOM 树的遍历和更新，也可能会导致触发一次完整的页面渲染流程。过于频繁（毫秒级）的调用 "),a("code",[t._v("setData")]),t._v("，会导致以下后果：")]),t._v(" "),a("ul",[a("li",[t._v("逻辑层 JS 线程持续繁忙，无法正常响应用户操作的事件，也无法正常完成页面切换；")]),t._v(" "),a("li",[t._v("视图层 JS 线程持续处于忙碌状态，逻辑层 -> 视图层通信耗时上升，视图层收到消息的延时较高，渲染出现明显延迟；")]),t._v(" "),a("li",[t._v("视图层无法及时响应用户操作，用户滑动页面时感到明显卡顿，操作反馈延迟，用户操作事件无法及时传递到逻辑层，逻辑层亦无法及时将操作处理结果及时传递到视图层。")])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("选择合适的 setData 范围")]),t._v("。组件的 setData 只会引起当前组件和子组件的更新，可以降低虚拟 DOM 更新时的计算开销。对于需要频繁更新的页面元素（例如：秒杀倒计时），可以封装为独立的组件，在组件内进行 setData 操作。必要时可以使用 "),a("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/CSS/contain",target:"_blank",rel:"noopener noreferrer"}},[t._v("CSS contain 属性"),a("OutboundLink")],1),t._v("限制计算布局、样式和绘制等的范围。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("setData 应只传发生变化的数据")]),t._v("。setData 的数据量会影响数据拷贝和数据通讯的耗时，增加页面更新的开销，造成页面更新延迟。setData 应只传入发生变化的字段；建议以数据路径形式改变数组中的某一项或对象的某个属性。")])]),t._v(" "),a("li",[a("p",[t._v("**后台态页面进行 setData。**页面切后台后的更新操作，应尽量避免，或延迟到页面 "),a("code",[t._v("onShow")]),t._v(" 后延迟进行。由于小程序逻辑层是单线程运行的，后台态页面去 "),a("code",[t._v("setData")]),t._v(" 也会抢占前台页面的运行资源，且后台态页面的的渲染用户是无法感知的，会产生浪费。在某些平台上，小程序渲染层各 WebView 也是共享同一个线程，后台页面的渲染和逻辑执行也会导致前台页面的卡顿。")])])]),t._v(" "),a("h2",{attrs:{id:"双线程通信"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#双线程通信"}},[t._v("#")]),t._v(" 双线程通信")]),t._v(" "),a("p",[t._v("小程序的视图层目前使用 WebView 作为渲染载体，而逻辑层是由独立的 JavascriptCore 作为运行环境。在架构上，WebView 和 JavascriptCore 都是独立的模块，并不具备数据直接共享的通道。")]),t._v(" "),a("p",[t._v("一个小程序存在多个界面，所以渲染层存在多个 WebView 线程。 "),a("strong",[t._v("逻辑层和渲染层的通信会经由微信客户端（Native）做中转，逻辑层发送网络请求也经由 Native 转发")]),t._v(" 。")]),t._v(" "),a("p",[t._v("当前，视图层和逻辑层的数据传输，实际上通过两边提供的 evaluateJavascript 所实现。**即用户传输的数据，需要将其转换为字符串形式传递，同时把转换后的数据内容拼接成一份 JS 脚本，再通过执行 JS 脚本的形式传递到两边独立环境。**而 evaluateJavascript 的执行会受很多方面的影响，数据到达视图层并不是实时的。所以我们的"),a("code",[t._v("setData")]),t._v("函数将数据从逻辑层发送到视图层，是异步的。")]),t._v(" "),a("h2",{attrs:{id:"双线程渲染机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#双线程渲染机制"}},[t._v("#")]),t._v(" 双线程渲染机制")]),t._v(" "),a("p",[t._v("双线程的渲染，其实是结合了模版绑定、虚拟 DOM、线程通信，最后整合的一个执行步骤：")]),t._v(" "),a("ol",[a("li",[t._v("通过模版数据绑定和虚拟 DOM 机制，小程序提供了带有数据绑定语法的 DSL 给到开发者，用来在渲染层描述界面的结构。")])]),t._v(" "),a("p",[t._v("就是我们常见的这些：")]),t._v(" "),a("div",{staticClass:"language-html line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-html"}},[a("code",[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("view")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" {{ message }} "),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("view")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("view")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[a("span",{pre:!0,attrs:{class:"token namespace"}},[t._v("wx:")]),t._v("if")]),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("{{condition}}"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("view")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("checkbox")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("checked")]),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("{{false}}"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("checkbox")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br")])]),a("ol",{attrs:{start:"2"}},[a("li",[t._v("小程序在逻辑层提供了设置页面数据的 api - setData")])]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("setData")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("key")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" value\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br")])]),a("p",[a("code",[t._v("setData")]),t._v("函数用于将数据从逻辑层发送到视图层（异步），同时改变对应的"),a("code",[t._v("this.data")]),t._v("的值（同步）。")]),t._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[t._v("逻辑层需要更改界面时，只要把修改后的 data 通过 setData 传到渲染层。")])]),t._v(" "),a("p",[t._v("传输的数据，会转换为字符串形式传递，故应尽量避免传递大量数据。")]),t._v(" "),a("ol",{attrs:{start:"4"}},[a("li",[t._v("渲染层会根据前面提到的渲染机制重新生成 VD（虚拟 DOM）树，并更新到对应的 DOM 树上，引起界面变化。")])]),t._v(" "),a("h2",{attrs:{id:"原生组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原生组件"}},[t._v("#")]),t._v(" 原生组件")]),t._v(" "),a("h3",{attrs:{id:"原生组件的引入"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原生组件的引入"}},[t._v("#")]),t._v(" 原生组件的引入")]),t._v(" "),a("p",[t._v("我们知道，用户的一次交互，如点击某个按钮，开发者的逻辑层要处理一些事情，然后再通过 setData 引起界面变化。这样的一个过程需要四次通信：")]),t._v(" "),a("ol",[a("li",[t._v("渲染层 -> Native（点击事件）。")]),t._v(" "),a("li",[t._v("Native -> 逻辑层（点击事件）。")]),t._v(" "),a("li",[t._v("逻辑层 -> Native（setData）。")]),t._v(" "),a("li",[t._v("Native -> 渲染层（setData）。")])]),t._v(" "),a("p",[t._v("在一些强交互的场景（表单、canvas 等），这样的操作流程会导致用户体验卡顿。")]),t._v(" "),a("p",[t._v("小程序是 Hybrid 应用，除了 Web 组件的渲染体系（上面讲到），还有由客户端原生参与组件（原生组件）的渲染。引入原生组件的有 3 个好处：")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("绕过 setData、数据通信和重渲染流程，使渲染性能更好。")])]),t._v(" "),a("li",[a("strong",[t._v("扩展 Web 的能力。")]),t._v(" 比如像输入框组件（input, textarea）有更好地控制键盘的能力。")]),t._v(" "),a("li",[a("strong",[t._v("体验更好，同时也减轻 WebView 的渲染工作。")]),t._v(" 比如像地图组件（map）这类较复杂的组件，其渲染工作不占用 WebView 线程，而交给更高效的客户端原生处理。")])]),t._v(" "),a("h3",{attrs:{id:"原生组件的渲染过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原生组件的渲染过程"}},[t._v("#")]),t._v(" 原生组件的渲染过程")]),t._v(" "),a("ol",[a("li",[t._v("组件被创建，包括组件属性会依次赋值。")]),t._v(" "),a("li",[t._v("组件被插入到 DOM 树里，浏览器内核会立即计算布局，此时我们可以读取出组件相对页面的位置（x, y 坐标）、宽高。")]),t._v(" "),a("li",[t._v("组件通知客户端，客户端在相同的位置上，根据宽高插入一块原生区域，之后客户端就在这块区域渲染界面。")]),t._v(" "),a("li",[t._v("当位置或宽高发生变化时，组件会通知客户端做相应的调整。")])]),t._v(" "),a("p",[t._v("简单来说，就是 "),a("strong",[t._v("原生组件在 WebView 这一层只需要渲染一个占位元素，之后客户端在这块占位元素之上叠了一层原生界面。")])]),t._v(" "),a("p",[t._v("有利必有弊，原生组件也是有限制的：")]),t._v(" "),a("ul",[a("li",[t._v("最主要的限制是一些 CSS 样式无法应用于原生组件")]),t._v(" "),a("li",[t._v("由于客户端渲染，原生组件的层级会比所有在 WebView 层渲染的普通组件要高")])]),t._v(" "),a("p",[a("a",{attrs:{href:"https://developers.weixin.qq.com/miniprogram/dev/framework/performance/tips/runtime_setData.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("合理使用 setData - 官方 5 条 setData 优化建议"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("a",{attrs:{href:"https://juejin.cn/post/7155646965978497032#heading-0",target:"_blank",rel:"noopener noreferrer"}},[t._v("性能优化之 setData"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("a",{attrs:{href:"https://godbasin.github.io/front-end-playground/wxapp/wxapp-principle/3-wxapp-set-data.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("被删的前端游乐场"),a("OutboundLink")],1)])])}),[],!1,null,null,null);a.default=r.exports}}]);