(window.webpackJsonp=window.webpackJsonp||[]).push([[103],{555:function(e,v,a){"use strict";a.r(v);var _=a(15),t=Object(_.a)({},(function(){var e=this,v=e.$createElement,a=e._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"jsbridge"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jsbridge"}},[e._v("#")]),e._v(" JSBridge")]),e._v(" "),a("h2",{attrs:{id:"介绍"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[e._v("#")]),e._v(" 介绍")]),e._v(" "),a("p",[a("strong",[e._v("JSBridge")]),e._v("  是一种 JS 实现的 Bridge，连接着桥两端的 Native 和 WebView。它在 APP 内方便地让 Native 调用 JS，JS 调用 Native ，是双向通信的通道。JSBridge 主要是 "),a("strong",[e._v("给 JavaScript 提供调用 Native 功能的接口")]),e._v("，实现原生功能如查看本地相册、打开摄像头、指纹支付等 Native 功能。它的核心是 "),a("strong",[e._v("构建 Native 和非 Native 间消息通信的通道")]),e._v("，而且是 "),a("strong",[e._v("双向通信的通道")]),e._v("。")]),e._v(" "),a("p",[a("strong",[e._v("H5 与 Native 对比")])]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",[e._v("name")]),e._v(" "),a("th",[e._v("H5")]),e._v(" "),a("th",[e._v("Native")])])]),e._v(" "),a("tbody",[a("tr",[a("td",[e._v("稳定性")]),e._v(" "),a("td",[e._v("调用系统浏览器内核，稳定性较差")]),e._v(" "),a("td",[e._v("使用原生内核，更加稳定")])]),e._v(" "),a("tr",[a("td",[e._v("灵活性")]),e._v(" "),a("td",[e._v("版本迭代快，上线灵活")]),e._v(" "),a("td",[e._v("迭代慢，需要应用商店审核，上线速度受限制")])]),e._v(" "),a("tr",[a("td",[e._v("受网速 影响")]),e._v(" "),a("td",[e._v("较大")]),e._v(" "),a("td",[e._v("较小")])]),e._v(" "),a("tr",[a("td",[e._v("流畅度")]),e._v(" "),a("td",[e._v("有时加载慢，给用户“卡顿”的感觉")]),e._v(" "),a("td",[e._v("加载速度快，更加流畅")])]),e._v(" "),a("tr",[a("td",[e._v("用户体验")]),e._v(" "),a("td",[e._v("功能受浏览器限制，体验有时较差")]),e._v(" "),a("td",[e._v("原生系统 api 丰富，能实现的功能较多，体验较好")])]),e._v(" "),a("tr",[a("td",[e._v("可移植性")]),e._v(" "),a("td",[e._v("兼容跨平台跨系统，如 PC 与 移动端，iOS 与 Android")]),e._v(" "),a("td",[e._v("可移植性较低，对于 iOS 和 Android 需要维护两套代码")])])])]),e._v(" "),a("h2",{attrs:{id:"双向通信原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#双向通信原理"}},[e._v("#")]),e._v(" 双向通信原理")]),e._v(" "),a("h3",{attrs:{id:"js-调用-native"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js-调用-native"}},[e._v("#")]),e._v(" JS 调用 Native")]),e._v(" "),a("p",[e._v("JS 调用 Native 的实现方式较多，主要有拦截 "),a("code",[e._v("URL Scheme")]),e._v(" 、重写 prompt 、注入 API 等方法。")]),e._v(" "),a("h4",{attrs:{id:"拦截-url-scheme"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#拦截-url-scheme"}},[e._v("#")]),e._v(" 拦截 URL Scheme")]),e._v(" "),a("p",[e._v("URL Schema 是类 UR L的一种请求格式，格式如下：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("<protocol>://<host>/<path>?<qeury>#fragment\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("我们可以自定义 JSBridge 通信的 URL Schema，比如："),a("code",[e._v("jsbridge://showToast?text=hello")])]),e._v(" "),a("p",[e._v("Native 加载 WebView之后，Web 发送的所有请求都会经过 WebView 组件，所以 Native 可以重写 WebView 里的方法，从来拦截 Web发起的请求，我们对请求的格式进行判断：")]),e._v(" "),a("ul",[a("li",[e._v("如果符合我们自定义的URL Schema，对URL进行解析，拿到相关操作、操作，进而调用原生Native的方法")]),e._v(" "),a("li",[e._v("如果不符合我们自定义的URL Schema，我们直接转发，请求真正的服务")])]),e._v(" "),a("p",[a("img",{attrs:{src:"/blog/images/mobile/jsbridge1.png",alt:"jsbridge1"}})]),e._v(" "),a("p",[e._v("Web发送URL请求的方法有这么几种：")]),e._v(" "),a("ol",[a("li",[a("code",[e._v("a")]),e._v("标签")]),e._v(" "),a("li",[a("code",[e._v("location.href")])]),e._v(" "),a("li",[e._v("使用"),a("code",[e._v("iframe.src")])]),e._v(" "),a("li",[e._v("发送"),a("code",[e._v("ajax")]),e._v("请求")])]),e._v(" "),a("p",[e._v("这些方法，"),a("code",[e._v("a")]),e._v("标签需要用户操作，"),a("code",[e._v("location.href")]),e._v("可能会引起页面的跳转丢失调用，发送"),a("code",[e._v("ajax")]),e._v("请求Android没有相应的拦截方法，所以使用"),a("code",[e._v("iframe.src")]),e._v("是经常会使用的方案。")]),e._v(" "),a("p",[e._v("Android 和 iOS 都可以通过拦截 URL Scheme 并解析 Scheme 来决定是否进行对应的 Native 代码逻辑处理：")]),e._v(" "),a("ul",[a("li",[e._v("Android 侧，"),a("code",[e._v("Webview")]),e._v(" 提供了 "),a("code",[e._v("shouldOverrideUrlLoading")]),e._v(" 方法来提供给 Native 拦截 H5 发送的 "),a("code",[e._v("URL Scheme")]),e._v(" 请求。")]),e._v(" "),a("li",[e._v("iOS 侧  "),a("code",[e._v("WKWebview")]),e._v(" 可以根据拦截到的 "),a("code",[e._v("URL Scheme")]),e._v(" 和对应的参数执行相关的操作。")])]),e._v(" "),a("p",[e._v("拦截 URL Scheme 这种方法的优点是不存在漏洞问题、使用灵活，可以实现 H5 和 Native 页面的无缝切换。例如在某一页面需要快速上线的情况下，先开发出 H5 页面。某一链接填写的是 H5 链接，在对应的 Native 页面开发完成前先跳转至 H5 页面，待 Native 页面开发完后再进行拦截，跳转至 Native 页面，此时 H5 的链接无需进行修改。但是使用 iframe.src 来发送 "),a("code",[e._v("URL Scheme")]),e._v(" 需要对 URL 的长度作控制，使用复杂，速度较慢。")]),e._v(" "),a("p",[e._v("拦截 URL Scheme 这种方式从早期就存在，兼容性很好，但是由于是基于URL的方式，长度受到限制而且不太直观，数据格式有限制，而且建立请求有时间耗时。")]),e._v(" "),a("h4",{attrs:{id:"重写-prompt-等原生-js-方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重写-prompt-等原生-js-方法"}},[e._v("#")]),e._v(" 重写 prompt 等原生 JS 方法")]),e._v(" "),a("ul",[a("li",[e._v("Android 4.2 之前注入对象的接口是 addJavascriptInterface ，但是由于安全原因慢慢不被使用。一般会通过修改浏览器的部分 Window 对象的方法来完成操作。主要是拦截 alert、confirm、prompt、console.log 四个方法，分别被 "),a("code",[e._v("Webview")]),e._v(" 的 onJsAlert、onJsConfirm、onConsoleMessage、onJsPrompt 监听。")]),e._v(" "),a("li",[e._v("iOS 由于安全机制，"),a("code",[e._v("WKWebView")]),e._v(" 对 alert、confirm、prompt 等方法做了拦截，如果通过此方式进行 Native 与 JS 交互，需要实现 "),a("code",[e._v("WKWebView")]),e._v(" 的三个 "),a("code",[e._v("WKUIDelegate")]),e._v(" 代理方法。")])]),e._v(" "),a("p",[e._v("使用该方式时，可以与 Android 和 iOS 约定好使用传参的格式，这样 H5 可以无需识别客户端，传入不同参数直接调用 Native 即可。剩下的交给客户端自己去拦截相同的方法，识别相同的参数，进行自己的处理逻辑即可实现多端表现一致。另外，如果能与 Native 确定好方法名、传参等调用的协议规范，这样其它格式的 prompt 等方法是不会被识别的，能起到隔离的作用。")]),e._v(" "),a("h4",{attrs:{id:"注入-api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#注入-api"}},[e._v("#")]),e._v(" 注入 API")]),e._v(" "),a("p",[e._v("这个方法会通过 webView 提供的接口，App 将 Native 的相关接口注入到 JS 的 Context（window）的对象中，一般来说这个对象内的方法名与 Native 相关方法名是相同的，Web 端就可以直接在全局 "),a("strong",[e._v("window")]),e._v(" 下使用这个暴露的全局 JS 对象，进而调用原生端的方法。")]),e._v(" "),a("ul",[a("li",[e._v("Android 的 "),a("code",[e._v("Webview")]),e._v(" 提供了 "),a("code",[e._v("addJavascriptInterface")]),e._v(" 方法，支持 Android 4.2 及以上系统。")]),e._v(" "),a("li",[e._v("iOS 的 "),a("code",[e._v("UIWebview")]),e._v(" 提供了 "),a("code",[e._v("JavaScriptScore")]),e._v(" 方法，支持 iOS 7.0 及以上系统。"),a("code",[e._v("WKWebview")]),e._v(" 提供了 "),a("code",[e._v("window.webkit.messageHandlers")]),e._v(" 方法，支持 iOS 8.0 及以上系统。"),a("code",[e._v("UIWebview")]),e._v(" 在几年前常用，目前已不常见。")])]),e._v(" "),a("h3",{attrs:{id:"native-调用-js"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#native-调用-js"}},[e._v("#")]),e._v(" Native 调用 JS")]),e._v(" "),a("p",[e._v("Native 调用 JS 比较简单，只要 H5 将 JS 方法暴露在 Window 上给 Native 调用即可。")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("Android 中主要有两种方式实现。在 4.4 以前，通过 "),a("code",[e._v("loadUrl")]),e._v(" 方法，执行一段 JS 代码来实现。在 4.4 以后，可以使用 "),a("code",[e._v("evaluateJavascript")]),e._v(" 方法实现。"),a("code",[e._v("loadUrl")]),e._v(" 方法使用起来方便简洁，但是效率低无法获得返回结果且调用的时候会刷新 WebView。"),a("code",[e._v("evaluateJavascript")]),e._v(" 方法效率高获取返回值方便，调用时候不刷新 WebView，但是只支持 Android 4.4+。")])]),e._v(" "),a("li",[a("p",[e._v("iOS 在 "),a("code",[e._v("UIWebView")]),e._v(" 使用 "),a("code",[e._v("stringByEvaluatingJavaScriptFromString")]),e._v(" 实现。在 "),a("code",[e._v("WKWebview")]),e._v(" 中可以通过 "),a("code",[e._v("evaluateJavaScript:javaScriptString")]),e._v(" 来实现，且支持 iOS 8.0 及以上系统。")])])]),e._v(" "),a("h2",{attrs:{id:"jsbridge-的使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jsbridge-的使用"}},[e._v("#")]),e._v(" JSBridge 的使用")]),e._v(" "),a("h3",{attrs:{id:"webview-调用-native"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webview-调用-native"}},[e._v("#")]),e._v(" webview 调用 native")]),e._v(" "),a("p",[e._v("当 webview 调用 native 时，会调用 "),a("code",[e._v("callHandler")]),e._v(" 方法。实际上就是先生成一个 message，然后 push 到 "),a("code",[e._v("sendMessageQueue")]),e._v(" 里，然后更改 iframe 的 "),a("code",[e._v("src")]),e._v("。然后，当 native 端检测到 "),a("code",[e._v("iframe src")]),e._v(" 的变化时，会走到 "),a("code",[e._v("isQueueMessageURL")]),e._v(" 的判断逻辑，然后执行 "),a("code",[e._v("WKFlushMessageQueue")]),e._v(" 函数，获取到 JS 侧的 "),a("code",[e._v("sendMessageQueue")]),e._v(" 中的所有 message。")]),e._v(" "),a("p",[e._v("当一个 message 结构存在 responseId 的时候说明这个 message 是执行 bridge 后传回的。取不到 responseId 说明是第一次调用 bridge 传过来的，这个时候会生成一个返回给调用方的 message，其 reponseId 是传过来的 message 的 callbackId，当 native 执行 responseCallback 时，会触发 _dispatchMessage 方法执行 webview 环境的的 js 逻辑，将生成的包含 responseId 的 message 返回给webview。")]),e._v(" "),a("p",[e._v("如果从 native 获取到的 message 中有 responseId，说明这个 message 是 JS 调 Native 之后回调接收的 message，所以从一开始 sendData 中添加的 responseCallbacks 中根据 responseId（一开始存的时候是用的callbackId，两个值是相同的）取出这个回调函数并执行，这样就完成了一次 JS 调用 Native 的流程。")]),e._v(" "),a("p",[a("img",{attrs:{src:"/blog/images/mobile/jsbridge2.png",alt:"jsbridge2"}})]),e._v(" "),a("p",[e._v("1、native 端注册 jsb。")]),e._v(" "),a("p",[e._v("2、webview 侧创建 iframe，设置 src 为 "),a("code",[e._v("__bridge_load__。")])]),e._v(" "),a("p",[e._v("3、native 端捕获请求，注入jsb初始化代码，在window上挂载相关对象和方法。")]),e._v(" "),a("p",[e._v("4、webview 侧调用 "),a("code",[e._v("callHandler")]),e._v("方法，并在 "),a("code",[e._v("responseCallback")]),e._v(" 上添加 "),a("code",[e._v("callbackId: responseCallback")]),e._v("，并修改 iframe 的 src，触发捕获。")]),e._v(" "),a("p",[e._v("5、native 收到 message，生成一个 "),a("code",[e._v("responseCallback")]),e._v("，并执行 native 侧注册好的方法")]),e._v(" "),a("p",[e._v("6、native 执行完毕后，通过 webview 执行"),a("code",[e._v("_handleMessageFromObjC")]),e._v("方法，取出 callback 函数，并执行。")]),e._v(" "),a("h4",{attrs:{id:"优缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优缺点"}},[e._v("#")]),e._v(" 优缺点")]),e._v(" "),a("ul",[a("li",[e._v("优点：JavaScript 端可以确定 JSBridge 的存在，直接调用即可。")]),e._v(" "),a("li",[e._v("缺点：如果桥的实现方式有更改，JSBridge 需要兼容多版本的 Native Bridge 或者 Native Bridge 兼容多版本的 JSBridge。。")])]),e._v(" "),a("h3",{attrs:{id:"native-调用-webview"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#native-调用-webview"}},[e._v("#")]),e._v(" native 调用 webview")]),e._v(" "),a("p",[e._v("native 调用 webview 注册的 jsb 的逻辑是相似的，不过就不是通过触发 iframe 的 src 触发执行的了，因为 Native 可以自己主动调用 JS侧的方法。其具体过程如下图：")]),e._v(" "),a("p",[a("img",{attrs:{src:"/blog/images/mobile/jsbridge3.png",alt:"jsbridge3"}})]),e._v(" "),a("p",[e._v("1、native 侧调用"),a("code",[e._v("callHandler")]),e._v("方法，并在 "),a("code",[e._v("responseCallback")]),e._v("上添加 "),a("code",[e._v("callbackId: responseCallback")]),e._v("。")]),e._v(" "),a("p",[e._v("2、native 侧主动调用 "),a("code",[e._v("_handleMessageFromObjC")]),e._v(" 方法，在webview中执行对应的逻辑。")]),e._v(" "),a("p",[e._v("3、webview 侧执行结束后，生成带有 "),a("code",[e._v("responseId")]),e._v(" 的 message，添加到 "),a("code",[e._v("sendMessageQueue")]),e._v(" 中，并修改 iframe 的 src 为"),a("code",[e._v("__wvjb_queue_message__")]),e._v("。")]),e._v(" "),a("p",[e._v("4、native 端拦截到 url 变化，调用 webview 的逻辑获取到 message，拿到 "),a("code",[e._v("responseId")]),e._v("，并执行对应的 callback 函数。")]),e._v(" "),a("h4",{attrs:{id:"优缺点-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优缺点-2"}},[e._v("#")]),e._v(" 优缺点")]),e._v(" "),a("ul",[a("li",[e._v("优点：桥的版本很容易与 Native 保持一致，Native 端不用对不同版本的 JSBridge 进行兼容。")]),e._v(" "),a("li",[e._v("缺点：注入时机不确定，需要实现注入失败后重试的机制，保证注入的成功率，同时 JavaScript 端在调用接口时，需要优先判断 JSBridge 是否已经注入成功。")])]),e._v(" "),a("p",[a("a",{attrs:{href:"https://juejin.cn/post/6844904070881214471#heading-8",target:"_blank",rel:"noopener noreferrer"}},[e._v("JSBridge 初探"),a("OutboundLink")],1)]),e._v(" "),a("p",[a("a",{attrs:{href:"https://juejin.cn/post/7177407635317063735",target:"_blank",rel:"noopener noreferrer"}},[e._v("App实现JSBridge的最佳方案"),a("OutboundLink")],1)]),e._v(" "),a("p",[a("a",{attrs:{href:"https://juejin.cn/post/6844903491970793480#heading-1",target:"_blank",rel:"noopener noreferrer"}},[e._v("H5 与 Native 交互之 JSBridge 技术"),a("OutboundLink")],1)])])}),[],!1,null,null,null);v.default=t.exports}}]);