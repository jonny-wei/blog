(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{489:function(t,a,s){"use strict";s.r(a);var r=s(14),v=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"参数传递与-arguments"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参数传递与-arguments"}},[t._v("#")]),t._v(" 参数传递与 Arguments")]),t._v(" "),s("h2",{attrs:{id:"参数按值传递"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参数按值传递"}},[t._v("#")]),t._v(" 参数按值传递")]),t._v(" "),s("p",[t._v("ECMAScript 中所有的函数的参数都是按值传递的。")]),t._v(" "),s("p",[t._v("一般参数传递方式有以下 3 种：")]),t._v(" "),s("ul",[s("li",[t._v("按值传递指：把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量，不影响原来的值。")]),t._v(" "),s("li",[t._v("按引用传递：传递对象的引用，堆中对象在栈中的地址值，所以函数内部对参数的改变都会影响该对象的值，两个是引用的同一对象。")]),t._v(" "),s("li",[t._v("按共享传递：传递对象的引用副本，函数内对参数的修改不会影响原来的对象，所以也是值传递。")])]),t._v(" "),s("p",[t._v("但 JS 中值类型（基本数据类型）按值传递；引用类型按共享传递（传拷贝后的引用的副本，拷贝的过程就是值传递，所以本质也是值传递）")]),t._v(" "),s("p",[t._v("综上，javaScript参数如果是值类型按值传递；如果是引用类型按共享传递。")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("注意")]),t._v(" "),s("p",[t._v("按引用传递是传递对象的引用，而按共享传递是传递对象的引用的副本！\n引用传递，不产生副本，会修改原值；共享传递，产生引用的副本，不会修改原值")]),t._v(" "),s("p",[t._v("参数如果是基本类型是按值传递，如果是引用类型按共享传递。\n但是因为拷贝副本也是一种值的拷贝，所以在高程中也直接认为是按值传递了。")])]),t._v(" "),s("p",[t._v("很多人还认为按引用传递也是按值传递，只是值是指针而已，这个说法也对，只是我们把所有的情况都归到按值传递上，看似统一了，但是如果我们要分析具体的情况时，一句按值传递可不好让人清晰的明白问题呐，所以才有了按引用传递和按共享传递的概念的出现。")]),t._v(" "),s("p",[t._v("毕竟值类型的值传递和引用类型的值传递在内存栈上的拷贝方式是完全相同的, 唯一差别就在于值类型和引用类型的差别了。")]),t._v(" "),s("h2",{attrs:{id:"类数组对象与-arguments"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#类数组对象与-arguments"}},[t._v("#")]),t._v(" 类数组对象与 arguments")]),t._v(" "),s("h3",{attrs:{id:"什么是类数组对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是类数组对象"}},[t._v("#")]),t._v(" 什么是类数组对象")]),t._v(" "),s("p",[t._v("用于一个 length 属性和若干索引属性的对象。类数组对象可以进行"),s("strong",[t._v("读写")]),t._v("，"),s("strong",[t._v("获取长度")]),t._v("，"),s("strong",[t._v("遍历")]),t._v(" 3个方面，"),s("strong",[t._v("但不能使用数组的方法")]),t._v("。如果非要使用数组的方法可以通过 call() 等函数。")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("类数组转数组")]),t._v(" "),s("ul",[s("li",[t._v("Array.prototype.slice.call(arrayLike);")]),t._v(" "),s("li",[t._v("Array.prototype.splice.call(arrayLike, 0);")]),t._v(" "),s("li",[t._v("Array.from(arrayLike);")]),t._v(" "),s("li",[t._v("Array.prototype.concat.apply([], arrayLike)")]),t._v(" "),s("li",[t._v("ES6的 ... 运算符")])])]),t._v(" "),s("h3",{attrs:{id:"arguments-对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#arguments-对象"}},[t._v("#")]),t._v(" Arguments 对象")]),t._v(" "),s("p",[t._v("Arguments 对象只定义在函数体中，包括了函数的参数和其他属性。在函数体中，arguments 指代该函数的 Arguments 对象。")]),t._v(" "),s("p",[t._v("Arguments 对象的属性：")]),t._v(" "),s("ul",[s("li",[t._v("length属性：表示实参的长度")]),t._v(" "),s("li",[t._v("callee属性：通过 callee 可以调用函数自身")])]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("注意")]),t._v(" "),s("p",[t._v("Arguments 和对应参数的绑定：传入的参数，实参和 arguments 的值会共享，当没有传入时，实参与 arguments 值不会共享。除此之外，以上是在非严格模式下，如果是在严格模式下，实参和 arguments 是不会共享的。")])]),t._v(" "),s("p",[t._v("Arguments的应用场景：")]),t._v(" "),s("ul",[s("li",[t._v("参数不定长")]),t._v(" "),s("li",[t._v("函数柯里化")]),t._v(" "),s("li",[t._v("递归调用")]),t._v(" "),s("li",[t._v("函数重载")])]),t._v(" "),s("p",[t._v("等等。。。")]),t._v(" "),s("div",{staticClass:"custom-block warning"},[s("p",{staticClass:"custom-block-title"},[t._v("参考文献")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://github.com/mqyqingfeng/Blog/issues/10",target:"_blank",rel:"noopener noreferrer"}},[t._v("JavaScript深入之参数按值传递"),s("OutboundLink")],1)]),t._v(" "),s("p",[s("a",{attrs:{href:"https://github.com/mqyqingfeng/Blog/issues/14",target:"_blank",rel:"noopener noreferrer"}},[t._v("JavaScript深入之类数组对象与arguments "),s("OutboundLink")],1)])])])}),[],!1,null,null,null);a.default=v.exports}}]);