(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{513:function(t,v,_){"use strict";_.r(v);var a=_(15),s=Object(a.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"浏览器安全机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#浏览器安全机制"}},[t._v("#")]),t._v(" 浏览器安全机制")]),t._v(" "),_("p",[t._v("浏览器安全可以分为三大块：")]),t._v(" "),_("ul",[_("li",[t._v("Web 页面安全")]),t._v(" "),_("li",[t._v("Web 网络安全")]),t._v(" "),_("li",[t._v("浏览器系统安全")])]),t._v(" "),_("p",[t._v("在web页面中的安全策略中最基础、最核心的安全策略：同源策略（Same-origin policy）。")]),t._v(" "),_("p",[_("img",{attrs:{src:"/blog/images/javascript/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8.png",alt:"浏览器安全"}})]),t._v(" "),_("h2",{attrs:{id:"web-页面安全"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#web-页面安全"}},[t._v("#")]),t._v(" Web 页面安全")]),t._v(" "),_("h3",{attrs:{id:"同源策略-same-origin-policy"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#同源策略-same-origin-policy"}},[t._v("#")]),t._v(" 同源策略（Same-origin policy）")]),t._v(" "),_("p",[t._v("如果两个 URL 的协议、域名和端口都相同，我们就称这两个 URL 同源。浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的。两个不同的源之间若想要相互访问资源或者操作 DOM，那么会有一套基础的安全策略的制约，我们把这称为"),_("strong",[t._v("同源策略")]),t._v("。")]),t._v(" "),_("h3",{attrs:{id:"主要表现"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#主要表现"}},[t._v("#")]),t._v(" 主要表现")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("DOM 层面")]),t._v(" "),_("p",[t._v("同源策略限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作。")])]),t._v(" "),_("li",[_("p",[t._v("数据层面")]),t._v(" "),_("p",[t._v("同源策略限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据。")])]),t._v(" "),_("li",[_("p",[t._v("网络层面")]),t._v(" "),_("p",[t._v("同源策略限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点")])])]),t._v(" "),_("p",[t._v("不过安全性和便利性是相互对立的，让不同的源之间绝对隔离，无疑是最安全的措施，但这也会使得 Web 项目难以开发和使用。因此我们就要在这之间做出权衡，出让一些安全性来满足灵活性：")]),t._v(" "),_("h3",{attrs:{id:"安全后门"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#安全后门"}},[t._v("#")]),t._v(" 安全后门")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("页面中可以嵌入第三方资源")]),t._v(" "),_("p",[t._v("页面中可以引用第三方资源，不过这也暴露了很多诸如 XSS 的安全问题，因此又在这种开放的基础之上引入了 CSP （内容安全策略）来限制其自由程度。"),_("strong",[t._v("CSP 的核心思想")]),t._v("是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 JavaScript 代码 。")])]),t._v(" "),_("li",[_("p",[t._v("跨文档消息机制")]),t._v(" "),_("p",[t._v("两个不同源的 DOM 是不能相互操纵的，浏览器中又引入了跨文档消息机制，可以通过 window.postMessage 的 JavaScript 接口来和不同源的 DOM 进行通信。")])]),t._v(" "),_("li",[_("p",[t._v("跨域资源共享")]),t._v(" "),_("p",[t._v("不同域之间使用 XMLHttpRequest 和 Fetch 都是无法直接进行跨域请求的，浏览器又在这种严格策略的基础之上引入了"),_("strong",[t._v("跨域资源共享策略（CORS）")]),t._v("，使用该机制可以进行跨域访问控制，从而使跨域数据传输得以安全进行。")])])]),t._v(" "),_("h2",{attrs:{id:"web-网络安全"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#web-网络安全"}},[t._v("#")]),t._v(" Web 网络安全")]),t._v(" "),_("p",[t._v("我们使用 HTTP 传输的内容很容易被中间人窃取、伪造和篡改，通常我们把这种攻击方式称为中间人攻击。具体来讲，在将 HTTP 数据提交给 TCP 层之后，数据会经过用户电脑、WiFi 路由器、运营商和目标服务器，在这中间的每个环节中，数据都有可能被窃取或篡改。比如用户电脑被黑客安装了恶意软件，那么恶意软件就能抓取和篡改所发出的 HTTP 请求的内容。或者用户一不小心连接上了 WiFi 钓鱼路由器，那么数据也都能被黑客抓取或篡改。")]),t._v(" "),_("h3",{attrs:{id:"http-协议栈引入安全层"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-协议栈引入安全层"}},[t._v("#")]),t._v(" HTTP 协议栈引入安全层")]),t._v(" "),_("p",[t._v("鉴于 HTTP 的明文传输使得传输过程毫无安全性可言，且制约了网上购物、在线转账等一系列场景应用，于是倒逼着我们要引入加密方案。从 HTTP 协议栈层面来看，我们可以在 TCP 和 HTTP 之间插入一个安全层，所有经过安全层的数据都会被加密或者解密。安全层有两个主要的职责：对发起 HTTP 请求的数据进行加密操作和对接收到 HTTP 的内容进行解密操作。")]),t._v(" "),_("p",[_("img",{attrs:{src:"/blog/images/javascript/http%E5%AE%89%E5%85%A8%E5%B1%82.png",alt:"http安全层"}})]),t._v(" "),_("h3",{attrs:{id:"https-传输数据"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#https-传输数据"}},[t._v("#")]),t._v(" HTTPS 传输数据")]),t._v(" "),_("p",[_("img",{attrs:{src:"/blog/images/javascript/https%E4%BC%A0%E8%BE%93.png",alt:"https传输"}})]),t._v(" "),_("p",[t._v("在传输数据阶段依然使用对称加密，但是对称加密的密钥我们采用非对称加密来传输")]),t._v(" "),_("ul",[_("li",[t._v("首先浏览器向服务器发送对称加密套件列表、非对称加密套件列表和随机数 client-random。")]),t._v(" "),_("li",[t._v("服务器保存随机数 client-random，选择对称加密和非对称加密的套件，然后生成随机数 service-random，向浏览器发送选择的加密套件、service-random 和公钥。")]),t._v(" "),_("li",[t._v("浏览器保存公钥，并生成随机数 pre-master，然后利用公钥对 pre-master 加密，并向服务器发送加密后的数据。")]),t._v(" "),_("li",[t._v("最后服务器拿出自己的私钥，解密出 pre-master 数据，并返回确认消息。")])]),t._v(" "),_("h4",{attrs:{id:"数字证书"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数字证书"}},[t._v("#")]),t._v(" 数字证书")]),t._v(" "),_("p",[t._v("通过上面的方式我们实现了数据的加密传输，不过这种方式依然存在着问题，黑客通过 DNS 劫持将网址的 IP 地址替换成了黑客的 IP 地址，这样访问的其实是黑客的服务器了，黑客就可以在自己的服务器上实现公钥和私钥，而对浏览器来说，它完全不知道现在访问的是个黑客的站点。所以我们还需要服务器向浏览器提供证明“我就是我”。证明我就是我需要使用权威机构颁发的证书，这个权威机构称为 CA（Certificate Authority），颁发的证书就称为"),_("strong",[t._v("数字证书（Digital Certificate)")]),t._v("。")]),t._v(" "),_("p",[t._v("数字证书有两个作用：")]),t._v(" "),_("ul",[_("li",[t._v("通过数字证书向浏览器证明服务器的身份")]),t._v(" "),_("li",[t._v("数字证书里面包含了服务器公钥。")])]),t._v(" "),_("p",[_("img",{attrs:{src:"/blog/images/javascript/https%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6.png",alt:"https数字证书"}})]),t._v(" "),_("p",[t._v("通过引入数字证书，我们就实现了服务器的身份认证功能，这样即便黑客伪造了服务器，但是由于证书是没有办法伪造的，所以依然无法欺骗用户。")]),t._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[t._v("小结")]),t._v(" "),_("p",[t._v("我们使用对称加密实现了安全层，但是由于对称加密的密钥需要明文传输，所以我们又将对称加密改造成了非对称加密。但是非对称加密效率低且不能加密服务器到浏览器端的数据，于是我们又继续改在安全层，采用对称加密的方式加密传输数据和非对称加密的方式来传输密钥，这样我们就解决传输效率和两端数据安全传输的问题。采用这种方式虽然能保证数据的安全传输，但是依然没办法证明服务器是可靠的，于是又引入了数字证书，数字证书是由 CA 签名过的，所以浏览器能够验证该证书的可靠性")])]),t._v(" "),_("h2",{attrs:{id:"浏览器系统安全"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#浏览器系统安全"}},[t._v("#")]),t._v(" 浏览器系统安全")]),t._v(" "),_("h3",{attrs:{id:"浏览器安全架构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#浏览器安全架构"}},[t._v("#")]),t._v(" 浏览器安全架构")]),t._v(" "),_("p",[t._v("如果浏览器被曝出存在漏洞，那么在这些漏洞没有被及时修复的情况下，黑客就有可能通过恶意的页面向浏览器中注入恶意程序，其中最常见的攻击方式是利用"),_("strong",[t._v("缓冲区溢出")]),t._v("。和 XSS 攻击页面相比，这类攻击无疑是枚“核弹”，它会将整个操作系统的内容都暴露给黑客，这样我们操作系统上所有的资料都是不安全的了。为了提高安全性，浏览器的采用了如下的多进程架构。并且提供了 "),_("strong",[t._v("安全沙箱")]),t._v(" 和 "),_("strong",[t._v("站点隔离")]),t._v(" 来进一步加强安全")]),t._v(" "),_("p",[_("img",{attrs:{src:"/blog/images/javascript/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8%E6%9E%B6%E6%9E%84.png",alt:"浏览器安全架构"}})]),t._v(" "),_("h3",{attrs:{id:"安全沙箱"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#安全沙箱"}},[t._v("#")]),t._v(" 安全沙箱")]),t._v(" "),_("p",[t._v("由于渲染进程需要执行 DOM 解析、CSS 解析、网络图片解码等操作，如果"),_("strong",[t._v("渲染进程")]),t._v("中存在"),_("strong",[t._v("系统级别的漏洞")]),t._v("，那么以上操作就有可能让恶意的站点获取到渲染进程的控制权限，进而又获取操作系统的"),_("strong",[t._v("控制权限")]),t._v("，这对于用户来说是非常危险的。")]),t._v(" "),_("p",[t._v("基于以上原因，我们需要在渲染进程和操作系统之间建一道墙，即便渲染进程由于存在漏洞被黑客攻击，但由于这道墙，黑客就获取不到渲染进程之外的任何操作权限。将渲染进程和操作系统隔离的这道墙就是我们要聊的"),_("strong",[t._v("安全沙箱")]),t._v("。")]),t._v(" "),_("p",[_("strong",[t._v("浏览器中的安全沙箱")]),t._v(" 是利用操作系统提供的安全技术，让渲染进程在执行过程中无法访问或者修改操作系统中的数据，在渲染进程需要访问系统资源的时候，需要 "),_("strong",[t._v("通过浏览器内核来实现")]),t._v("，然后将访问的结果通过 "),_("strong",[t._v("IPC 转发")]),t._v(" 给渲染进程。")]),t._v(" "),_("p",[t._v("安全沙箱最小的保护单位是进程。因为单进程浏览器需要频繁访问或者修改操作系统的数据，所以单进程浏览器是无法被安全沙箱保护的，而现代浏览器采用的多进程架构使得安全沙箱可以发挥作用。")]),t._v(" "),_("h4",{attrs:{id:"安全沙箱影响的模块功能"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#安全沙箱影响的模块功能"}},[t._v("#")]),t._v(" 安全沙箱影响的模块功能")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("持久存储")]),t._v(" "),_("p",[t._v("存储 Cookie 数据的读写。通常浏览器内核会维护一个存放所有 Cookie 的 Cookie 数据库，然后当渲染进程通过 JavaScript 来读取 Cookie 时，渲染进程会通过 IPC 将读取 Cookie 的信息发送给浏览器内核，浏览器内核读取 Cookie 之后再将内容返回给渲染进程。一些缓存文件的读写也是由浏览器内核实现的，比如网络文件缓存的读取。")])]),t._v(" "),_("li",[_("p",[t._v("网络访问")]),t._v(" "),_("p",[t._v("同样有了安全沙箱的保护，在渲染进程内部也是不能直接访问网络的，如果要访问网络，则需要通过浏览器内核。不过浏览器内核在处理 URL 请求之前，会检查渲染进程是否有权限请求该 URL，比如检查 XMLHttpRequest 或者 Fetch 是否是跨站点请求，或者检测 HTTPS 的站点中是否包含了 HTTP 的请求。")])]),t._v(" "),_("li",[_("p",[t._v("用户交互")]),t._v(" "),_("p",[t._v("为了限制渲染进程有监控到用户输入事件的能力，所以所有的键盘鼠标事件都是由浏览器内核来接收的，然后浏览器内核再通过 IPC 将这些事件发送给渲染进程。")]),t._v(" "),_("p",[t._v("渲染进程需要渲染出位图。为了向用户显示渲染进程渲染出来的位图，渲染进程需要将生成好的位图发送到浏览器内核，然后浏览器内核将位图复制到屏幕上。")]),t._v(" "),_("p",[t._v("操作系统没有将用户输入事件直接传递给渲染进程，而是将这些事件传递给浏览器内核。然后浏览器内核再根据当前浏览器界面的状态来判断如何调度这些事件，如果当前焦点位于浏览器地址栏中，则输入事件会在浏览器内核内部处理；如果当前焦点在页面的区域内，则浏览器内核会将输入事件转发给渲染进程。")])])]),t._v(" "),_("h3",{attrs:{id:"站点隔离"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#站点隔离"}},[t._v("#")]),t._v(" 站点隔离")]),t._v(" "),_("p",[t._v("所谓站点隔离是指 Chrome 将同一站点（包含了相同根域名和相同协议的地址）中相互关联的页面放到同一个渲染进程中执行。由于最初都是按照标签页来划分渲染进程的，所以如果一个标签页里面有多个不同源的 iframe，那么这些 iframe 也会被分配到同一个渲染进程中，这样就很容易让黑客通过 iframe 来攻击当前渲染进程。而站点隔离会将不同源的 iframe 分配到不同的渲染进程中，这样即使黑客攻击恶意 iframe 的渲染进程，也不会影响到其他渲染进程的。")])])}),[],!1,null,null,null);v.default=s.exports}}]);